{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-cf0711d30da8a7e5.js","src/js/helper.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","src/js/view.js","src/js/backend.js","node_modules/pocketbase/dist/pocketbase.es.mjs","node_modules/pocketbase/src/ClientResponseError.ts","node_modules/pocketbase/src/stores/utils/cookie.ts","node_modules/pocketbase/src/stores/utils/jwt.ts","node_modules/pocketbase/src/stores/BaseAuthStore.ts","node_modules/pocketbase/src/stores/LocalAuthStore.ts","node_modules/pocketbase/src/services/utils/BaseService.ts","node_modules/pocketbase/src/services/SettingsService.ts","node_modules/pocketbase/src/services/utils/CrudService.ts","node_modules/pocketbase/src/services/utils/legacy.ts","node_modules/pocketbase/src/services/utils/refresh.ts","node_modules/pocketbase/src/services/AdminService.ts","node_modules/pocketbase/src/services/utils/options.ts","node_modules/pocketbase/src/services/RealtimeService.ts","node_modules/pocketbase/src/services/RecordService.ts","node_modules/pocketbase/src/services/CollectionService.ts","node_modules/pocketbase/src/services/LogService.ts","node_modules/pocketbase/src/services/HealthService.ts","node_modules/pocketbase/src/services/FileService.ts","node_modules/pocketbase/src/services/BackupService.ts","node_modules/pocketbase/src/Client.ts","node_modules/pocketbase/src/stores/AsyncAuthStore.ts"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SECURE = false;var HMR_ENV_HASH = \"d6ea1d42532a7575\";var HMR_USE_SSE = false;module.bundle.HMR_BUNDLE_ID = \"c0729ae2298f60af\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: {|[string]: mixed|};\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var HMR_USE_SSE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData[moduleName],\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData[moduleName] = undefined;\n}\nmodule.bundle.Module = Module;\nmodule.bundle.hotData = {};\nvar checkedAssets /*: {|[string]: boolean|} */, assetsToDispose /*: Array<[ParcelRequire, string]> */, assetsToAccept /*: Array<[ParcelRequire, string]> */;\n\nfunction getHostname() {\n  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\nfunction getPort() {\n  return HMR_PORT || location.port;\n}\n\n// eslint-disable-next-line no-redeclare\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = getHostname();\n  var port = getPort();\n  var protocol = HMR_SECURE || location.protocol == 'https:' && !['localhost', '127.0.0.1', '0.0.0.0'].includes(hostname) ? 'wss' : 'ws';\n  var ws;\n  if (HMR_USE_SSE) {\n    ws = new EventSource('/__parcel_hmr');\n  } else {\n    try {\n      ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');\n    } catch (err) {\n      if (err.message) {\n        console.error(err.message);\n      }\n      ws = {};\n    }\n  }\n\n  // Web extension context\n  var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;\n\n  // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n  var supportsSourceURL = false;\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  }\n\n  // $FlowFixMe\n  ws.onmessage = async function (event /*: {data: string, ...} */) {\n    checkedAssets = {} /*: {|[string]: boolean|} */;\n    assetsToAccept = [];\n    assetsToDispose = [];\n    var data /*: HMRMessage */ = JSON.parse(event.data);\n    if (data.type === 'update') {\n      // Remove error overlay if there is one\n      if (typeof document !== 'undefined') {\n        removeErrorOverlay();\n      }\n      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH);\n\n      // Handle HMR Update\n      let handled = assets.every(asset => {\n        return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n      });\n      if (handled) {\n        console.clear();\n\n        // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n        if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n          window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n        }\n        await hmrApplyUpdates(assets);\n\n        // Dispose all old assets.\n        let processedAssets = {} /*: {|[string]: boolean|} */;\n        for (let i = 0; i < assetsToDispose.length; i++) {\n          let id = assetsToDispose[i][1];\n          if (!processedAssets[id]) {\n            hmrDispose(assetsToDispose[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n\n        // Run accept callbacks. This will also re-execute other disposed assets in topological order.\n        processedAssets = {};\n        for (let i = 0; i < assetsToAccept.length; i++) {\n          let id = assetsToAccept[i][1];\n          if (!processedAssets[id]) {\n            hmrAccept(assetsToAccept[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n      } else fullReload();\n    }\n    if (data.type === 'error') {\n      // Log parcel errors to console\n      for (let ansiDiagnostic of data.diagnostics.ansi) {\n        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n        console.error(' [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n      }\n      if (typeof document !== 'undefined') {\n        // Render the fancy html overlay\n        removeErrorOverlay();\n        var overlay = createErrorOverlay(data.diagnostics.html);\n        // $FlowFixMe\n        document.body.appendChild(overlay);\n      }\n    }\n  };\n  if (ws instanceof WebSocket) {\n    ws.onerror = function (e) {\n      if (e.message) {\n        console.error(e.message);\n      }\n    };\n    ws.onclose = function () {\n      console.warn('[parcel]  Connection to the HMR server was lost');\n    };\n  }\n}\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel]  Error resolved');\n  }\n}\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n           ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div> ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div> <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\nfunction fullReload() {\n  if ('reload' in location) {\n    location.reload();\n  } else if (extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  }\n}\nfunction getParents(bundle, id) /*: Array<[ParcelRequire, string]> */{\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n  var parents = [];\n  var k, d, dep;\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n  return parents;\n}\nfunction updateLink(link) {\n  var href = link.getAttribute('href');\n  if (!href) {\n    return;\n  }\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n  newLink.setAttribute('href',\n  // $FlowFixMe\n  href.split('?')[0] + '?' + Date.now());\n  // $FlowFixMe\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href /*: string */ = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n    cssTimeout = null;\n  }, 50);\n}\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n      return new Promise((resolve, reject) => {\n        var _document$head;\n        script.onload = () => resolve(script);\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension fix\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n            extCtx.runtime.reload();\n            return;\n          }\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n          (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\nfunction hmrApply(bundle /*: ParcelRequire */, asset /*:  HMRAsset */) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      }\n\n      // $FlowFixMe\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    } else if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    }\n\n    // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n    delete modules[id];\n    delete bundle.cache[id];\n\n    // Now delete the orphans.\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\nfunction hmrAcceptCheck(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  }\n\n  // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n      parents.push(...p);\n    }\n  }\n  return accepted;\n}\nfunction hmrAcceptCheckOne(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      return true;\n    }\n    return hmrAcceptCheck(bundle.parent, id, depsByBundle);\n  }\n  if (checkedAssets[id]) {\n    return true;\n  }\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  assetsToDispose.push([bundle, id]);\n  if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {\n    assetsToAccept.push([bundle, id]);\n    return true;\n  }\n}\nfunction hmrDispose(bundle /*: ParcelRequire */, id /*: string */) {\n  var cached = bundle.cache[id];\n  bundle.hotData[id] = {};\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData[id];\n  }\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData[id]);\n    });\n  }\n  delete bundle.cache[id];\n}\nfunction hmrAccept(bundle /*: ParcelRequire */, id /*: string */) {\n  // Execute the module.\n  bundle(id);\n\n  // Run the accept callbacks in the new version of the module.\n  var cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      var assetsToAlsoAccept = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n      if (assetsToAlsoAccept && assetsToAccept.length) {\n        assetsToAlsoAccept.forEach(function (a) {\n          hmrDispose(a[0], a[1]);\n        });\n\n        // $FlowFixMe[method-unbinding]\n        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);\n      }\n    });\n  }\n}","import view from './view';\n\nconst helper = (() => {\n  function buildPost(title, body, author, author_id) {\n    return {\n      title,\n      body,\n      author,\n      author_id,\n    };\n  }\n\n  function buildUser(name, username, password, passwordConfirm) {\n    return {\n      username,\n      emailVisibility: false,\n      password,\n      passwordConfirm,\n      name,\n      isAdmin: false,\n    };\n  }\n\n  function validateInput(input) {\n    const validity = input.validity;\n\n    // Validity Cases\n    if (validity.valid) return null;\n    if (validity.valueMissing) return 'Required';\n    if (validity.patternMismatch) {\n      if (input.name === 'name') return 'Please match format: John S';\n      if (input.name === 'username') return 'Should be lowercase, no spaces';\n    }\n    if (validity.tooShort) return 'Please use at least 5 characters';\n  }\n\n  function validateForm(form) {\n    const elements = form.elements;\n    const error = elements.passwordConfirm.previousElementSibling.children[0];\n\n    if (elements.password.value !== elements.passwordConfirm.value) {\n      console.log(error);\n      view.showError(error, 'Passwords do not match');\n      return false;\n    } else {\n      view.showError(error, '');\n    }\n\n    // Check form validity\n    return form.checkValidity();\n  }\n\n  return { buildPost, buildUser, validateInput, validateForm };\n})();\n\nexport default helper;\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","const view = (() => {\n  const buildPosts = (posts, currentUser) => {\n    // FUNCTION THE BUILDS POST IN UI\n    const postsContainer = document.getElementById('posts-container');\n\n    // Clear post in UI\n    clearPosts(postsContainer);\n\n    // Update UI to stay in sync with data\n    updateHeading(currentUser);\n    updateUI(currentUser);\n\n    for (let post of posts) {\n      const title = document.createElement('h2');\n      title.classList.add('post-title');\n      title.textContent = post.title;\n\n      const author = document.createElement('div');\n      author.classList.add('post-author');\n      author.textContent = post.author;\n\n      const date = document.createElement('div');\n      date.classList.add('post-date');\n      date.textContent = new Date(post.created).toDateString();\n\n      const byline = document.createElement('div');\n      byline.classList.add('post-byline');\n      byline.appendChild(author);\n      byline.appendChild(date);\n\n      // Render delete button is user is logged in, only renders on user's posts unless user is admin\n      if (\n        currentUser &&\n        (currentUser.id === post.author_id || currentUser.isAdmin)\n      ) {\n        const del = document.createElement('button');\n        del.classList.add('post-delete');\n        del.innerHTML = '<span></span>';\n        del.onclick = () => {\n          const deletionModal = document.getElementById('deletion-modal');\n          // set post_id data attribute to post id onclick. Used for post deletion\n          deletionModal.dataset.post_id = post.id;\n          openModal(deletionModal);\n        };\n        byline.appendChild(del);\n      }\n\n      const divider = document.createElement('div');\n      divider.classList.add('divider');\n\n      const body = document.createElement('div');\n      body.classList.add('post-body');\n      body.innerHTML = post.body;\n\n      const announcement = document.createElement('div');\n      announcement.classList.add('post');\n      announcement.dataset.author_id = post.author_id;\n      announcement.dataset.post_id = post.id;\n      announcement.appendChild(title);\n      announcement.appendChild(byline);\n      announcement.appendChild(divider);\n      announcement.appendChild(body);\n\n      postsContainer.appendChild(announcement);\n    }\n  };\n\n  const updateHeading = (currentUser) => {\n    const authHeading = document.getElementById('auth-heading');\n    const username = document.getElementById('current-username');\n    if (!currentUser) {\n      authHeading.style.display = 'none';\n      username.textContent = 'NO USER';\n      return;\n    }\n\n    authHeading.style.display = 'flex';\n    username.textContent = currentUser.name;\n    return;\n  };\n\n  const updateUI = (currentUser) => {\n    const button = document.getElementById('new-post-button');\n    if (!currentUser) {\n      button.textContent = 'Log In';\n    } else {\n      button.textContent = 'New Announcement';\n    }\n  };\n\n  const clearPosts = (parent) => {\n    while (parent.hasChildNodes()) {\n      parent.removeChild(parent.firstChild);\n    }\n  };\n\n  const openModal = (modal) => {\n    modal.showModal();\n  };\n\n  const closeModal = (modal) => {\n    modal.close();\n  };\n\n  const showError = (element, error) => {\n    element.textContent = error;\n  };\n\n  return { buildPosts, openModal, closeModal, showError };\n})();\n\nexport default view;\n","import PocketBase from 'pocketbase';\n\nconst url = 'https://mpls.pockethost.io/';\nconst pb = new PocketBase(url);\n\n// A MODULE TO HANDLE CALLS TO POCKETBASE BACKEND\nconst backend = (() => {\n  async function getPosts() {\n    try {\n      const records = await pb\n        .collection('posts')\n        .getFullList({ sort: '-created' });\n\n      return records;\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  async function pushPost(post) {\n    if (!backend.getCurrentUser()) return false;\n\n    try {\n      await pb.collection('posts').create(post);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  async function deletePost(id) {\n    if (!backend.getCurrentUser()) return false;\n\n    try {\n      await pb.collection('posts').delete(id);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  async function createUser(user) {\n    try {\n      // create user in backend\n      const record = await pb.collection('users').create(user);\n      return record;\n    } catch (error) {\n      // throw error\n      return error.data;\n    }\n  }\n\n  async function authUser(username, password) {\n    // Attempt to log in user.\n    // Return true if successful else return false\n    try {\n      const authData = await pb\n        .collection('users')\n        .authWithPassword(username, password);\n\n      return true;\n    } catch (error) {\n      console.log(error);\n      return false;\n    }\n  }\n\n  function getCurrentUser() {\n    // Check current user. Returns null if no user\n    return pb.authStore.model;\n  }\n\n  function logoutUser() {\n    return pb.authStore.clear();\n  }\n\n  return {\n    getPosts,\n    pushPost,\n    deletePost,\n    createUser,\n    authUser,\n    getCurrentUser,\n    logoutUser,\n  };\n})();\n\nexport default backend;\n",null,"/**\n * ClientResponseError is a custom Error class that is intended to wrap\n * and normalize any error thrown by `Client.send()`.\n */\nexport class ClientResponseError extends Error {\n    url: string = \"\";\n    status: number = 0;\n    response: { [key: string]: any } = {};\n    isAbort: boolean = false;\n    originalError: any = null;\n\n    constructor(errData?: any) {\n        super(\"ClientResponseError\");\n\n        // Set the prototype explicitly.\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, ClientResponseError.prototype);\n\n        if (errData !== null && typeof errData === \"object\") {\n            this.url = typeof errData.url === \"string\" ? errData.url : \"\";\n            this.status = typeof errData.status === \"number\" ? errData.status : 0;\n            this.isAbort = !!errData.isAbort;\n            this.originalError = errData.originalError;\n\n            if (errData.response !== null && typeof errData.response === \"object\") {\n                this.response = errData.response;\n            } else if (errData.data !== null && typeof errData.data === \"object\") {\n                this.response = errData.data;\n            } else {\n                this.response = {};\n            }\n        }\n\n        if (!this.originalError && !(errData instanceof ClientResponseError)) {\n            this.originalError = errData;\n        }\n\n        if (typeof DOMException !== \"undefined\" && errData instanceof DOMException) {\n            this.isAbort = true;\n        }\n\n        this.name = \"ClientResponseError \" + this.status;\n        this.message = this.response?.message;\n        if (!this.message) {\n            if (this.isAbort) {\n                this.message =\n                    \"The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation.\";\n            } else if (this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\")) {\n                this.message =\n                    \"Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).\";\n            } else {\n                this.message = \"Something went wrong while processing your request.\";\n            }\n        }\n    }\n\n    /**\n     * Alias for `this.response` to preserve the backward compatibility.\n     */\n    get data() {\n        return this.response;\n    }\n\n    /**\n     * Make a POJO's copy of the current error class instance.\n     * @see https://github.com/vuex-orm/vuex-orm/issues/255\n     */\n    toJSON() {\n        return { ...this };\n    }\n}\n","/**\n * -------------------------------------------------------------------\n * Simple cookie parse and serialize utilities mostly based on the\n * node module https://github.com/jshttp/cookie.\n * -------------------------------------------------------------------\n */\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nexport interface ParseOptions {\n    decode?: (val: string) => string;\n}\n\n/**\n * Parses the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nexport function cookieParse(str: string, options?: ParseOptions): { [key: string]: any } {\n    const result: { [key: string]: any } = {};\n\n    if (typeof str !== \"string\") {\n        return result;\n    }\n\n    const opt = Object.assign({}, options || {});\n    const decode = opt.decode || defaultDecode;\n\n    let index = 0;\n    while (index < str.length) {\n        const eqIdx = str.indexOf(\"=\", index);\n\n        // no more cookie pairs\n        if (eqIdx === -1) {\n            break;\n        }\n\n        let endIdx = str.indexOf(\";\", index);\n\n        if (endIdx === -1) {\n            endIdx = str.length;\n        } else if (endIdx < eqIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n\n        const key = str.slice(index, eqIdx).trim();\n\n        // only assign once\n        if (undefined === result[key]) {\n            let val = str.slice(eqIdx + 1, endIdx).trim();\n\n            // quoted values\n            if (val.charCodeAt(0) === 0x22) {\n                val = val.slice(1, -1);\n            }\n\n            try {\n                result[key] = decode(val);\n            } catch (_) {\n                result[key] = val; // no decoding\n            }\n        }\n\n        index = endIdx + 1;\n    }\n\n    return result;\n}\n\nexport interface SerializeOptions {\n    encode?: (val: string | number | boolean) => string;\n    maxAge?: number;\n    domain?: string;\n    path?: string;\n    expires?: Date;\n    httpOnly?: boolean;\n    secure?: boolean;\n    priority?: string;\n    sameSite?: boolean | string;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * ```js\n * cookieSerialize('foo', 'bar', { httpOnly: true }) // \"foo=bar; httpOnly\"\n * ```\n */\nexport function cookieSerialize(\n    name: string,\n    val: string,\n    options?: SerializeOptions,\n): string {\n    const opt = Object.assign({}, options || {});\n    const encode = opt.encode || defaultEncode;\n\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError(\"argument name is invalid\");\n    }\n\n    const value = encode(val);\n\n    if (value && !fieldContentRegExp.test(value)) {\n        throw new TypeError(\"argument val is invalid\");\n    }\n\n    let result = name + \"=\" + value;\n\n    if (opt.maxAge != null) {\n        const maxAge = opt.maxAge - 0;\n\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError(\"option maxAge is invalid\");\n        }\n\n        result += \"; Max-Age=\" + Math.floor(maxAge);\n    }\n\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError(\"option domain is invalid\");\n        }\n\n        result += \"; Domain=\" + opt.domain;\n    }\n\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError(\"option path is invalid\");\n        }\n\n        result += \"; Path=\" + opt.path;\n    }\n\n    if (opt.expires) {\n        if (!isDate(opt.expires) || isNaN(opt.expires.valueOf())) {\n            throw new TypeError(\"option expires is invalid\");\n        }\n\n        result += \"; Expires=\" + opt.expires.toUTCString();\n    }\n\n    if (opt.httpOnly) {\n        result += \"; HttpOnly\";\n    }\n\n    if (opt.secure) {\n        result += \"; Secure\";\n    }\n\n    if (opt.priority) {\n        const priority =\n            typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n\n        switch (priority) {\n            case \"low\":\n                result += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                result += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                result += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(\"option priority is invalid\");\n        }\n    }\n\n    if (opt.sameSite) {\n        const sameSite =\n            typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n        switch (sameSite) {\n            case true:\n                result += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                result += \"; SameSite=Lax\";\n                break;\n            case \"strict\":\n                result += \"; SameSite=Strict\";\n                break;\n            case \"none\":\n                result += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(\"option sameSite is invalid\");\n        }\n    }\n\n    return result;\n}\n\n/**\n * Default URL-decode string value function.\n * Optimized to skip native call when no `%`.\n */\nfunction defaultDecode(val: string): string {\n    return val.indexOf(\"%\") !== -1 ? decodeURIComponent(val) : val;\n}\n\n/**\n * Default URL-encode value function.\n */\nfunction defaultEncode(val: string | number | boolean): string {\n    return encodeURIComponent(val);\n}\n\n/**\n * Determines if value is a Date.\n */\nfunction isDate(val: any): boolean {\n    return Object.prototype.toString.call(val) === \"[object Date]\" || val instanceof Date;\n}\n","let atobPolyfill: Function;\nif (typeof atob === \"function\") {\n    atobPolyfill = atob;\n} else {\n    /**\n     * The code was extracted from:\n     * https://github.com/davidchambers/Base64.js\n     */\n    atobPolyfill = (input: any) => {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        let str = String(input).replace(/=+$/, \"\");\n        if (str.length % 4 == 1) {\n            throw new Error(\n                \"'atob' failed: The string to be decoded is not correctly encoded.\",\n            );\n        }\n\n        for (\n            // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = \"\";\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            ((bs = bc % 4 ? (bs as any) * 64 + buffer : buffer),\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4)\n                ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n                : 0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n\n        return output;\n    };\n}\n\n/**\n * Returns JWT token's payload data.\n */\nexport function getTokenPayload(token: string): { [key: string]: any } {\n    if (token) {\n        try {\n            const encodedPayload = decodeURIComponent(\n                atobPolyfill(token.split(\".\")[1])\n                    .split(\"\")\n                    .map(function (c: string) {\n                        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n                    })\n                    .join(\"\"),\n            );\n\n            return JSON.parse(encodedPayload) || {};\n        } catch (e) {}\n    }\n\n    return {};\n}\n\n/**\n * Checks whether a JWT token is expired or not.\n * Tokens without `exp` payload key are considered valid.\n * Tokens with empty payload (eg. invalid token strings) are considered expired.\n *\n * @param token The token to check.\n * @param [expirationThreshold] Time in seconds that will be subtracted from the token `exp` property.\n */\nexport function isTokenExpired(token: string, expirationThreshold = 0): boolean {\n    let payload = getTokenPayload(token);\n\n    if (\n        Object.keys(payload).length > 0 &&\n        (!payload.exp || payload.exp - expirationThreshold > Date.now() / 1000)\n    ) {\n        return false;\n    }\n\n    return true;\n}\n","import { cookieParse, cookieSerialize, SerializeOptions } from \"@/stores/utils/cookie\";\nimport { isTokenExpired, getTokenPayload } from \"@/stores/utils/jwt\";\n\nexport type AuthModel = { [key: string]: any } | null;\n\nexport type OnStoreChangeFunc = (token: string, model: AuthModel) => void;\n\nconst defaultCookieKey = \"pb_auth\";\n\n/**\n * Base AuthStore class that is intended to be extended by all other\n * PocketBase AuthStore implementations.\n */\nexport abstract class BaseAuthStore {\n    protected baseToken: string = \"\";\n    protected baseModel: AuthModel = null;\n\n    private _onChangeCallbacks: Array<OnStoreChangeFunc> = [];\n\n    /**\n     * Retrieves the stored token (if any).\n     */\n    get token(): string {\n        return this.baseToken;\n    }\n\n    /**\n     * Retrieves the stored model data (if any).\n     */\n    get model(): AuthModel {\n        return this.baseModel;\n    }\n\n    /**\n     * Loosely checks if the store has valid token (aka. existing and unexpired exp claim).\n     */\n    get isValid(): boolean {\n        return !isTokenExpired(this.token);\n    }\n\n    /**\n     * Checks whether the current store state is for admin authentication.\n     */\n    get isAdmin(): boolean {\n        return getTokenPayload(this.token).type === \"admin\";\n    }\n\n    /**\n     * Checks whether the current store state is for auth record authentication.\n     */\n    get isAuthRecord(): boolean {\n        return getTokenPayload(this.token).type === \"authRecord\";\n    }\n\n    /**\n     * Saves the provided new token and model data in the auth store.\n     */\n    save(token: string, model?: AuthModel): void {\n        this.baseToken = token || \"\";\n        this.baseModel = model || null;\n\n        this.triggerChange();\n    }\n\n    /**\n     * Removes the stored token and model data form the auth store.\n     */\n    clear(): void {\n        this.baseToken = \"\";\n        this.baseModel = null;\n        this.triggerChange();\n    }\n\n    /**\n     * Parses the provided cookie string and updates the store state\n     * with the cookie's token and model data.\n     *\n     * NB! This function doesn't validate the token or its data.\n     * Usually this isn't a concern if you are interacting only with the\n     * PocketBase API because it has the proper server-side security checks in place,\n     * but if you are using the store `isValid` state for permission controls\n     * in a node server (eg. SSR), then it is recommended to call `authRefresh()`\n     * after loading the cookie to ensure an up-to-date token and model state.\n     * For example:\n     *\n     * ```js\n     * pb.authStore.loadFromCookie(\"cookie string...\");\n     *\n     * try {\n     *     // get an up-to-date auth store state by veryfing and refreshing the loaded auth model (if any)\n     *     pb.authStore.isValid && await pb.collection('users').authRefresh();\n     * } catch (_) {\n     *     // clear the auth store on failed refresh\n     *     pb.authStore.clear();\n     * }\n     * ```\n     */\n    loadFromCookie(cookie: string, key = defaultCookieKey): void {\n        const rawData = cookieParse(cookie || \"\")[key] || \"\";\n\n        let data: { [key: string]: any } = {};\n        try {\n            data = JSON.parse(rawData);\n            // normalize\n            if (typeof data === null || typeof data !== \"object\" || Array.isArray(data)) {\n                data = {};\n            }\n        } catch (_) {}\n\n        this.save(data.token || \"\", data.model || null);\n    }\n\n    /**\n     * Exports the current store state as cookie string.\n     *\n     * By default the following optional attributes are added:\n     * - Secure\n     * - HttpOnly\n     * - SameSite=Strict\n     * - Path=/\n     * - Expires={the token expiration date}\n     *\n     * NB! If the generated cookie exceeds 4096 bytes, this method will\n     * strip the model data to the bare minimum to try to fit within the\n     * recommended size in https://www.rfc-editor.org/rfc/rfc6265#section-6.1.\n     */\n    exportToCookie(options?: SerializeOptions, key = defaultCookieKey): string {\n        const defaultOptions: SerializeOptions = {\n            secure: true,\n            sameSite: true,\n            httpOnly: true,\n            path: \"/\",\n        };\n\n        // extract the token expiration date\n        const payload = getTokenPayload(this.token);\n        if (payload?.exp) {\n            defaultOptions.expires = new Date(payload.exp * 1000);\n        } else {\n            defaultOptions.expires = new Date(\"1970-01-01\");\n        }\n\n        // merge with the user defined options\n        options = Object.assign({}, defaultOptions, options);\n\n        const rawData = {\n            token: this.token,\n            model: this.model ? JSON.parse(JSON.stringify(this.model)) : null,\n        };\n\n        let result = cookieSerialize(key, JSON.stringify(rawData), options);\n\n        const resultLength =\n            typeof Blob !== \"undefined\" ? new Blob([result]).size : result.length;\n\n        // strip down the model data to the bare minimum\n        if (rawData.model && resultLength > 4096) {\n            rawData.model = { id: rawData?.model?.id, email: rawData?.model?.email };\n            const extraProps = [\"collectionId\", \"username\", \"verified\"];\n            for (const prop in this.model) {\n                if (extraProps.includes(prop)) {\n                    rawData.model[prop] = this.model[prop];\n                }\n            }\n            result = cookieSerialize(key, JSON.stringify(rawData), options);\n        }\n\n        return result;\n    }\n\n    /**\n     * Register a callback function that will be called on store change.\n     *\n     * You can set the `fireImmediately` argument to true in order to invoke\n     * the provided callback right after registration.\n     *\n     * Returns a removal function that you could call to \"unsubscribe\" from the changes.\n     */\n    onChange(callback: OnStoreChangeFunc, fireImmediately = false): () => void {\n        this._onChangeCallbacks.push(callback);\n\n        if (fireImmediately) {\n            callback(this.token, this.model);\n        }\n\n        return () => {\n            for (let i = this._onChangeCallbacks.length - 1; i >= 0; i--) {\n                if (this._onChangeCallbacks[i] == callback) {\n                    delete this._onChangeCallbacks[i]; // removes the function reference\n                    this._onChangeCallbacks.splice(i, 1); // reindex the array\n                    return;\n                }\n            }\n        };\n    }\n\n    protected triggerChange(): void {\n        for (const callback of this._onChangeCallbacks) {\n            callback && callback(this.token, this.model);\n        }\n    }\n}\n","import { BaseAuthStore, AuthModel } from \"@/stores/BaseAuthStore\";\n\n/**\n * The default token store for browsers with auto fallback\n * to runtime/memory if local storage is undefined (eg. in node env).\n */\nexport class LocalAuthStore extends BaseAuthStore {\n    private storageFallback: { [key: string]: any } = {};\n    private storageKey: string;\n\n    constructor(storageKey = \"pocketbase_auth\") {\n        super();\n\n        this.storageKey = storageKey;\n\n        this._bindStorageEvent();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get token(): string {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.token || \"\";\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get model(): AuthModel {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.model || null;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, model?: AuthModel) {\n        this._storageSet(this.storageKey, {\n            token: token,\n            model: model,\n        });\n\n        super.save(token, model);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear() {\n        this._storageRemove(this.storageKey);\n\n        super.clear();\n    }\n\n    // ---------------------------------------------------------------\n    // Internal helpers:\n    // ---------------------------------------------------------------\n\n    /**\n     * Retrieves `key` from the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageGet(key: string): any {\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            const rawValue = window.localStorage.getItem(key) || \"\";\n            try {\n                return JSON.parse(rawValue);\n            } catch (e) {\n                // not a json\n                return rawValue;\n            }\n        }\n\n        // fallback\n        return this.storageFallback[key];\n    }\n\n    /**\n     * Stores a new data in the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageSet(key: string, value: any) {\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            // store in local storage\n            let normalizedVal = value;\n            if (typeof value !== \"string\") {\n                normalizedVal = JSON.stringify(value);\n            }\n            window.localStorage.setItem(key, normalizedVal);\n        } else {\n            // store in fallback\n            this.storageFallback[key] = value;\n        }\n    }\n\n    /**\n     * Removes `key` from the browser's local storage and the runtime/memory.\n     */\n    private _storageRemove(key: string) {\n        // delete from local storage\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            window.localStorage?.removeItem(key);\n        }\n\n        // delete from fallback\n        delete this.storageFallback[key];\n    }\n\n    /**\n     * Updates the current store state on localStorage change.\n     */\n    private _bindStorageEvent() {\n        if (\n            typeof window === \"undefined\" ||\n            !window?.localStorage ||\n            !window.addEventListener\n        ) {\n            return;\n        }\n\n        window.addEventListener(\"storage\", (e) => {\n            if (e.key != this.storageKey) {\n                return;\n            }\n\n            const data = this._storageGet(this.storageKey) || {};\n\n            super.save(data.token || \"\", data.model || null);\n        });\n    }\n}\n","import Client from \"@/Client\";\n\n/**\n * BaseService class that should be inherited from all API services.\n */\nexport abstract class BaseService {\n    readonly client: Client;\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n}\n","import { BaseService } from \"@/services/utils/BaseService\";\nimport { CommonOptions } from \"@/services/utils/options\";\n\ninterface appleClientSecret {\n    secret: string;\n}\n\nexport class SettingsService extends BaseService {\n    /**\n     * Fetch all available app settings.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getAll(options?: CommonOptions): Promise<{ [key: string]: any }> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings\", options);\n    }\n\n    /**\n     * Bulk updates app settings.\n     *\n     * @throws {ClientResponseError}\n     */\n    async update(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings\", options);\n    }\n\n    /**\n     * Performs a S3 filesystem connection test.\n     *\n     * The currently supported `filesystem` are \"storage\" and \"backups\".\n     *\n     * @throws {ClientResponseError}\n     */\n    async testS3(\n        filesystem: string = \"storage\",\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    filesystem: filesystem,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/test/s3\", options).then(() => true);\n    }\n\n    /**\n     * Sends a test email.\n     *\n     * The possible `emailTemplate` values are:\n     * - verification\n     * - password-reset\n     * - email-change\n     *\n     * @throws {ClientResponseError}\n     */\n    async testEmail(\n        toEmail: string,\n        emailTemplate: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    email: toEmail,\n                    template: emailTemplate,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/test/email\", options).then(() => true);\n    }\n\n    /**\n     * Generates a new Apple OAuth2 client secret.\n     *\n     * @throws {ClientResponseError}\n     */\n    async generateAppleClientSecret(\n        clientId: string,\n        teamId: string,\n        keyId: string,\n        privateKey: string,\n        duration: number,\n        options?: CommonOptions,\n    ): Promise<appleClientSecret> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    clientId,\n                    teamId,\n                    keyId,\n                    privateKey,\n                    duration,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/apple/generate-client-secret\", options);\n    }\n}\n","import { BaseService } from \"@/services/utils/BaseService\";\nimport { ClientResponseError } from \"@/ClientResponseError\";\nimport { ListResult } from \"@/services/utils/dtos\";\nimport { CommonOptions, ListOptions, FullListOptions } from \"@/services/utils/options\";\n\nexport abstract class CrudService<M> extends BaseService {\n    /**\n     * Base path for the crud actions (without trailing slash, eg. '/admins').\n     */\n    abstract get baseCrudPath(): string;\n\n    /**\n     * Response data decoder.\n     */\n    decode<T = M>(data: { [key: string]: any }): T {\n        return data as T;\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once\n     * (by default 500 items per request; to change it set the `batch` query param).\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList<T = M>(options?: FullListOptions): Promise<Array<T>>;\n\n    /**\n     * Legacy version of getFullList with explicitly specified batch size.\n     */\n    async getFullList<T = M>(batch?: number, options?: ListOptions): Promise<Array<T>>;\n\n    async getFullList<T = M>(\n        batchOrqueryParams?: number | FullListOptions,\n        options?: ListOptions,\n    ): Promise<Array<T>> {\n        if (typeof batchOrqueryParams == \"number\") {\n            return this._getFullList<T>(batchOrqueryParams, options);\n        }\n\n        options = Object.assign({}, batchOrqueryParams, options);\n\n        let batch = 500;\n        if (options.batch) {\n            batch = options.batch;\n            delete options.batch;\n        }\n\n        return this._getFullList<T>(batch, options);\n    }\n\n    /**\n     * Returns paginated items list.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getList<T = M>(\n        page = 1,\n        perPage = 30,\n        options?: ListOptions,\n    ): Promise<ListResult<T>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        options.query = Object.assign(\n            {\n                page: page,\n                perPage: perPage,\n            },\n            options.query,\n        );\n\n        return this.client.send(this.baseCrudPath, options).then((responseData: any) => {\n            responseData.items =\n                responseData.items?.map((item: any) => {\n                    return this.decode<T>(item);\n                }) || [];\n\n            return responseData;\n        });\n    }\n\n    /**\n     * Returns the first found item by the specified filter.\n     *\n     * Internally it calls `getList(1, 1, { filter, skipTotal })` and\n     * returns the first found item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * For consistency with `getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFirstListItem<T = M>(filter: string, options?: CommonOptions): Promise<T> {\n        options = Object.assign(\n            {\n                requestKey: \"one_by_filter_\" + this.baseCrudPath + \"_\" + filter,\n            },\n            options,\n        );\n\n        options.query = Object.assign(\n            {\n                filter: filter,\n                skipTotal: 1,\n            },\n            options.query,\n        );\n\n        return this.getList<T>(1, 1, options).then((result) => {\n            if (!result?.items?.length) {\n                throw new ClientResponseError({\n                    status: 404,\n                    response: {\n                        code: 404,\n                        message: \"The requested resource wasn't found.\",\n                        data: {},\n                    },\n                });\n            }\n\n            return result.items[0];\n        });\n    }\n\n    /**\n     * Returns single item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * If `id` is empty it will throw a 404 error.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getOne<T = M>(id: string, options?: CommonOptions): Promise<T> {\n        if (!id) {\n            throw new ClientResponseError({\n                url: this.client.buildUrl(this.baseCrudPath + \"/\"),\n                status: 404,\n                response: {\n                    code: 404,\n                    message: \"Missing required record id.\",\n                    data: {},\n                },\n            });\n        }\n\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Creates a new item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async create<T = M>(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath, options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Updates an existing item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async update<T = M>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     *\n     * @throws {ClientResponseError}\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then(() => true);\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     */\n    protected _getFullList<T = M>(\n        batchSize = 500,\n        options?: ListOptions,\n    ): Promise<Array<T>> {\n        options = options || {};\n        options.query = Object.assign(\n            {\n                skipTotal: 1,\n            },\n            options.query,\n        );\n\n        let result: Array<T> = [];\n\n        let request = async (page: number): Promise<Array<any>> => {\n            return this.getList(page, batchSize || 500, options).then((list) => {\n                const castedList = list as any as ListResult<T>;\n                const items = castedList.items;\n\n                result = result.concat(items);\n\n                if (items.length == list.perPage) {\n                    return request(page + 1);\n                }\n\n                return result;\n            });\n        };\n\n        return request(1);\n    }\n}\n","import { SendOptions } from \"@/services/utils/options\";\n\nexport function normalizeLegacyOptionsArgs(\n    legacyWarn: string,\n    baseOptions: SendOptions,\n    bodyOrOptions?: any,\n    query?: any,\n): SendOptions {\n    const hasBodyOrOptions = typeof bodyOrOptions !== \"undefined\";\n    const hasQuery = typeof query !== \"undefined\";\n\n    if (!hasQuery && !hasBodyOrOptions) {\n        return baseOptions;\n    }\n\n    if (hasQuery) {\n        console.warn(legacyWarn);\n        baseOptions.body = Object.assign({}, baseOptions.body, bodyOrOptions);\n        baseOptions.query = Object.assign({}, baseOptions.query, query);\n\n        return baseOptions;\n    }\n\n    return Object.assign(baseOptions, bodyOrOptions);\n}\n","import Client from \"@/Client\";\nimport { isTokenExpired } from \"@/stores/utils/jwt\";\n\n// reset previous auto refresh registrations\nexport function resetAutoRefresh(client: Client) {\n    (client as any)._resetAutoRefresh?.();\n}\n\nexport function registerAutoRefresh(\n    client: Client,\n    threshold: number,\n    refreshFunc: () => Promise<any>,\n    reauthenticateFunc: () => Promise<any>,\n) {\n    resetAutoRefresh(client);\n\n    const oldBeforeSend = client.beforeSend;\n    const oldModel = client.authStore.model;\n\n    // unset the auto refresh in case the auth store was cleared\n    // OR a new model was authenticated\n    const unsubStoreChange = client.authStore.onChange((newToken, model) => {\n        if (\n            !newToken ||\n            model?.id != oldModel?.id ||\n            // check the collection id in case an admin and auth record share the same id\n            ((model?.collectionId || oldModel?.collectionId) &&\n                model?.collectionId != oldModel?.collectionId)\n        ) {\n            resetAutoRefresh(client);\n        }\n    });\n\n    // initialize a reset function and attach it dynamically to the client\n    (client as any)._resetAutoRefresh = function () {\n        unsubStoreChange();\n        client.beforeSend = oldBeforeSend;\n        delete (client as any)._resetAutoRefresh;\n    };\n\n    client.beforeSend = async (url, sendOptions) => {\n        const oldToken = client.authStore.token;\n\n        if (sendOptions.query?.autoRefresh) {\n            return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n        }\n\n        let isValid = client.authStore.isValid;\n        if (\n            // is loosely valid\n            isValid &&\n            // but it is going to expire in the next \"threshold\" seconds\n            isTokenExpired(client.authStore.token, threshold)\n        ) {\n            try {\n                await refreshFunc();\n            } catch (_) {\n                isValid = false;\n            }\n        }\n\n        // still invalid -> reauthenticate\n        if (!isValid) {\n            await reauthenticateFunc();\n        }\n\n        // the request wasn't sent with a custom token\n        const headers = sendOptions.headers || {};\n        for (let key in headers) {\n            if (\n                key.toLowerCase() == \"authorization\" &&\n                // the request wasn't sent with a custom token\n                oldToken == headers[key] &&\n                client.authStore.token\n            ) {\n                // set the latest store token\n                headers[key] = client.authStore.token;\n                break;\n            }\n        }\n        sendOptions.headers = headers;\n\n        return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n    };\n}\n","import { CrudService } from \"@/services/utils/CrudService\";\nimport { AdminModel } from \"@/services/utils/dtos\";\nimport { AuthOptions, CommonOptions } from \"@/services/utils/options\";\nimport { normalizeLegacyOptionsArgs } from \"@/services/utils/legacy\";\nimport { registerAutoRefresh, resetAutoRefresh } from \"@/services/utils/refresh\";\n\nexport interface AdminAuthResponse {\n    [key: string]: any;\n\n    token: string;\n    admin: AdminModel;\n}\n\nexport class AdminService extends CrudService<AdminModel> {\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return \"/api/admins\";\n    }\n\n    // ---------------------------------------------------------------\n    // Post update/delete AuthStore sync\n    // ---------------------------------------------------------------\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    async update<T = AdminModel>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        return super.update(id, bodyParams, options).then((item) => {\n            // update the store state if the updated item id matches with the stored model\n            if (\n                this.client.authStore.model?.id === item.id &&\n                typeof this.client.authStore.model?.collectionId === \"undefined\" // is not record auth\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        return super.delete(id, options).then((success) => {\n            // clear the store state if the deleted item id matches with the stored model\n            if (\n                success &&\n                this.client.authStore.model?.id === id &&\n                typeof this.client.authStore.model?.collectionId === \"undefined\" // is not record auth\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful authorize response.\n     */\n    protected authResponse(responseData: any): AdminAuthResponse {\n        const admin = this.decode(responseData?.admin || {});\n\n        if (responseData?.token && responseData?.admin) {\n            this.client.authStore.save(responseData.token, admin);\n        }\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            token: responseData?.token || \"\",\n            admin: admin,\n        });\n    }\n\n    /**\n     * Authenticate an admin account with its email and password\n     * and returns a new admin token and data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithPassword(\n        email: string,\n        password: string,\n        options?: AuthOptions,\n    ): Promise<AdminAuthResponse>;\n\n    /**\n     * @deprecated\n     * Consider using authWithPassword(email, password, options?).\n     */\n    async authWithPassword(\n        email: string,\n        password: string,\n        body?: any,\n        query?: any,\n    ): Promise<AdminAuthResponse>;\n\n    async authWithPassword(\n        email: string,\n        password: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<AdminAuthResponse> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                identity: email,\n                password: password,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authWithPassword(email, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(email, pass, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        const autoRefreshThreshold = options.autoRefreshThreshold;\n        delete options.autoRefreshThreshold;\n\n        // not from auto refresh reauthentication\n        if (!options.autoRefresh) {\n            resetAutoRefresh(this.client);\n        }\n\n        let authData = await this.client.send(\n            this.baseCrudPath + \"/auth-with-password\",\n            options,\n        );\n\n        authData = this.authResponse(authData);\n\n        if (autoRefreshThreshold) {\n            registerAutoRefresh(\n                this.client,\n                autoRefreshThreshold,\n                () => this.authRefresh({ autoRefresh: true }),\n                () =>\n                    this.authWithPassword(\n                        email,\n                        password,\n                        Object.assign({ autoRefresh: true }, options),\n                    ),\n            );\n        }\n\n        return authData;\n    }\n\n    /**\n     * Refreshes the current admin authenticated instance and\n     * returns a new token and admin data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     *\n     * @throws {ClientResponseError}\n     */\n    async authRefresh(options?: CommonOptions): Promise<AdminAuthResponse>;\n\n    /**\n     * @deprecated\n     * Consider using authRefresh(options?).\n     */\n    async authRefresh(body?: any, query?: any): Promise<AdminAuthResponse>;\n\n    async authRefresh(bodyOrOptions?: any, query?: any): Promise<AdminAuthResponse> {\n        let options: any = {\n            method: \"POST\",\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/auth-refresh\", options)\n            .then(this.authResponse.bind(this));\n    }\n\n    /**\n     * Sends admin password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestPasswordReset(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestPasswordReset(email, options?).\n     */\n    async requestPasswordReset(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestPasswordReset(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/request-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms admin password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmPasswordReset(\n        resetToken: string,\n        password: string,\n        passwordConfirm: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmPasswordReset(resetToken, password, passwordConfirm, options?).\n     */\n    async confirmPasswordReset(\n        resetToken: string,\n        password: string,\n        passwordConfirm: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmPasswordReset(\n        resetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: resetToken,\n                password: password,\n                passwordConfirm: passwordConfirm,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmPasswordReset(resetToken, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(resetToken, password, passwordConfirm, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/confirm-password-reset\", options)\n            .then(() => true);\n    }\n}\n","export interface SendOptions extends RequestInit {\n    // for backward compatibility and to minimize the verbosity,\n    // any top-level field that doesn't exist in RequestInit or the\n    // fields below will be treated as query parameter.\n    [key: string]: any;\n\n    /**\n     * Optional custom fetch function to use for sending the request.\n     */\n    fetch?: (url: RequestInfo | URL, config?: RequestInit) => Promise<Response>;\n\n    /**\n     * Custom headers to send with the requests.\n     */\n    headers?: { [key: string]: string };\n\n    /**\n     * The body of the request (serialized automatically for json requests).\n     */\n    body?: any;\n\n    /**\n     * Query parameters that will be appended to the request url.\n     */\n    query?: { [key: string]: any };\n\n    /**\n     * @deprecated use `query` instead\n     *\n     * for backward-compatibility `params` values are merged with `query`,\n     * but this option may get removed in the final v1 release\n     */\n    params?: { [key: string]: any };\n\n    /**\n     * The request identifier that can be used to cancel pending requests.\n     */\n    requestKey?: string | null;\n\n    /**\n     * @deprecated use `requestKey:string` instead\n     */\n    $cancelKey?: string;\n\n    /**\n     * @deprecated use `requestKey:null` instead\n     */\n    $autoCancel?: boolean;\n}\n\nexport interface CommonOptions extends SendOptions {\n    fields?: string;\n}\n\nexport interface ListOptions extends CommonOptions {\n    page?: number;\n    perPage?: number;\n    sort?: string;\n    filter?: string;\n    skipTotal?: boolean;\n}\n\nexport interface FullListOptions extends ListOptions {\n    batch?: number;\n}\n\nexport interface RecordOptions extends CommonOptions {\n    expand?: string;\n}\n\nexport interface RecordListOptions extends ListOptions, RecordOptions {}\n\nexport interface RecordFullListOptions extends FullListOptions, RecordOptions {}\n\nexport interface LogStatsOptions extends CommonOptions {\n    filter?: string;\n}\n\nexport interface FileOptions extends CommonOptions {\n    thumb?: string;\n    download?: boolean;\n}\n\nexport interface AuthOptions extends CommonOptions {\n    /**\n     * If autoRefreshThreshold is set it will take care to auto refresh\n     * when necessary the auth data before each request to ensure that\n     * the auth state is always valid.\n     *\n     * The value must be in seconds, aka. the amount of seconds\n     * that will be subtracted from the current token `exp` claim in order\n     * to determine whether it is going to expire within the specified time threshold.\n     *\n     * For example, if you want to auto refresh the token if it is\n     * going to expire in the next 30mins (or already has expired),\n     * it can be set to `1800`\n     */\n    autoRefreshThreshold?: number;\n}\n\n// -------------------------------------------------------------------\n\n// list of known SendOptions keys (everything else is treated as query param)\nconst knownSendOptionsKeys = [\n    \"requestKey\",\n    \"$cancelKey\",\n    \"$autoCancel\",\n    \"fetch\",\n    \"headers\",\n    \"body\",\n    \"query\",\n    \"params\",\n    // ---,\n    \"cache\",\n    \"credentials\",\n    \"headers\",\n    \"integrity\",\n    \"keepalive\",\n    \"method\",\n    \"mode\",\n    \"redirect\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"signal\",\n    \"window\",\n];\n\n// modifies in place the provided options by moving unknown send options as query parameters.\nexport function normalizeUnknownQueryParams(options?: SendOptions): void {\n    if (!options) {\n        return;\n    }\n\n    options.query = options.query || {};\n    for (let key in options) {\n        if (knownSendOptionsKeys.includes(key)) {\n            continue;\n        }\n\n        options.query[key] = options[key];\n        delete options[key];\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseService } from \"@/services/utils/BaseService\";\nimport { SendOptions, normalizeUnknownQueryParams } from \"@/services/utils/options\";\n\ninterface promiseCallbacks {\n    resolve: Function;\n    reject: Function;\n}\n\ntype Subscriptions = { [key: string]: Array<EventListener> };\n\nexport type UnsubscribeFunc = () => Promise<void>;\n\nexport class RealtimeService extends BaseService {\n    clientId: string = \"\";\n\n    private eventSource: EventSource | null = null;\n    private subscriptions: Subscriptions = {};\n    private lastSentSubscriptions: Array<string> = [];\n    private connectTimeoutId: any;\n    private maxConnectTimeout: number = 15000;\n    private reconnectTimeoutId: any;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = Infinity;\n    private predefinedReconnectIntervals: Array<number> = [\n        200, 300, 500, 1000, 1200, 1500, 2000,\n    ];\n    private pendingConnects: Array<promiseCallbacks> = [];\n\n    /**\n     * Returns whether the realtime connection has been established.\n     */\n    get isConnected(): boolean {\n        return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\n    }\n\n    /**\n     * Register the subscription listener.\n     *\n     * You can subscribe multiple times to the same topic.\n     *\n     * If the SSE connection is not started yet,\n     * this method will also initialize it.\n     */\n    async subscribe(\n        topic: string,\n        callback: (data: any) => void,\n        options?: SendOptions,\n    ): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error(\"topic must be set.\");\n        }\n\n        let key = topic;\n\n        // serialize and append the topic options (if any)\n        if (options) {\n            normalizeUnknownQueryParams(options);\n            const serialized =\n                \"options=\" +\n                encodeURIComponent(\n                    JSON.stringify({ query: options.query, headers: options.headers }),\n                );\n            key += (key.includes(\"?\") ? \"&\" : \"?\") + serialized;\n        }\n\n        const listener = function (e: Event) {\n            const msgEvent = e as MessageEvent;\n\n            let data;\n            try {\n                data = JSON.parse(msgEvent?.data);\n            } catch {}\n\n            callback(data || {});\n        };\n\n        // store the listener\n        if (!this.subscriptions[key]) {\n            this.subscriptions[key] = [];\n        }\n        this.subscriptions[key].push(listener);\n\n        if (!this.isConnected) {\n            // initialize sse connection\n            await this.connect();\n        } else if (this.subscriptions[key].length === 1) {\n            // send the updated subscriptions (if it is the first for the key)\n            await this.submitSubscriptions();\n        } else {\n            // only register the listener\n            this.eventSource?.addEventListener(key, listener);\n        }\n\n        return async (): Promise<void> => {\n            return this.unsubscribeByTopicAndListener(topic, listener);\n        };\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners with the specified topic.\n     *\n     * If `topic` is not provided, then this method will unsubscribe\n     * from all active subscriptions.\n     *\n     * This method is no-op if there are no active subscriptions.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        let needToSubmit = false;\n\n        if (!topic) {\n            // remove all subscriptions\n            this.subscriptions = {};\n        } else {\n            // remove all listeners related to the topic\n            const subs = this.getSubscriptionsByTopic(topic);\n            for (let key in subs) {\n                if (!this.hasSubscriptionListeners(key)) {\n                    continue; // already unsubscribed\n                }\n\n                for (let listener of this.subscriptions[key]) {\n                    this.eventSource?.removeEventListener(key, listener);\n                }\n                delete this.subscriptions[key];\n\n                // mark for subscriptions change submit if there are no other listeners\n                if (!needToSubmit) {\n                    needToSubmit = true;\n                }\n            }\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (needToSubmit) {\n            await this.submitSubscriptions();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners starting with the specified topic prefix.\n     *\n     * This method is no-op if there are no active subscriptions with the specified topic prefix.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByPrefix(keyPrefix: string): Promise<void> {\n        let hasAtleastOneTopic = false;\n        for (let key in this.subscriptions) {\n            // \"?\" so that it can be used as end delimiter for the prefix\n            if (!(key + \"?\").startsWith(keyPrefix)) {\n                continue;\n            }\n\n            hasAtleastOneTopic = true;\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource?.removeEventListener(key, listener);\n            }\n            delete this.subscriptions[key];\n        }\n\n        if (!hasAtleastOneTopic) {\n            return; // nothing to unsubscribe from\n        }\n\n        if (this.hasSubscriptionListeners()) {\n            // submit the deleted subscriptions\n            await this.submitSubscriptions();\n        } else {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscriptions matching the specified topic and listener function.\n     *\n     * This method is no-op if there are no active subscription with\n     * the specified topic and listener.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByTopicAndListener(\n        topic: string,\n        listener: EventListener,\n    ): Promise<void> {\n        let needToSubmit = false;\n\n        const subs = this.getSubscriptionsByTopic(topic);\n        for (let key in subs) {\n            if (\n                !Array.isArray(this.subscriptions[key]) ||\n                !this.subscriptions[key].length\n            ) {\n                continue; // already unsubscribed\n            }\n\n            let exist = false;\n            for (let i = this.subscriptions[key].length - 1; i >= 0; i--) {\n                if (this.subscriptions[key][i] !== listener) {\n                    continue;\n                }\n\n                exist = true; // has at least one matching listener\n                delete this.subscriptions[key][i]; // removes the function reference\n                this.subscriptions[key].splice(i, 1); // reindex the array\n                this.eventSource?.removeEventListener(key, listener);\n            }\n            if (!exist) {\n                continue;\n            }\n\n            // remove the key from the subscriptions list if there are no other listeners\n            if (!this.subscriptions[key].length) {\n                delete this.subscriptions[key];\n            }\n\n            // mark for subscriptions change submit if there are no other listeners\n            if (!needToSubmit && !this.hasSubscriptionListeners(key)) {\n                needToSubmit = true;\n            }\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (needToSubmit) {\n            await this.submitSubscriptions();\n        }\n    }\n\n    private hasSubscriptionListeners(keyToCheck?: string): boolean {\n        this.subscriptions = this.subscriptions || {};\n\n        // check the specified key\n        if (keyToCheck) {\n            return !!this.subscriptions[keyToCheck]?.length;\n        }\n\n        // check for at least one non-empty subscription\n        for (let key in this.subscriptions) {\n            if (!!this.subscriptions[key]?.length) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private async submitSubscriptions(): Promise<void> {\n        if (!this.clientId) {\n            return; // no client/subscriber\n        }\n\n        // optimistic update\n        this.addAllSubscriptionListeners();\n\n        this.lastSentSubscriptions = this.getNonEmptySubscriptionKeys();\n\n        return this.client\n            .send(\"/api/realtime\", {\n                method: \"POST\",\n                body: {\n                    clientId: this.clientId,\n                    subscriptions: this.lastSentSubscriptions,\n                },\n                requestKey: this.getSubscriptionsCancelKey(),\n            })\n            .catch((err) => {\n                if (err?.isAbort) {\n                    return; // silently ignore aborted pending requests\n                }\n                throw err;\n            });\n    }\n\n    private getSubscriptionsCancelKey(): string {\n        return \"realtime_\" + this.clientId;\n    }\n\n    private getSubscriptionsByTopic(topic: string): Subscriptions {\n        const result: Subscriptions = {};\n\n        // \"?\" so that it can be used as end delimiter for the topic\n        topic = topic.includes(\"?\") ? topic : topic + \"?\";\n\n        for (let key in this.subscriptions) {\n            if ((key + \"?\").startsWith(topic)) {\n                result[key] = this.subscriptions[key];\n            }\n        }\n\n        return result;\n    }\n\n    private getNonEmptySubscriptionKeys(): Array<string> {\n        const result: Array<string> = [];\n\n        for (let key in this.subscriptions) {\n            if (this.subscriptions[key].length) {\n                result.push(key);\n            }\n        }\n\n        return result;\n    }\n\n    private addAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        this.removeAllSubscriptionListeners();\n\n        for (let key in this.subscriptions) {\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource.addEventListener(key, listener);\n            }\n        }\n    }\n\n    private removeAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        for (let key in this.subscriptions) {\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource.removeEventListener(key, listener);\n            }\n        }\n    }\n\n    private async connect(): Promise<void> {\n        if (this.reconnectAttempts > 0) {\n            // immediately resolve the promise to avoid indefinitely\n            // blocking the client during reconnection\n            return;\n        }\n\n        return new Promise((resolve, reject) => {\n            this.pendingConnects.push({ resolve, reject });\n\n            if (this.pendingConnects.length > 1) {\n                // all promises will be resolved once the connection is established\n                return;\n            }\n\n            this.initConnect();\n        });\n    }\n\n    private initConnect() {\n        this.disconnect(true);\n\n        // wait up to 15s for connect\n        clearTimeout(this.connectTimeoutId);\n        this.connectTimeoutId = setTimeout(() => {\n            this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\n        }, this.maxConnectTimeout);\n\n        this.eventSource = new EventSource(this.client.buildUrl(\"/api/realtime\"));\n\n        this.eventSource.onerror = (_) => {\n            this.connectErrorHandler(\n                new Error(\"Failed to establish realtime connection.\"),\n            );\n        };\n\n        this.eventSource.addEventListener(\"PB_CONNECT\", (e) => {\n            const msgEvent = e as MessageEvent;\n            this.clientId = msgEvent?.lastEventId;\n\n            this.submitSubscriptions()\n                .then(async () => {\n                    let retries = 3;\n                    while (this.hasUnsentSubscriptions() && retries > 0) {\n                        retries--;\n                        // resubscribe to ensure that the latest topics are submitted\n                        //\n                        // This is needed because missed topics could happen on reconnect\n                        // if after the pending sent `submitSubscriptions()` call another `subscribe()`\n                        // was made before the submit was able to complete.\n                        await this.submitSubscriptions();\n                    }\n                })\n                .then(() => {\n                    for (let p of this.pendingConnects) {\n                        p.resolve();\n                    }\n\n                    // reset connect meta\n                    this.pendingConnects = [];\n                    this.reconnectAttempts = 0;\n                    clearTimeout(this.reconnectTimeoutId);\n                    clearTimeout(this.connectTimeoutId);\n\n                    // propagate the PB_CONNECT event\n                    const connectSubs = this.getSubscriptionsByTopic(\"PB_CONNECT\");\n                    for (let key in connectSubs) {\n                        for (let listener of connectSubs[key]) {\n                            listener(e);\n                        }\n                    }\n                })\n                .catch((err) => {\n                    this.clientId = \"\";\n                    this.connectErrorHandler(err);\n                });\n        });\n    }\n\n    private hasUnsentSubscriptions(): boolean {\n        const latestTopics = this.getNonEmptySubscriptionKeys();\n        if (latestTopics.length != this.lastSentSubscriptions.length) {\n            return true;\n        }\n\n        for (const t of latestTopics) {\n            if (!this.lastSentSubscriptions.includes(t)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private connectErrorHandler(err: any) {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n\n        if (\n            // wasn't previously connected -> direct reject\n            (!this.clientId && !this.reconnectAttempts) ||\n            // was previously connected but the max reconnection limit has been reached\n            this.reconnectAttempts > this.maxReconnectAttempts\n        ) {\n            for (let p of this.pendingConnects) {\n                p.reject(new ClientResponseError(err));\n            }\n            this.pendingConnects = [];\n            this.disconnect();\n            return;\n        }\n\n        // otherwise -> reconnect in the background\n        this.disconnect(true);\n        const timeout =\n            this.predefinedReconnectIntervals[this.reconnectAttempts] ||\n            this.predefinedReconnectIntervals[\n                this.predefinedReconnectIntervals.length - 1\n            ];\n        this.reconnectAttempts++;\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.initConnect();\n        }, timeout);\n    }\n\n    private disconnect(fromReconnect = false): void {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n        this.removeAllSubscriptionListeners();\n        this.client.cancelRequest(this.getSubscriptionsCancelKey());\n        this.eventSource?.close();\n        this.eventSource = null;\n        this.clientId = \"\";\n\n        if (!fromReconnect) {\n            this.reconnectAttempts = 0;\n\n            // resolve any remaining connect promises\n            //\n            // this is done to avoid unnecessary throwing errors in case\n            // unsubscribe is called before the pending connect promises complete\n            // (see https://github.com/pocketbase/pocketbase/discussions/2897#discussioncomment-6423818)\n            for (let p of this.pendingConnects) {\n                p.resolve();\n            }\n            this.pendingConnects = [];\n        }\n    }\n}\n","import Client from \"@/Client\";\nimport { getTokenPayload } from \"@/stores/utils/jwt\";\nimport { CrudService } from \"@/services/utils/CrudService\";\nimport { RealtimeService, UnsubscribeFunc } from \"@/services/RealtimeService\";\nimport { ClientResponseError } from \"@/ClientResponseError\";\nimport { ListResult, RecordModel, ExternalAuthModel } from \"@/services/utils/dtos\";\nimport {\n    SendOptions,\n    CommonOptions,\n    RecordOptions,\n    RecordListOptions,\n    RecordFullListOptions,\n} from \"@/services/utils/options\";\nimport { normalizeLegacyOptionsArgs } from \"@/services/utils/legacy\";\n\nexport interface RecordAuthResponse<T = RecordModel> {\n    /**\n     * The signed PocketBase auth record.\n     */\n    record: T;\n\n    /**\n     * The PocketBase record auth token.\n     *\n     * If you are looking for the OAuth2 access and refresh tokens\n     * they are available under the `meta.accessToken` and `meta.refreshToken` props.\n     */\n    token: string;\n\n    /**\n     * Auth meta data usually filled when OAuth2 is used.\n     */\n    meta?: { [key: string]: any };\n}\n\nexport interface AuthProviderInfo {\n    name: string;\n    displayName: string;\n    state: string;\n    authUrl: string;\n    codeVerifier: string;\n    codeChallenge: string;\n    codeChallengeMethod: string;\n}\n\nexport interface AuthMethodsList {\n    usernamePassword: boolean;\n    emailPassword: boolean;\n    onlyVerified: boolean;\n    authProviders: Array<AuthProviderInfo>;\n}\n\nexport interface RecordSubscription<T = RecordModel> {\n    action: string; // eg. create, update, delete\n    record: T;\n}\n\nexport type OAuth2UrlCallback = (url: string) => void | Promise<void>;\n\nexport interface OAuth2AuthConfig extends SendOptions {\n    // the name of the OAuth2 provider (eg. \"google\")\n    provider: string;\n\n    // custom scopes to overwrite the default ones\n    scopes?: Array<string>;\n\n    // optional record create data\n    createData?: { [key: string]: any };\n\n    // optional callback that is triggered after the OAuth2 sign-in/sign-up url generation\n    urlCallback?: OAuth2UrlCallback;\n\n    // optional query params to send with the PocketBase auth request (eg. fields, expand, etc.)\n    query?: RecordOptions;\n}\n\nexport class RecordService<M = RecordModel> extends CrudService<M> {\n    readonly collectionIdOrName: string;\n\n    constructor(client: Client, collectionIdOrName: string) {\n        super(client);\n\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return this.baseCollectionPath + \"/records\";\n    }\n\n    /**\n     * Returns the current collection service base path.\n     */\n    get baseCollectionPath(): string {\n        return \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Realtime handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Subscribe to realtime changes to the specified topic (\"*\" or record id).\n     *\n     * If `topic` is the wildcard \"*\", then this method will subscribe to\n     * any record changes in the collection.\n     *\n     * If `topic` is a record id, then this method will subscribe only\n     * to changes of the specified record id.\n     *\n     * It's OK to subscribe multiple times to the same topic.\n     * You can use the returned `UnsubscribeFunc` to remove only a single subscription.\n     * Or use `unsubscribe(topic)` if you want to remove all subscriptions attached to the topic.\n     */\n    async subscribe<T = M>(\n        topic: string,\n        callback: (data: RecordSubscription<T>) => void,\n        options?: SendOptions,\n    ): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error(\"Missing topic.\");\n        }\n\n        if (!callback) {\n            throw new Error(\"Missing subscription callback.\");\n        }\n\n        return this.client.realtime.subscribe(\n            this.collectionIdOrName + \"/\" + topic,\n            callback,\n            options,\n        );\n    }\n\n    /**\n     * Unsubscribe from all subscriptions of the specified topic\n     * (\"*\" or record id).\n     *\n     * If `topic` is not set, then this method will unsubscribe from\n     * all subscriptions associated to the current collection.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        // unsubscribe from the specified topic\n        if (topic) {\n            return this.client.realtime.unsubscribe(\n                this.collectionIdOrName + \"/\" + topic,\n            );\n        }\n\n        // unsubscribe from everything related to the collection\n        return this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Crud handers\n    // ---------------------------------------------------------------\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(options?: RecordFullListOptions): Promise<Array<T>>;\n\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(\n        batch?: number,\n        options?: RecordListOptions,\n    ): Promise<Array<T>>;\n\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(\n        batchOrOptions?: number | RecordFullListOptions,\n        options?: RecordListOptions,\n    ): Promise<Array<T>> {\n        if (typeof batchOrOptions == \"number\") {\n            return super.getFullList<T>(batchOrOptions, options);\n        }\n\n        const params = Object.assign({}, batchOrOptions, options);\n\n        return super.getFullList<T>(params);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getList<T = M>(\n        page = 1,\n        perPage = 30,\n        options?: RecordListOptions,\n    ): Promise<ListResult<T>> {\n        return super.getList<T>(page, perPage, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getFirstListItem<T = M>(\n        filter: string,\n        options?: RecordListOptions,\n    ): Promise<T> {\n        return super.getFirstListItem<T>(filter, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getOne<T = M>(id: string, options?: RecordOptions): Promise<T> {\n        return super.getOne<T>(id, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async create<T = M>(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): Promise<T> {\n        return super.create<T>(bodyParams, options);\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    async update<T = M>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): Promise<T> {\n        return super.update<RecordModel>(id, bodyParams, options).then((item) => {\n            if (\n                // is record auth\n                this.client.authStore.model?.id === item?.id &&\n                (this.client.authStore.model?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.model?.collectionName ===\n                        this.collectionIdOrName)\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        return super.delete(id, options).then((success) => {\n            if (\n                success &&\n                // is record auth\n                this.client.authStore.model?.id === id &&\n                (this.client.authStore.model?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.model?.collectionName ===\n                        this.collectionIdOrName)\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful collection authorization response.\n     */\n    protected authResponse<T = M>(responseData: any): RecordAuthResponse<T> {\n        const record = this.decode(responseData?.record || {});\n\n        this.client.authStore.save(responseData?.token, record as any);\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            token: responseData?.token || \"\",\n            record: record as any as T,\n        });\n    }\n\n    /**\n     * Returns all available collection auth methods.\n     *\n     * @throws {ClientResponseError}\n     */\n    async listAuthMethods(options?: CommonOptions): Promise<AuthMethodsList> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-methods\", options)\n            .then((responseData: any) => {\n                return Object.assign({}, responseData, {\n                    // normalize common fields\n                    usernamePassword: !!responseData?.usernamePassword,\n                    emailPassword: !!responseData?.emailPassword,\n                    authProviders: Array.isArray(responseData?.authProviders)\n                        ? responseData?.authProviders\n                        : [],\n                });\n            });\n    }\n\n    /**\n     * Authenticate a single auth collection record via its username/email and password.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithPassword<T = M>(\n        usernameOrEmail: string,\n        password: string,\n        options?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authWithPassword(usernameOrEmail, password, options?).\n     */\n    async authWithPassword<T = M>(\n        usernameOrEmail: string,\n        password: string,\n        body?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>>;\n\n    async authWithPassword<T = M>(\n        usernameOrEmail: string,\n        password: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                identity: usernameOrEmail,\n                password: password,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authWithPassword(usernameOrEmail, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(usernameOrEmail, pass, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-with-password\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Authenticate a single auth collection record with OAuth2 code.\n     *\n     * If you don't have an OAuth2 code you may also want to check `authWithOAuth2` method.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: { [key: string]: any },\n        options?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createdData, options?).\n     */\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: { [key: string]: any },\n        body?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>>;\n\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: { [key: string]: any },\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                provider: provider,\n                code: code,\n                codeVerifier: codeVerifier,\n                redirectUrl: redirectUrl,\n                createData: createData,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-with-oauth2\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * @deprecated This form of authWithOAuth2 is deprecated.\n     *\n     * Please use `authWithOAuth2Code()` OR its simplified realtime version\n     * as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\n     */\n    async authWithOAuth2<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: { [key: string]: any },\n        bodyParams?: { [key: string]: any },\n        queryParams?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * Authenticate a single auth collection record with OAuth2\n     * **without custom redirects, deeplinks or even page reload**.\n     *\n     * This method initializes a one-off realtime subscription and will\n     * open a popup window with the OAuth2 vendor page to authenticate.\n     * Once the external OAuth2 sign-in/sign-up flow is completed, the popup\n     * window will be automatically closed and the OAuth2 data sent back\n     * to the user through the previously established realtime connection.\n     *\n     * You can specify an optional `urlCallback` prop to customize\n     * the default url `window.open` behavior.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * Example:\n     *\n     * ```js\n     * const authData = await pb.collection(\"users\").authWithOAuth2({\n     *     provider: \"google\",\n     * })\n     * ```\n     *\n     * _Site-note_: when creating the OAuth2 app in the provider dashboard\n     * you have to configure `https://yourdomain.com/api/oauth2-redirect`\n     * as redirect URL.\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOAuth2<T = M>(\n        options: OAuth2AuthConfig,\n    ): Promise<RecordAuthResponse<T>>;\n\n    async authWithOAuth2<T = M>(...args: any): Promise<RecordAuthResponse<T>> {\n        // fallback to legacy format\n        if (args.length > 1 || typeof args?.[0] === \"string\") {\n            console.warn(\n                \"PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\",\n            );\n            return this.authWithOAuth2Code<T>(\n                args?.[0] || \"\",\n                args?.[1] || \"\",\n                args?.[2] || \"\",\n                args?.[3] || \"\",\n                args?.[4] || {},\n                args?.[5] || {},\n                args?.[6] || {},\n            );\n        }\n\n        const config = args?.[0] || {};\n\n        const authMethods = await this.listAuthMethods();\n\n        const provider = authMethods.authProviders.find(\n            (p) => p.name === config.provider,\n        );\n        if (!provider) {\n            throw new ClientResponseError(\n                new Error(`Missing or invalid provider \"${config.provider}\".`),\n            );\n        }\n\n        const redirectUrl = this.client.buildUrl(\"/api/oauth2-redirect\");\n\n        // initialize a one-off realtime service\n        const realtime = new RealtimeService(this.client);\n\n        // open a new popup window in case config.urlCallback is not set\n        //\n        // note: it is opened before the async call due to Safari restrictions\n        // (see https://github.com/pocketbase/pocketbase/discussions/2429#discussioncomment-5943061)\n        let eagerDefaultPopup: Window | null = null;\n        if (!config.urlCallback) {\n            eagerDefaultPopup = openBrowserPopup(undefined);\n        }\n\n        function cleanup() {\n            eagerDefaultPopup?.close();\n            realtime.unsubscribe();\n        }\n\n        return new Promise(async (resolve, reject) => {\n            try {\n                await realtime.subscribe(\"@oauth2\", async (e) => {\n                    const oldState = realtime.clientId;\n\n                    try {\n                        if (!e.state || oldState !== e.state) {\n                            throw new Error(\"State parameters don't match.\");\n                        }\n\n                        if (e.error || !e.code) {\n                            throw new Error(\n                                \"OAuth2 redirect error or missing code: \" + e.error,\n                            );\n                        }\n\n                        // clear the non SendOptions props\n                        const options = Object.assign({}, config);\n                        delete options.provider;\n                        delete options.scopes;\n                        delete options.createData;\n                        delete options.urlCallback;\n\n                        const authData = await this.authWithOAuth2Code<T>(\n                            provider.name,\n                            e.code,\n                            provider.codeVerifier,\n                            redirectUrl,\n                            config.createData,\n                            options,\n                        );\n\n                        resolve(authData);\n                    } catch (err) {\n                        reject(new ClientResponseError(err));\n                    }\n\n                    cleanup();\n                });\n\n                const replacements: { [key: string]: any } = {\n                    state: realtime.clientId,\n                };\n                if (config.scopes?.length) {\n                    replacements[\"scope\"] = config.scopes.join(\" \");\n                }\n\n                const url = this._replaceQueryParams(\n                    provider.authUrl + redirectUrl,\n                    replacements,\n                );\n\n                let urlCallback =\n                    config.urlCallback ||\n                    function (url: string) {\n                        if (eagerDefaultPopup) {\n                            eagerDefaultPopup.location.href = url;\n                        } else {\n                            // it could have been blocked due to its empty initial url,\n                            // try again...\n                            eagerDefaultPopup = openBrowserPopup(url);\n                        }\n                    };\n\n                await urlCallback(url);\n            } catch (err) {\n                cleanup();\n                reject(new ClientResponseError(err));\n            }\n        });\n    }\n\n    /**\n     * Refreshes the current authenticated record instance and\n     * returns a new token and record data.\n     *\n     * On success this method also automatically updates the client's AuthStore.\n     *\n     * @throws {ClientResponseError}\n     */\n    async authRefresh<T = M>(options?: RecordOptions): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authRefresh(options?).\n     */\n    async authRefresh<T = M>(body?: any, query?: any): Promise<RecordAuthResponse<T>>;\n\n    async authRefresh<T = M>(\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-refresh\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Sends auth record password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestPasswordReset(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestPasswordReset(email, options?).\n     */\n    async requestPasswordReset(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestPasswordReset(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmPasswordReset(passwordResetToken, password, passwordConfirm, options?).\n     */\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: passwordResetToken,\n                password: password,\n                passwordConfirm: passwordConfirm,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Sends auth record verification email request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestVerification(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestVerification(email, options?).\n     */\n    async requestVerification(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestVerification(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-verification\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record email verification request.\n     *\n     * If the current `client.authStore.model` matches with the auth record from the token,\n     * then on success the `client.authStore.model.verified` will be updated to `true`.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmVerification(\n        verificationToken: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmVerification(verificationToken, options?).\n     */\n    async confirmVerification(\n        verificationToken: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmVerification(\n        verificationToken: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: verificationToken,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-verification\", options)\n            .then(() => {\n                // on success manually update the current auth record verified state\n                const payload = getTokenPayload(verificationToken);\n                const model = this.client.authStore.model;\n                if (\n                    model &&\n                    !model.verified &&\n                    model.id === payload.id &&\n                    model.collectionId === payload.collectionId\n                ) {\n                    model.verified = true;\n                    this.client.authStore.save(this.client.authStore.token, model);\n                }\n\n                return true;\n            });\n    }\n\n    /**\n     * Sends an email change request to the authenticated record model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestEmailChange(newEmail: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestEmailChange(newEmail, options?).\n     */\n    async requestEmailChange(newEmail: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestEmailChange(\n        newEmail: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                newEmail: newEmail,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-email-change\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record's new email address.\n     *\n     * If the current `client.authStore.model` matches with the auth record from the token,\n     * then on success the `client.authStore` will be cleared.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmEmailChange(emailChangeToken, password, options?).\n     */\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: emailChangeToken,\n                password: password,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-email-change\", options)\n            .then(() => {\n                const payload = getTokenPayload(emailChangeToken);\n                const model = this.client.authStore.model;\n                if (\n                    model &&\n                    model.id === payload.id &&\n                    model.collectionId === payload.collectionId\n                ) {\n                    this.client.authStore.clear();\n                }\n\n                return true;\n            });\n    }\n\n    /**\n     * Lists all linked external auth providers for the specified auth record.\n     *\n     * @throws {ClientResponseError}\n     */\n    async listExternalAuths(\n        recordId: string,\n        options?: CommonOptions,\n    ): Promise<Array<ExternalAuthModel>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\n            this.baseCrudPath + \"/\" + encodeURIComponent(recordId) + \"/external-auths\",\n            options,\n        );\n    }\n\n    /**\n     * Unlink a single external auth provider from the specified auth record.\n     *\n     * @throws {ClientResponseError}\n     */\n    async unlinkExternalAuth(\n        recordId: string,\n        provider: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(\n                this.baseCrudPath +\n                    \"/\" +\n                    encodeURIComponent(recordId) +\n                    \"/external-auths/\" +\n                    encodeURIComponent(provider),\n                options,\n            )\n            .then(() => true);\n    }\n\n    // ---------------------------------------------------------------\n\n    // very rudimentary url query params replacement because at the moment\n    // URL (and URLSearchParams) doesn't seem to be fully supported in React Native\n    //\n    // note: for details behind some of the decode/encode parsing check https://unixpapa.com/js/querystring.html\n    private _replaceQueryParams(\n        url: string,\n        replacements: { [key: string]: any } = {},\n    ): string {\n        let urlPath = url;\n        let query = \"\";\n\n        const queryIndex = url.indexOf(\"?\");\n        if (queryIndex >= 0) {\n            urlPath = url.substring(0, url.indexOf(\"?\"));\n            query = url.substring(url.indexOf(\"?\") + 1);\n        }\n\n        const parsedParams: { [key: string]: string } = {};\n\n        // parse the query parameters\n        const rawParams = query.split(\"&\");\n        for (const param of rawParams) {\n            if (param == \"\") {\n                continue;\n            }\n\n            const pair = param.split(\"=\");\n            parsedParams[decodeURIComponent(pair[0].replace(/\\+/g, \" \"))] =\n                decodeURIComponent((pair[1] || \"\").replace(/\\+/g, \" \"));\n        }\n\n        // apply the replacements\n        for (let key in replacements) {\n            if (!replacements.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (replacements[key] == null) {\n                delete parsedParams[key];\n            } else {\n                parsedParams[key] = replacements[key];\n            }\n        }\n\n        // construct back the full query string\n        query = \"\";\n        for (let key in parsedParams) {\n            if (!parsedParams.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (query != \"\") {\n                query += \"&\";\n            }\n\n            query +=\n                encodeURIComponent(key.replace(/%20/g, \"+\")) +\n                \"=\" +\n                encodeURIComponent(parsedParams[key].replace(/%20/g, \"+\"));\n        }\n\n        return query != \"\" ? urlPath + \"?\" + query : urlPath;\n    }\n}\n\nfunction openBrowserPopup(url?: string): Window | null {\n    if (typeof window === \"undefined\" || !window?.open) {\n        throw new ClientResponseError(\n            new Error(\n                `Not in a browser context - please pass a custom urlCallback function.`,\n            ),\n        );\n    }\n\n    let width = 1024;\n    let height = 768;\n\n    let windowWidth = window.innerWidth;\n    let windowHeight = window.innerHeight;\n\n    // normalize window size\n    width = width > windowWidth ? windowWidth : width;\n    height = height > windowHeight ? windowHeight : height;\n\n    let left = windowWidth / 2 - width / 2;\n    let top = windowHeight / 2 - height / 2;\n\n    // note: we don't use the noopener and noreferrer attributes since\n    // for some reason browser blocks such windows then url is undefined/blank\n    return window.open(\n        url,\n        \"popup_window\",\n        \"width=\" +\n            width +\n            \",height=\" +\n            height +\n            \",top=\" +\n            top +\n            \",left=\" +\n            left +\n            \",resizable,menubar=no\",\n    );\n}\n","import { CrudService } from \"@/services/utils/CrudService\";\nimport { CollectionModel } from \"@/services/utils/dtos\";\nimport { CommonOptions } from \"@/services/utils/options\";\n\nexport class CollectionService extends CrudService<CollectionModel> {\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return \"/api/collections\";\n    }\n\n    /**\n     * Imports the provided collections.\n     *\n     * If `deleteMissing` is `true`, all local collections and schema fields,\n     * that are not present in the imported configuration, WILL BE DELETED\n     * (including their related records data)!\n     *\n     * @throws {ClientResponseError}\n     */\n    async import(\n        collections: Array<CollectionModel>,\n        deleteMissing: boolean = false,\n        options?: CommonOptions,\n    ): Promise<true> {\n        options = Object.assign(\n            {\n                method: \"PUT\",\n                body: {\n                    collections: collections,\n                    deleteMissing: deleteMissing,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCrudPath + \"/import\", options).then(() => true);\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseService } from \"@/services/utils/BaseService\";\nimport { ListResult, LogModel } from \"@/services/utils/dtos\";\nimport { CommonOptions, ListOptions, LogStatsOptions } from \"@/services/utils/options\";\n\nexport interface HourlyStats {\n    total: number;\n    date: string;\n}\n\nexport class LogService extends BaseService {\n    /**\n     * Returns paginated logs list.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getList(\n        page = 1,\n        perPage = 30,\n        options?: ListOptions,\n    ): Promise<ListResult<LogModel>> {\n        options = Object.assign({ method: \"GET\" }, options);\n\n        options.query = Object.assign(\n            {\n                page: page,\n                perPage: perPage,\n            },\n            options.query,\n        );\n\n        return this.client.send(\"/api/logs\", options);\n    }\n\n    /**\n     * Returns a single log by its id.\n     *\n     * If `id` is empty it will throw a 404 error.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getOne(id: string, options?: CommonOptions): Promise<LogModel> {\n        if (!id) {\n            throw new ClientResponseError({\n                url: this.client.buildUrl(\"/api/logs/\"),\n                status: 404,\n                response: {\n                    code: 404,\n                    message: \"Missing required log id.\",\n                    data: {},\n                },\n            });\n        }\n\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/logs/\" + encodeURIComponent(id), options);\n    }\n\n    /**\n     * Returns logs statistics.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getStats(options?: LogStatsOptions): Promise<Array<HourlyStats>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/logs/stats\", options);\n    }\n}\n","import { BaseService } from \"@/services/utils/BaseService\";\nimport { CommonOptions } from \"@/services/utils/options\";\n\nexport interface HealthCheckResponse {\n    code: number;\n    message: string;\n    data: { [key: string]: any };\n}\n\nexport class HealthService extends BaseService {\n    /**\n     * Checks the health status of the api.\n     *\n     * @throws {ClientResponseError}\n     */\n    async check(options?: CommonOptions): Promise<HealthCheckResponse> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/health\", options);\n    }\n}\n","import { BaseService } from \"@/services/utils/BaseService\";\nimport { CommonOptions, FileOptions } from \"@/services/utils/options\";\n\nexport class FileService extends BaseService {\n    /**\n     * Builds and returns an absolute record file url for the provided filename.\n     */\n    getUrl(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        if (\n            !filename ||\n            !record?.id ||\n            !(record?.collectionId || record?.collectionName)\n        ) {\n            return \"\";\n        }\n\n        const parts = [];\n        parts.push(\"api\");\n        parts.push(\"files\");\n        parts.push(encodeURIComponent(record.collectionId || record.collectionName));\n        parts.push(encodeURIComponent(record.id));\n        parts.push(encodeURIComponent(filename));\n\n        let result = this.client.buildUrl(parts.join(\"/\"));\n\n        if (Object.keys(queryParams).length) {\n            // normalize the download query param for consistency with the Dart sdk\n            if (queryParams.download === false) {\n                delete queryParams.download;\n            }\n\n            const params = new URLSearchParams(queryParams);\n\n            result += (result.includes(\"?\") ? \"&\" : \"?\") + params;\n        }\n\n        return result;\n    }\n\n    /**\n     * Requests a new private file access token for the current auth model (admin or record).\n     *\n     * @throws {ClientResponseError}\n     */\n    async getToken(options?: CommonOptions): Promise<string> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(\"/api/files/token\", options)\n            .then((data) => data?.token || \"\");\n    }\n}\n","import { BaseService } from \"@/services/utils/BaseService\";\nimport { CommonOptions } from \"@/services/utils/options\";\n\nexport interface BackupFileInfo {\n    key: string;\n    size: number;\n    modified: string;\n}\n\nexport class BackupService extends BaseService {\n    /**\n     * Returns list with all available backup files.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList(options?: CommonOptions): Promise<Array<BackupFileInfo>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups\", options);\n    }\n\n    /**\n     * Initializes a new backup.\n     *\n     * @throws {ClientResponseError}\n     */\n    async create(basename: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    name: basename,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups\", options).then(() => true);\n    }\n\n    /**\n     * Uploads an existing backup file.\n     *\n     * Example:\n     *\n     * ```js\n     * await pb.backups.upload({\n     *     file: new Blob([...]),\n     * });\n     * ```\n     *\n     * @throws {ClientResponseError}\n     */\n    async upload(\n        bodyParams: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups/upload\", options).then(() => true);\n    }\n\n    /**\n     * Deletes a single backup file.\n     *\n     * @throws {ClientResponseError}\n     */\n    async delete(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/backups/${encodeURIComponent(key)}`, options)\n            .then(() => true);\n    }\n\n    /**\n     * Initializes an app data restore from an existing backup.\n     *\n     * @throws {ClientResponseError}\n     */\n    async restore(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/backups/${encodeURIComponent(key)}/restore`, options)\n            .then(() => true);\n    }\n\n    /**\n     * Builds a download url for a single existing backup using an\n     * admin file token and the backup file key.\n     *\n     * The file token can be generated via `pb.files.getToken()`.\n     */\n    getDownloadUrl(token: string, key: string): string {\n        return this.client.buildUrl(\n            `/api/backups/${encodeURIComponent(key)}?token=${encodeURIComponent(token)}`,\n        );\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseAuthStore } from \"@/stores/BaseAuthStore\";\nimport { LocalAuthStore } from \"@/stores/LocalAuthStore\";\nimport { SettingsService } from \"@/services/SettingsService\";\nimport { AdminService } from \"@/services/AdminService\";\nimport { RecordService } from \"@/services/RecordService\";\nimport { CollectionService } from \"@/services/CollectionService\";\nimport { LogService } from \"@/services/LogService\";\nimport { RealtimeService } from \"@/services/RealtimeService\";\nimport { HealthService } from \"@/services/HealthService\";\nimport { FileService } from \"@/services/FileService\";\nimport { BackupService } from \"@/services/BackupService\";\nimport { RecordModel } from \"@/services/utils/dtos\";\nimport {\n    SendOptions,\n    FileOptions,\n    normalizeUnknownQueryParams,\n} from \"@/services/utils/options\";\n\nexport interface BeforeSendResult {\n    [key: string]: any; // for backward compatibility\n    url?: string;\n    options?: { [key: string]: any };\n}\n\n/**\n * PocketBase JS Client.\n */\nexport default class Client {\n    /**\n     * The base PocketBase backend url address (eg. 'http://127.0.0.1.8090').\n     */\n    baseUrl: string;\n\n    /**\n     * Hook that get triggered right before sending the fetch request,\n     * allowing you to inspect and modify the url and request options.\n     *\n     * For list of the possible options check https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n     *\n     * You can return a non-empty result object `{ url, options }` to replace the url and request options entirely.\n     *\n     * Example:\n     * ```js\n     * client.beforeSend = function (url, options) {\n     *     options.headers = Object.assign({}, options.headers, {\n     *         'X-Custom-Header': 'example',\n     *     });\n     *\n     *     return { url, options }\n     * };\n     * ```\n     */\n    beforeSend?: (\n        url: string,\n        options: SendOptions,\n    ) => BeforeSendResult | Promise<BeforeSendResult>;\n\n    /**\n     * Hook that get triggered after successfully sending the fetch request,\n     * allowing you to inspect/modify the response object and its parsed data.\n     *\n     * Returns the new Promise resolved `data` that will be returned to the client.\n     *\n     * Example:\n     * ```js\n     * client.afterSend = function (response, data) {\n     *     if (response.status != 200) {\n     *         throw new ClientResponseError({\n     *             url:      response.url,\n     *             status:   response.status,\n     *             response: { ... },\n     *         });\n     *     }\n     *\n     *     return data;\n     * };\n     * ```\n     */\n    afterSend?: (response: Response, data: any) => any;\n\n    /**\n     * Optional language code (default to `en-US`) that will be sent\n     * with the requests to the server as `Accept-Language` header.\n     */\n    lang: string;\n\n    /**\n     * A replaceable instance of the local auth store service.\n     */\n    authStore: BaseAuthStore;\n\n    /**\n     * An instance of the service that handles the **Settings APIs**.\n     */\n    readonly settings: SettingsService;\n\n    /**\n     * An instance of the service that handles the **Admin APIs**.\n     */\n    readonly admins: AdminService;\n\n    /**\n     * An instance of the service that handles the **Collection APIs**.\n     */\n    readonly collections: CollectionService;\n\n    /**\n     * An instance of the service that handles the **File APIs**.\n     */\n    readonly files: FileService;\n\n    /**\n     * An instance of the service that handles the **Log APIs**.\n     */\n    readonly logs: LogService;\n\n    /**\n     * An instance of the service that handles the **Realtime APIs**.\n     */\n    readonly realtime: RealtimeService;\n\n    /**\n     * An instance of the service that handles the **Health APIs**.\n     */\n    readonly health: HealthService;\n\n    /**\n     * An instance of the service that handles the **Backup APIs**.\n     */\n    readonly backups: BackupService;\n\n    private cancelControllers: { [key: string]: AbortController } = {};\n    private recordServices: { [key: string]: RecordService } = {};\n    private enableAutoCancellation: boolean = true;\n\n    constructor(baseUrl = \"/\", authStore?: BaseAuthStore | null, lang = \"en-US\") {\n        this.baseUrl = baseUrl;\n        this.lang = lang;\n        this.authStore = authStore || new LocalAuthStore();\n\n        // services\n        this.admins = new AdminService(this);\n        this.collections = new CollectionService(this);\n        this.files = new FileService(this);\n        this.logs = new LogService(this);\n        this.settings = new SettingsService(this);\n        this.realtime = new RealtimeService(this);\n        this.health = new HealthService(this);\n        this.backups = new BackupService(this);\n    }\n\n    /**\n     * Returns the RecordService associated to the specified collection.\n     *\n     * @param  {string} idOrName\n     * @return {RecordService}\n     */\n    collection<M = RecordModel>(idOrName: string): RecordService<M> {\n        if (!this.recordServices[idOrName]) {\n            this.recordServices[idOrName] = new RecordService(this, idOrName);\n        }\n\n        return this.recordServices[idOrName];\n    }\n\n    /**\n     * Globally enable or disable auto cancellation for pending duplicated requests.\n     */\n    autoCancellation(enable: boolean): Client {\n        this.enableAutoCancellation = !!enable;\n\n        return this;\n    }\n\n    /**\n     * Cancels single request by its cancellation key.\n     */\n    cancelRequest(requestKey: string): Client {\n        if (this.cancelControllers[requestKey]) {\n            this.cancelControllers[requestKey].abort();\n            delete this.cancelControllers[requestKey];\n        }\n\n        return this;\n    }\n\n    /**\n     * Cancels all pending requests.\n     */\n    cancelAllRequests(): Client {\n        for (let k in this.cancelControllers) {\n            this.cancelControllers[k].abort();\n        }\n\n        this.cancelControllers = {};\n\n        return this;\n    }\n\n    /**\n     * Constructs a filter expression with placeholders populated from a parameters object.\n     *\n     * Placeholder parameters are defined with the `{:paramName}` notation.\n     *\n     * The following parameter values are supported:\n     *\n     * - `string` (_single quotes are autoescaped_)\n     * - `number`\n     * - `boolean`\n     * - `Date` object (_stringified into the PocketBase datetime format_)\n     * - `null`\n     * - everything else is converted to a string using `JSON.stringify()`\n     *\n     * Example:\n     *\n     * ```js\n     * pb.collection(\"example\").getFirstListItem(pb.filter(\n     *    'title ~ {:title} && created >= {:created}',\n     *    { title: \"example\", created: new Date()}\n     * ))\n     * ```\n     */\n    filter(raw: string, params?: { [key: string]: any }): string {\n        if (!params) {\n            return raw;\n        }\n\n        for (let key in params) {\n            let val = params[key];\n            switch (typeof val) {\n                case \"boolean\":\n                case \"number\":\n                    val = \"\" + val;\n                    break;\n                case \"string\":\n                    val = \"'\" + val.replace(/'/g, \"\\\\'\") + \"'\";\n                    break;\n                default:\n                    if (val === null) {\n                        val = \"null\";\n                    } else if (val instanceof Date) {\n                        val = \"'\" + val.toISOString().replace(\"T\", \" \") + \"'\";\n                    } else {\n                        val = \"'\" + JSON.stringify(val).replace(/'/g, \"\\\\'\") + \"'\";\n                    }\n            }\n            raw = raw.replaceAll(\"{:\" + key + \"}\", val);\n        }\n\n        return raw;\n    }\n\n    /**\n     * Legacy alias of `pb.files.getUrl()`.\n     */\n    getFileUrl(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        return this.files.getUrl(record, filename, queryParams);\n    }\n\n    /**\n     * Builds a full client url by safely concatenating the provided path.\n     */\n    buildUrl(path: string): string {\n        let url = this.baseUrl;\n\n        // construct an absolute base url if in a browser environment\n        if (\n            typeof window !== \"undefined\" &&\n            !!window.location &&\n            !url.startsWith(\"https://\") &&\n            !url.startsWith(\"http://\")\n        ) {\n            url = window.location.origin?.endsWith(\"/\")\n                ? window.location.origin.substring(0, window.location.origin.length - 1)\n                : window.location.origin || \"\";\n\n            if (!this.baseUrl.startsWith(\"/\")) {\n                url += window.location.pathname || \"/\";\n                url += url.endsWith(\"/\") ? \"\" : \"/\";\n            }\n\n            url += this.baseUrl;\n        }\n\n        // concatenate the path\n        if (path) {\n            url += url.endsWith(\"/\") ? \"\" : \"/\"; // append trailing slash if missing\n            url += path.startsWith(\"/\") ? path.substring(1) : path;\n        }\n\n        return url;\n    }\n\n    /**\n     * Sends an api http request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async send<T = any>(path: string, options: SendOptions): Promise<T> {\n        options = this.initSendOptions(path, options);\n\n        // build url + path\n        let url = this.buildUrl(path);\n\n        if (this.beforeSend) {\n            const result = Object.assign({}, await this.beforeSend(url, options));\n            if (\n                typeof result.url !== \"undefined\" ||\n                typeof result.options !== \"undefined\"\n            ) {\n                url = result.url || url;\n                options = result.options || options;\n            } else if (Object.keys(result).length) {\n                // legacy behavior\n                options = result as SendOptions;\n                console?.warn &&\n                    console.warn(\n                        \"Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.\",\n                    );\n            }\n        }\n\n        // serialize the query parameters\n        if (typeof options.query !== \"undefined\") {\n            const query = this.serializeQueryParams(options.query);\n            if (query) {\n                url += (url.includes(\"?\") ? \"&\" : \"?\") + query;\n            }\n            delete options.query;\n        }\n\n        // ensures that the json body is serialized\n        if (\n            this.getHeader(options.headers, \"Content-Type\") == \"application/json\" &&\n            options.body &&\n            typeof options.body !== \"string\"\n        ) {\n            options.body = JSON.stringify(options.body);\n        }\n\n        const fetchFunc = options.fetch || fetch;\n\n        // send the request\n        return fetchFunc(url, options)\n            .then(async (response) => {\n                let data: any = {};\n\n                try {\n                    data = await response.json();\n                } catch (_) {\n                    // all api responses are expected to return json\n                    // with the exception of the realtime event and 204\n                }\n\n                if (this.afterSend) {\n                    data = await this.afterSend(response, data);\n                }\n\n                if (response.status >= 400) {\n                    throw new ClientResponseError({\n                        url: response.url,\n                        status: response.status,\n                        data: data,\n                    });\n                }\n\n                return data as T;\n            })\n            .catch((err) => {\n                // wrap to normalize all errors\n                throw new ClientResponseError(err);\n            });\n    }\n\n    /**\n     * Shallow copy the provided object and takes care to initialize\n     * any options required to preserve the backward compatability.\n     *\n     * @param  {SendOptions} options\n     * @return {SendOptions}\n     */\n    private initSendOptions(path: string, options: SendOptions): SendOptions {\n        options = Object.assign({ method: \"GET\" } as SendOptions, options);\n\n        // auto convert the body to FormData, if needed\n        options.body = this.convertToFormDataIfNeeded(options.body);\n\n        // move unknown send options as query parameters\n        normalizeUnknownQueryParams(options);\n\n        // requestKey normalizations for backward-compatibility\n        // ---\n        options.query = Object.assign({}, options.params, options.query);\n        if (typeof options.requestKey === \"undefined\") {\n            if (options.$autoCancel === false || options.query.$autoCancel === false) {\n                options.requestKey = null;\n            } else if (options.$cancelKey || options.query.$cancelKey) {\n                options.requestKey = options.$cancelKey || options.query.$cancelKey;\n            }\n        }\n        // remove the deprecated special cancellation params from the other query params\n        delete options.$autoCancel;\n        delete options.query.$autoCancel;\n        delete options.$cancelKey;\n        delete options.query.$cancelKey;\n        // ---\n\n        // add the json header, if not explicitly set\n        // (for FormData body the Content-Type header should be skipped since the boundary is autogenerated)\n        if (\n            this.getHeader(options.headers, \"Content-Type\") === null &&\n            !this.isFormData(options.body)\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                \"Content-Type\": \"application/json\",\n            });\n        }\n\n        // add Accept-Language header, if not explicitly set\n        if (this.getHeader(options.headers, \"Accept-Language\") === null) {\n            options.headers = Object.assign({}, options.headers, {\n                \"Accept-Language\": this.lang,\n            });\n        }\n\n        // check if Authorization header can be added\n        if (\n            // has valid token\n            this.authStore.token &&\n            // auth header is not explicitly set\n            this.getHeader(options.headers, \"Authorization\") === null\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                Authorization: this.authStore.token,\n            });\n        }\n\n        // handle auto cancelation for duplicated pending request\n        if (this.enableAutoCancellation && options.requestKey !== null) {\n            const requestKey = options.requestKey || (options.method || \"GET\") + path;\n\n            delete options.requestKey;\n\n            // cancel previous pending requests\n            this.cancelRequest(requestKey);\n\n            const controller = new AbortController();\n            this.cancelControllers[requestKey] = controller;\n            options.signal = controller.signal;\n        }\n\n        return options;\n    }\n\n    /**\n     * Converts analyzes the provided body and converts it to FormData\n     * in case a plain object with File/Blob values is used.\n     */\n    private convertToFormDataIfNeeded(body: any): any {\n        if (\n            typeof FormData === \"undefined\" ||\n            typeof body === \"undefined\" ||\n            typeof body !== \"object\" ||\n            body === null ||\n            this.isFormData(body) ||\n            !this.hasBlobField(body)\n        ) {\n            return body;\n        }\n\n        const form = new FormData();\n\n        for (const key in body) {\n            const val = body[key];\n\n            if (typeof val === \"object\" && !this.hasBlobField({ data: val })) {\n                // send json-like values as jsonPayload to avoid the implicit string value normalization\n                let payload: { [key: string]: any } = {};\n                payload[key] = val;\n                form.append(\"@jsonPayload\", JSON.stringify(payload));\n            } else {\n                // in case of mixed string and file/blob\n                const normalizedVal = Array.isArray(val) ? val : [val];\n                for (let v of normalizedVal) {\n                    form.append(key, v);\n                }\n            }\n        }\n\n        return form;\n    }\n\n    /**\n     * Checks if the submitted body object has at least one Blob/File field.\n     */\n    private hasBlobField(body: { [key: string]: any }): boolean {\n        for (const key in body) {\n            const values = Array.isArray(body[key]) ? body[key] : [body[key]];\n            for (const v of values) {\n                if (\n                    (typeof Blob !== \"undefined\" && v instanceof Blob) ||\n                    (typeof File !== \"undefined\" && v instanceof File)\n                ) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Extracts the header with the provided name in case-insensitive manner.\n     * Returns `null` if no header matching the name is found.\n     */\n    private getHeader(\n        headers: { [key: string]: string } | undefined,\n        name: string,\n    ): string | null {\n        headers = headers || {};\n        name = name.toLowerCase();\n\n        for (let key in headers) {\n            if (key.toLowerCase() == name) {\n                return headers[key];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Loosely checks if the specified body is a FormData instance.\n     */\n    private isFormData(body: any): boolean {\n        return (\n            body &&\n            // we are checking the constructor name because FormData\n            // is not available natively in some environments and the\n            // polyfill(s) may not be globally accessible\n            (body.constructor.name === \"FormData\" ||\n                // fallback to global FormData instance check\n                // note: this is needed because the constructor.name could be different in case of\n                //       custom global FormData implementation, eg. React Native on Android/iOS\n                (typeof FormData !== \"undefined\" && body instanceof FormData))\n        );\n    }\n\n    /**\n     * Serializes the provided query parameters into a query string.\n     */\n    private serializeQueryParams(params: { [key: string]: any }): string {\n        const result: Array<string> = [];\n        for (const key in params) {\n            if (params[key] === null) {\n                // skip null query params\n                continue;\n            }\n\n            const value = params[key];\n            const encodedKey = encodeURIComponent(key);\n\n            if (Array.isArray(value)) {\n                // repeat array params\n                for (const v of value) {\n                    result.push(encodedKey + \"=\" + encodeURIComponent(v));\n                }\n            } else if (value instanceof Date) {\n                result.push(encodedKey + \"=\" + encodeURIComponent(value.toISOString()));\n            } else if (typeof value !== null && typeof value === \"object\") {\n                result.push(encodedKey + \"=\" + encodeURIComponent(JSON.stringify(value)));\n            } else {\n                result.push(encodedKey + \"=\" + encodeURIComponent(value));\n            }\n        }\n\n        return result.join(\"&\");\n    }\n}\n","import { BaseAuthStore, AuthModel } from \"@/stores/BaseAuthStore\";\n\nexport type AsyncSaveFunc = (serializedPayload: string) => Promise<void>;\n\nexport type AsyncClearFunc = () => Promise<void>;\n\ntype queueFunc = () => Promise<void>;\n\n/**\n * AsyncAuthStore is a helper auth store implementation\n * that could be used with any external async persistent layer\n * (key-value db, local file, etc.).\n *\n * Here is an example with the React Native AsyncStorage package:\n *\n * ```\n * import AsyncStorage from \"@react-native-async-storage/async-storage\";\n * import PocketBase, { AsyncAuthStore } from \"pocketbase\";\n *\n * const store = new AsyncAuthStore({\n *     save:    async (serialized) => AsyncStorage.setItem(\"pb_auth\", serialized),\n *     initial: AsyncStorage.getItem(\"pb_auth\"),\n * });\n *\n * const pb = new PocketBase(\"https://example.com\", store)\n * ```\n */\nexport class AsyncAuthStore extends BaseAuthStore {\n    private saveFunc: AsyncSaveFunc;\n    private clearFunc?: AsyncClearFunc;\n    private queue: Array<queueFunc> = [];\n\n    constructor(config: {\n        // The async function that is called every time\n        // when the auth store state needs to be persisted.\n        save: AsyncSaveFunc;\n\n        /// An *optional* async function that is called every time\n        /// when the auth store needs to be cleared.\n        ///\n        /// If not explicitly set, `saveFunc` with empty data will be used.\n        clear?: AsyncClearFunc;\n\n        // An *optional* initial data to load into the store.\n        initial?: string | Promise<any>;\n    }) {\n        super();\n\n        this.saveFunc = config.save;\n        this.clearFunc = config.clear;\n\n        this._enqueue(() => this._loadInitial(config.initial));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, model?: AuthModel): void {\n        super.save(token, model);\n\n        let value = \"\";\n        try {\n            value = JSON.stringify({ token, model });\n        } catch (err) {\n            console.warn(\"AsyncAuthStore: failed to stringify the new state\");\n        }\n\n        this._enqueue(() => this.saveFunc(value));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear(): void {\n        super.clear();\n\n        if (this.clearFunc) {\n            this._enqueue(() => this.clearFunc!());\n        } else {\n            this._enqueue(() => this.saveFunc(\"\"));\n        }\n    }\n\n    /**\n     * Initializes the auth store state.\n     */\n    private async _loadInitial(payload?: string | Promise<any>) {\n        try {\n            payload = await payload;\n\n            if (payload) {\n                let parsed;\n                if (typeof payload === \"string\") {\n                    parsed = JSON.parse(payload) || {};\n                } else if (typeof payload === \"object\") {\n                    parsed = payload;\n                }\n\n                this.save(parsed.token || \"\", parsed.model || null);\n            }\n        } catch (_) {}\n    }\n\n    /**\n     * Appends an async function to the queue.\n     */\n    private _enqueue(asyncCallback: () => Promise<void>) {\n        this.queue.push(asyncCallback);\n\n        if (this.queue.length == 1) {\n            this._dequeue();\n        }\n    }\n\n    /**\n     * Starts the queue processing.\n     */\n    private _dequeue() {\n        if (!this.queue.length) {\n            return;\n        }\n\n        this.queue[0]().finally(() => {\n            this.queue.shift();\n\n            if (!this.queue.length) {\n                return;\n            }\n\n            this._dequeue();\n        });\n    }\n}\n"],"names":["ClientResponseError","Error","constructor","errData","super","this","url","status","response","isAbort","originalError","Object","setPrototypeOf","prototype","data","DOMException","name","message","cause","includes","toJSON","fieldContentRegExp","cookieParse","str","options","result","decode","assign","defaultDecode","index","length","eqIdx","indexOf","endIdx","lastIndexOf","key","slice","trim","undefined","val","charCodeAt","_","cookieSerialize","opt","encode","defaultEncode","test","TypeError","value","maxAge","isNaN","isFinite","Math","floor","domain","path","expires","isDate","toString","call","Date","valueOf","toUTCString","httpOnly","secure","priority","toLowerCase","sameSite","decodeURIComponent","encodeURIComponent","atobPolyfill","getTokenPayload","token","encodedPayload","split","map","c","join","JSON","parse","e","isTokenExpired","expirationThreshold","payload","keys","exp","now","atob","input","String","replace","bs","buffer","bc","idx","output","charAt","fromCharCode","defaultCookieKey","BaseAuthStore","baseToken","baseModel","_onChangeCallbacks","model","isValid","isAdmin","type","isAuthRecord","save","triggerChange","clear","loadFromCookie","cookie","rawData","Array","isArray","exportToCookie","defaultOptions","stringify","resultLength","Blob","size","id","email","extraProps","prop","onChange","callback","fireImmediately","push","i","splice","LocalAuthStore","storageKey","storageFallback","_bindStorageEvent","_storageGet","_storageSet","_storageRemove","window","localStorage","rawValue","getItem","normalizedVal","setItem","removeItem","addEventListener","BaseService","client","SettingsService","getAll","method","send","update","bodyParams","body","testS3","filesystem","then","testEmail","toEmail","emailTemplate","template","generateAppleClientSecret","clientId","teamId","keyId","privateKey","duration","CrudService","getFullList","batchOrqueryParams","_getFullList","batch","getList","page","perPage","query","baseCrudPath","responseData","items","item","getFirstListItem","filter","requestKey","skipTotal","code","getOne","buildUrl","create","batchSize","request","async","list","concat","normalizeLegacyOptionsArgs","legacyWarn","baseOptions","bodyOrOptions","hasQuery","console","warn","resetAutoRefresh","_resetAutoRefresh","AdminService","authStore","collectionId","delete","success","authResponse","admin","authWithPassword","password","identity","autoRefreshThreshold","autoRefresh","authData","registerAutoRefresh","threshold","refreshFunc","reauthenticateFunc","oldBeforeSend","beforeSend","oldModel","unsubStoreChange","newToken","sendOptions","oldToken","headers","authRefresh","bind","requestPasswordReset","confirmPasswordReset","resetToken","passwordConfirm","knownSendOptionsKeys","normalizeUnknownQueryParams","RealtimeService","eventSource","subscriptions","lastSentSubscriptions","maxConnectTimeout","reconnectAttempts","maxReconnectAttempts","Infinity","predefinedReconnectIntervals","pendingConnects","isConnected","subscribe","topic","serialized","listener","msgEvent","submitSubscriptions","connect","unsubscribeByTopicAndListener","unsubscribe","needToSubmit","subs","getSubscriptionsByTopic","hasSubscriptionListeners","removeEventListener","disconnect","unsubscribeByPrefix","keyPrefix","hasAtleastOneTopic","startsWith","exist","keyToCheck","addAllSubscriptionListeners","getNonEmptySubscriptionKeys","getSubscriptionsCancelKey","catch","err","removeAllSubscriptionListeners","Promise","resolve","reject","initConnect","clearTimeout","connectTimeoutId","setTimeout","connectErrorHandler","EventSource","onerror","lastEventId","retries","hasUnsentSubscriptions","p","reconnectTimeoutId","connectSubs","latestTopics","t","timeout","fromReconnect","cancelRequest","close","RecordService","collectionIdOrName","baseCollectionPath","realtime","batchOrOptions","params","collectionName","record","listAuthMethods","usernamePassword","emailPassword","authProviders","usernameOrEmail","authWithOAuth2Code","provider","codeVerifier","redirectUrl","createData","authWithOAuth2","args","config","find","eagerDefaultPopup","cleanup","urlCallback","openBrowserPopup","oldState","state","error","scopes","replacements","_replaceQueryParams","authUrl","location","href","passwordResetToken","requestVerification","confirmVerification","verificationToken","verified","requestEmailChange","newEmail","confirmEmailChange","emailChangeToken","listExternalAuths","recordId","unlinkExternalAuth","urlPath","substring","parsedParams","rawParams","param","pair","hasOwnProperty","open","width","height","windowWidth","innerWidth","windowHeight","innerHeight","left","top","CollectionService","import","collections","deleteMissing","LogService","getStats","HealthService","check","FileService","getUrl","filename","queryParams","parts","download","URLSearchParams","getToken","BackupService","basename","upload","restore","getDownloadUrl","Client","baseUrl","lang","cancelControllers","recordServices","enableAutoCancellation","admins","files","logs","settings","health","backups","collection","idOrName","autoCancellation","enable","abort","cancelAllRequests","k","raw","toISOString","replaceAll","getFileUrl","origin","endsWith","pathname","initSendOptions","serializeQueryParams","getHeader","fetch","json","afterSend","convertToFormDataIfNeeded","$autoCancel","$cancelKey","isFormData","Authorization","controller","AbortController","signal","FormData","hasBlobField","form","v","append","values","File","encodedKey","AsyncAuthStore","queue","saveFunc","clearFunc","_enqueue","_loadInitial","initial","parsed","asyncCallback","_dequeue","finally","shift"],"version":3,"file":"index.298f60af.js.map","sourceRoot":"/__parcel_source_root/"}