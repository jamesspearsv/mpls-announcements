{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,U,I,G,I,E,E,SCuDA,EAHS,CAAE,UAjDT,SAAmB,CAAK,CAAE,CAAI,CAAE,CAAM,CAAE,CAAS,EAC/C,MAAO,CACL,MAAA,EACA,KAAA,EACA,OAAA,EACA,UAAA,CACF,CACF,EA0CoB,UAxCpB,SAAmB,CAAI,CAAE,CAAQ,CAAE,CAAQ,CAAE,CAAe,EAC1D,MAAO,CACL,SAAA,EACA,gBAAiB,CAAA,EACjB,SAAA,EACA,gBAAA,EACA,KAAA,EACA,QAAS,CAAA,CACX,CACF,EA+B+B,cA7B/B,SAAuB,CAAK,EAC1B,IAAM,EAAW,EAAM,QAAQ,CAG/B,GAAI,EAAS,KAAK,CAAE,OAAO,KAC3B,GAAI,EAAS,YAAY,CAAE,MAAO,WAClC,GAAI,EAAS,eAAe,CAAE,CAC5B,GAAI,AAAe,SAAf,EAAM,IAAI,CAAa,MAAO,8BAClC,GAAI,AAAe,aAAf,EAAM,IAAI,CAAiB,MAAO,gCACxC,CACA,GAAI,EAAS,QAAQ,CAAE,MAAO,kCAChC,EAkB8C,aAhB9C,SAAsB,CAAI,EACxB,IAAM,EAAW,EAAK,QAAQ,CACxB,EAAQ,EAAS,eAAe,CAAC,sBAAsB,CAAC,QAAQ,CAAC,EAAE,QAEzE,AAAI,EAAS,QAAQ,CAAC,KAAK,GAAK,EAAS,eAAe,CAAC,KAAK,EAC5D,QAAQ,GAAG,CAAC,GACZ,AAAA,CAAA,EAAA,EAAA,OAAG,AAAH,EAAK,SAAS,CAAC,EAAO,0BACf,CAAA,IAEP,AAAA,CAAA,EAAA,EAAA,OAAG,AAAH,EAAK,SAAS,CAAC,EAAO,IAIjB,EAAK,aAAa,GAC3B,CAE2D,C,G,E,Q,S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","sources":["<anon>","src/js/helper.js","src/js/view.js","src/js/backend.js","node_modules/pocketbase/dist/pocketbase.es.mjs","node_modules/pocketbase/src/ClientResponseError.ts","node_modules/pocketbase/src/stores/utils/cookie.ts","node_modules/pocketbase/src/stores/utils/jwt.ts","node_modules/pocketbase/src/stores/BaseAuthStore.ts","node_modules/pocketbase/src/stores/LocalAuthStore.ts","node_modules/pocketbase/src/services/utils/BaseService.ts","node_modules/pocketbase/src/services/SettingsService.ts","node_modules/pocketbase/src/services/utils/CrudService.ts","node_modules/pocketbase/src/services/utils/legacy.ts","node_modules/pocketbase/src/services/utils/refresh.ts","node_modules/pocketbase/src/services/AdminService.ts","node_modules/pocketbase/src/services/utils/options.ts","node_modules/pocketbase/src/services/RealtimeService.ts","node_modules/pocketbase/src/services/RecordService.ts","node_modules/pocketbase/src/services/CollectionService.ts","node_modules/pocketbase/src/services/LogService.ts","node_modules/pocketbase/src/services/HealthService.ts","node_modules/pocketbase/src/services/FileService.ts","node_modules/pocketbase/src/services/BackupService.ts","node_modules/pocketbase/src/Client.ts","node_modules/pocketbase/src/stores/AsyncAuthStore.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire9b17\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire9b17\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"i9R9q\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $d3824bf2ef2465db$export$2e2bcd8739ae039);\n\nvar $17YkW = parcelRequire(\"17YkW\");\nconst $d3824bf2ef2465db$var$helper = (()=>{\n    function buildPost(title, body, author, author_id) {\n        return {\n            title: title,\n            body: body,\n            author: author,\n            author_id: author_id\n        };\n    }\n    function buildUser(name, username, password, passwordConfirm) {\n        return {\n            username: username,\n            emailVisibility: false,\n            password: password,\n            passwordConfirm: passwordConfirm,\n            name: name,\n            isAdmin: false\n        };\n    }\n    function validateInput(input) {\n        const validity = input.validity;\n        // Validity Cases\n        if (validity.valid) return null;\n        if (validity.valueMissing) return \"Required\";\n        if (validity.patternMismatch) {\n            if (input.name === \"name\") return \"Please match format: John S\";\n            if (input.name === \"username\") return \"Should be lowercase, no spaces\";\n        }\n        if (validity.tooShort) return \"Please use at least 5 characters\";\n    }\n    function validateForm(form) {\n        const elements = form.elements;\n        const error = elements.passwordConfirm.previousElementSibling.children[0];\n        if (elements.password.value !== elements.passwordConfirm.value) {\n            console.log(error);\n            (0, $17YkW.default).showError(error, \"Passwords do not match\");\n            return false;\n        } else (0, $17YkW.default).showError(error, \"\");\n        // Check form validity\n        return form.checkValidity();\n    }\n    return {\n        buildPost: buildPost,\n        buildUser: buildUser,\n        validateInput: validateInput,\n        validateForm: validateForm\n    };\n})();\nvar $d3824bf2ef2465db$export$2e2bcd8739ae039 = $d3824bf2ef2465db$var$helper;\n\n});\nparcelRegister(\"17YkW\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $0d253f80dc492c18$export$2e2bcd8739ae039);\nconst $0d253f80dc492c18$var$view = (()=>{\n    const buildPosts = (posts, currentUser)=>{\n        // FUNCTION THE BUILDS POST IN UI\n        const postsContainer = document.getElementById(\"posts-container\");\n        // Clear post in UI\n        clearPosts(postsContainer);\n        // Update UI to stay in sync with data\n        updateHeading(currentUser);\n        updateUI(currentUser);\n        for (let post of posts){\n            const title = document.createElement(\"h2\");\n            title.classList.add(\"post-title\");\n            title.textContent = post.title;\n            const author = document.createElement(\"div\");\n            author.classList.add(\"post-author\");\n            author.textContent = post.author;\n            const date = document.createElement(\"div\");\n            date.classList.add(\"post-date\");\n            date.textContent = new Date(post.created).toDateString();\n            const byline = document.createElement(\"div\");\n            byline.classList.add(\"post-byline\");\n            byline.appendChild(author);\n            byline.appendChild(date);\n            // Render delete button is user is logged in, only renders on user's posts unless user is admin\n            if (currentUser && (currentUser.id === post.author_id || currentUser.isAdmin)) {\n                const del = document.createElement(\"button\");\n                del.classList.add(\"post-delete\");\n                del.innerHTML = \"<span>\\xd7</span>\";\n                del.onclick = ()=>{\n                    const deletionModal = document.getElementById(\"deletion-modal\");\n                    // set post_id data attribute to post id onclick. Used for post deletion\n                    deletionModal.dataset.post_id = post.id;\n                    openModal(deletionModal);\n                };\n                byline.appendChild(del);\n            }\n            const divider = document.createElement(\"div\");\n            divider.classList.add(\"divider\");\n            const body = document.createElement(\"div\");\n            body.classList.add(\"post-body\");\n            body.innerHTML = post.body;\n            const announcement = document.createElement(\"div\");\n            announcement.classList.add(\"post\");\n            announcement.dataset.author_id = post.author_id;\n            announcement.dataset.post_id = post.id;\n            announcement.appendChild(title);\n            announcement.appendChild(byline);\n            announcement.appendChild(divider);\n            announcement.appendChild(body);\n            postsContainer.appendChild(announcement);\n        }\n    };\n    const updateHeading = (currentUser)=>{\n        const authHeading = document.getElementById(\"auth-heading\");\n        const username = document.getElementById(\"current-username\");\n        if (!currentUser) {\n            authHeading.style.display = \"none\";\n            username.textContent = \"NO USER\";\n            return;\n        }\n        authHeading.style.display = \"flex\";\n        username.textContent = currentUser.name;\n        return;\n    };\n    const updateUI = (currentUser)=>{\n        const button = document.getElementById(\"new-post-button\");\n        if (!currentUser) button.textContent = \"Log In\";\n        else button.textContent = \"New Announcement\";\n    };\n    const clearPosts = (parent)=>{\n        while(parent.hasChildNodes())parent.removeChild(parent.firstChild);\n    };\n    const openModal = (modal)=>{\n        modal.showModal();\n    };\n    const closeModal = (modal)=>{\n        modal.close();\n    };\n    const showError = (element, error)=>{\n        element.textContent = error;\n    };\n    return {\n        buildPosts: buildPosts,\n        openModal: openModal,\n        closeModal: closeModal,\n        showError: showError\n    };\n})();\nvar $0d253f80dc492c18$export$2e2bcd8739ae039 = $0d253f80dc492c18$var$view;\n\n});\n\n\nparcelRegister(\"6MoCM\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $4efa53a9ba85f959$export$2e2bcd8739ae039);\n\nvar $1LIL3 = parcelRequire(\"1LIL3\");\nconst $4efa53a9ba85f959$var$url = \"https://mpls.pockethost.io/\";\nconst $4efa53a9ba85f959$var$pb = new (0, $1LIL3.default)($4efa53a9ba85f959$var$url);\n// A MODULE TO HANDLE CALLS TO POCKETBASE BACKEND\nconst $4efa53a9ba85f959$var$backend = (()=>{\n    async function getPosts() {\n        try {\n            const records = await $4efa53a9ba85f959$var$pb.collection(\"posts\").getFullList({\n                sort: \"-created\"\n            });\n            return records;\n        } catch (error) {\n            console.log(error);\n        }\n    }\n    async function pushPost(post) {\n        if (!$4efa53a9ba85f959$var$backend.getCurrentUser()) return false;\n        try {\n            await $4efa53a9ba85f959$var$pb.collection(\"posts\").create(post);\n        } catch (error) {\n            console.log(error);\n        }\n    }\n    async function deletePost(id) {\n        if (!$4efa53a9ba85f959$var$backend.getCurrentUser()) return false;\n        try {\n            await $4efa53a9ba85f959$var$pb.collection(\"posts\").delete(id);\n        } catch (error) {\n            console.log(error);\n        }\n    }\n    async function createUser(user) {\n        try {\n            // create user in backend\n            const record = await $4efa53a9ba85f959$var$pb.collection(\"users\").create(user);\n            return record;\n        } catch (error) {\n            // throw error\n            return error.data;\n        }\n    }\n    async function authUser(username, password) {\n        // Attempt to log in user.\n        // Return true if successful else return false\n        try {\n            const authData = await $4efa53a9ba85f959$var$pb.collection(\"users\").authWithPassword(username, password);\n            return true;\n        } catch (error) {\n            console.log(error);\n            return false;\n        }\n    }\n    function getCurrentUser() {\n        // Check current user. Returns null if no user\n        return $4efa53a9ba85f959$var$pb.authStore.model;\n    }\n    function logoutUser() {\n        return $4efa53a9ba85f959$var$pb.authStore.clear();\n    }\n    return {\n        getPosts: getPosts,\n        pushPost: pushPost,\n        deletePost: deletePost,\n        createUser: createUser,\n        authUser: authUser,\n        getCurrentUser: getCurrentUser,\n        logoutUser: logoutUser\n    };\n})();\nvar $4efa53a9ba85f959$export$2e2bcd8739ae039 = $4efa53a9ba85f959$var$backend;\n\n});\nparcelRegister(\"1LIL3\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $5582cf41b70f685b$export$2e2bcd8739ae039);\nclass $5582cf41b70f685b$export$dcaf143e197b2cd2 extends Error {\n    constructor(e){\n        super(\"ClientResponseError\"), this.url = \"\", this.status = 0, this.response = {}, this.isAbort = !1, this.originalError = null, Object.setPrototypeOf(this, $5582cf41b70f685b$export$dcaf143e197b2cd2.prototype), null !== e && \"object\" == typeof e && (this.url = \"string\" == typeof e.url ? e.url : \"\", this.status = \"number\" == typeof e.status ? e.status : 0, this.isAbort = !!e.isAbort, this.originalError = e.originalError, null !== e.response && \"object\" == typeof e.response ? this.response = e.response : null !== e.data && \"object\" == typeof e.data ? this.response = e.data : this.response = {}), this.originalError || e instanceof $5582cf41b70f685b$export$dcaf143e197b2cd2 || (this.originalError = e), \"undefined\" != typeof DOMException && e instanceof DOMException && (this.isAbort = !0), this.name = \"ClientResponseError \" + this.status, this.message = this.response?.message, this.message || (this.isAbort ? this.message = \"The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation.\" : this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\") ? this.message = \"Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).\" : this.message = \"Something went wrong while processing your request.\");\n    }\n    get data() {\n        return this.response;\n    }\n    toJSON() {\n        return {\n            ...this\n        };\n    }\n}\nconst $5582cf41b70f685b$var$e = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nfunction $5582cf41b70f685b$export$2314e25186e9360(e, t) {\n    const s = {};\n    if (\"string\" != typeof e) return s;\n    const i = Object.assign({}, t || {}).decode || $5582cf41b70f685b$var$defaultDecode;\n    let n = 0;\n    for(; n < e.length;){\n        const t = e.indexOf(\"=\", n);\n        if (-1 === t) break;\n        let r = e.indexOf(\";\", n);\n        if (-1 === r) r = e.length;\n        else if (r < t) {\n            n = e.lastIndexOf(\";\", t - 1) + 1;\n            continue;\n        }\n        const o = e.slice(n, t).trim();\n        if (void 0 === s[o]) {\n            let n = e.slice(t + 1, r).trim();\n            34 === n.charCodeAt(0) && (n = n.slice(1, -1));\n            try {\n                s[o] = i(n);\n            } catch (e) {\n                s[o] = n;\n            }\n        }\n        n = r + 1;\n    }\n    return s;\n}\nfunction $5582cf41b70f685b$export$879d2f108927fb90(t, s, i) {\n    const n = Object.assign({}, i || {}), r = n.encode || $5582cf41b70f685b$var$defaultEncode;\n    if (!$5582cf41b70f685b$var$e.test(t)) throw new TypeError(\"argument name is invalid\");\n    const o = r(s);\n    if (o && !$5582cf41b70f685b$var$e.test(o)) throw new TypeError(\"argument val is invalid\");\n    let a = t + \"=\" + o;\n    if (null != n.maxAge) {\n        const e = n.maxAge - 0;\n        if (isNaN(e) || !isFinite(e)) throw new TypeError(\"option maxAge is invalid\");\n        a += \"; Max-Age=\" + Math.floor(e);\n    }\n    if (n.domain) {\n        if (!$5582cf41b70f685b$var$e.test(n.domain)) throw new TypeError(\"option domain is invalid\");\n        a += \"; Domain=\" + n.domain;\n    }\n    if (n.path) {\n        if (!$5582cf41b70f685b$var$e.test(n.path)) throw new TypeError(\"option path is invalid\");\n        a += \"; Path=\" + n.path;\n    }\n    if (n.expires) {\n        if (!function isDate(e) {\n            return \"[object Date]\" === Object.prototype.toString.call(e) || e instanceof Date;\n        }(n.expires) || isNaN(n.expires.valueOf())) throw new TypeError(\"option expires is invalid\");\n        a += \"; Expires=\" + n.expires.toUTCString();\n    }\n    if (n.httpOnly && (a += \"; HttpOnly\"), n.secure && (a += \"; Secure\"), n.priority) switch(\"string\" == typeof n.priority ? n.priority.toLowerCase() : n.priority){\n        case \"low\":\n            a += \"; Priority=Low\";\n            break;\n        case \"medium\":\n            a += \"; Priority=Medium\";\n            break;\n        case \"high\":\n            a += \"; Priority=High\";\n            break;\n        default:\n            throw new TypeError(\"option priority is invalid\");\n    }\n    if (n.sameSite) switch(\"string\" == typeof n.sameSite ? n.sameSite.toLowerCase() : n.sameSite){\n        case !0:\n            a += \"; SameSite=Strict\";\n            break;\n        case \"lax\":\n            a += \"; SameSite=Lax\";\n            break;\n        case \"strict\":\n            a += \"; SameSite=Strict\";\n            break;\n        case \"none\":\n            a += \"; SameSite=None\";\n            break;\n        default:\n            throw new TypeError(\"option sameSite is invalid\");\n    }\n    return a;\n}\nfunction $5582cf41b70f685b$var$defaultDecode(e) {\n    return -1 !== e.indexOf(\"%\") ? decodeURIComponent(e) : e;\n}\nfunction $5582cf41b70f685b$var$defaultEncode(e) {\n    return encodeURIComponent(e);\n}\nlet $5582cf41b70f685b$var$t;\nfunction $5582cf41b70f685b$export$26ddc56bc995240a(e) {\n    if (e) try {\n        const s = decodeURIComponent($5582cf41b70f685b$var$t(e.split(\".\")[1]).split(\"\").map(function(e) {\n            return \"%\" + (\"00\" + e.charCodeAt(0).toString(16)).slice(-2);\n        }).join(\"\"));\n        return JSON.parse(s) || {};\n    } catch (e) {}\n    return {};\n}\nfunction $5582cf41b70f685b$export$b007d77a962aa175(e, t = 0) {\n    let s = $5582cf41b70f685b$export$26ddc56bc995240a(e);\n    return !(Object.keys(s).length > 0 && (!s.exp || s.exp - t > Date.now() / 1e3));\n}\n$5582cf41b70f685b$var$t = \"function\" == typeof atob ? atob : (e)=>{\n    let t = String(e).replace(/=+$/, \"\");\n    if (t.length % 4 == 1) throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    for(var s, i, n = 0, r = 0, o = \"\"; i = t.charAt(r++); ~i && (s = n % 4 ? 64 * s + i : i, n++ % 4) && (o += String.fromCharCode(255 & s >> (-2 * n & 6))))i = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(i);\n    return o;\n};\nconst $5582cf41b70f685b$var$s = \"pb_auth\";\nclass $5582cf41b70f685b$export$68a044b9d3f6e888 {\n    constructor(){\n        this.baseToken = \"\", this.baseModel = null, this._onChangeCallbacks = [];\n    }\n    get token() {\n        return this.baseToken;\n    }\n    get model() {\n        return this.baseModel;\n    }\n    get isValid() {\n        return !$5582cf41b70f685b$export$b007d77a962aa175(this.token);\n    }\n    get isAdmin() {\n        return \"admin\" === $5582cf41b70f685b$export$26ddc56bc995240a(this.token).type;\n    }\n    get isAuthRecord() {\n        return \"authRecord\" === $5582cf41b70f685b$export$26ddc56bc995240a(this.token).type;\n    }\n    save(e, t) {\n        this.baseToken = e || \"\", this.baseModel = t || null, this.triggerChange();\n    }\n    clear() {\n        this.baseToken = \"\", this.baseModel = null, this.triggerChange();\n    }\n    loadFromCookie(e, t = $5582cf41b70f685b$var$s) {\n        const i = $5582cf41b70f685b$export$2314e25186e9360(e || \"\")[t] || \"\";\n        let n = {};\n        try {\n            n = JSON.parse(i), (\"object\" != typeof n || Array.isArray(n)) && (n = {});\n        } catch (e) {}\n        this.save(n.token || \"\", n.model || null);\n    }\n    exportToCookie(e, t = $5582cf41b70f685b$var$s) {\n        const i = {\n            secure: !0,\n            sameSite: !0,\n            httpOnly: !0,\n            path: \"/\"\n        }, n = $5582cf41b70f685b$export$26ddc56bc995240a(this.token);\n        i.expires = n?.exp ? new Date(1e3 * n.exp) : new Date(\"1970-01-01\"), e = Object.assign({}, i, e);\n        const r = {\n            token: this.token,\n            model: this.model ? JSON.parse(JSON.stringify(this.model)) : null\n        };\n        let o = $5582cf41b70f685b$export$879d2f108927fb90(t, JSON.stringify(r), e);\n        const a = \"undefined\" != typeof Blob ? new Blob([\n            o\n        ]).size : o.length;\n        if (r.model && a > 4096) {\n            r.model = {\n                id: r?.model?.id,\n                email: r?.model?.email\n            };\n            const s = [\n                \"collectionId\",\n                \"username\",\n                \"verified\"\n            ];\n            for(const e in this.model)s.includes(e) && (r.model[e] = this.model[e]);\n            o = $5582cf41b70f685b$export$879d2f108927fb90(t, JSON.stringify(r), e);\n        }\n        return o;\n    }\n    onChange(e, t = !1) {\n        return this._onChangeCallbacks.push(e), t && e(this.token, this.model), ()=>{\n            for(let t = this._onChangeCallbacks.length - 1; t >= 0; t--)if (this._onChangeCallbacks[t] == e) return delete this._onChangeCallbacks[t], void this._onChangeCallbacks.splice(t, 1);\n        };\n    }\n    triggerChange() {\n        for (const e of this._onChangeCallbacks)e && e(this.token, this.model);\n    }\n}\nclass $5582cf41b70f685b$export$6439a4b85bcd7f5d extends $5582cf41b70f685b$export$68a044b9d3f6e888 {\n    constructor(e = \"pocketbase_auth\"){\n        super(), this.storageFallback = {}, this.storageKey = e, this._bindStorageEvent();\n    }\n    get token() {\n        return (this._storageGet(this.storageKey) || {}).token || \"\";\n    }\n    get model() {\n        return (this._storageGet(this.storageKey) || {}).model || null;\n    }\n    save(e, t) {\n        this._storageSet(this.storageKey, {\n            token: e,\n            model: t\n        }), super.save(e, t);\n    }\n    clear() {\n        this._storageRemove(this.storageKey), super.clear();\n    }\n    _storageGet(e) {\n        if (\"undefined\" != typeof window && window?.localStorage) {\n            const t = window.localStorage.getItem(e) || \"\";\n            try {\n                return JSON.parse(t);\n            } catch (e) {\n                return t;\n            }\n        }\n        return this.storageFallback[e];\n    }\n    _storageSet(e, t) {\n        if (\"undefined\" != typeof window && window?.localStorage) {\n            let s = t;\n            \"string\" != typeof t && (s = JSON.stringify(t)), window.localStorage.setItem(e, s);\n        } else this.storageFallback[e] = t;\n    }\n    _storageRemove(e) {\n        \"undefined\" != typeof window && window?.localStorage && window.localStorage?.removeItem(e), delete this.storageFallback[e];\n    }\n    _bindStorageEvent() {\n        \"undefined\" != typeof window && window?.localStorage && window.addEventListener && window.addEventListener(\"storage\", (e)=>{\n            if (e.key != this.storageKey) return;\n            const t = this._storageGet(this.storageKey) || {};\n            super.save(t.token || \"\", t.model || null);\n        });\n    }\n}\nclass $5582cf41b70f685b$var$BaseService {\n    constructor(e){\n        this.client = e;\n    }\n}\nclass $5582cf41b70f685b$var$SettingsService extends $5582cf41b70f685b$var$BaseService {\n    async getAll(e) {\n        return e = Object.assign({\n            method: \"GET\"\n        }, e), this.client.send(\"/api/settings\", e);\n    }\n    async update(e, t) {\n        return t = Object.assign({\n            method: \"PATCH\",\n            body: e\n        }, t), this.client.send(\"/api/settings\", t);\n    }\n    async testS3(e = \"storage\", t) {\n        return t = Object.assign({\n            method: \"POST\",\n            body: {\n                filesystem: e\n            }\n        }, t), this.client.send(\"/api/settings/test/s3\", t).then(()=>!0);\n    }\n    async testEmail(e, t, s) {\n        return s = Object.assign({\n            method: \"POST\",\n            body: {\n                email: e,\n                template: t\n            }\n        }, s), this.client.send(\"/api/settings/test/email\", s).then(()=>!0);\n    }\n    async generateAppleClientSecret(e, t, s, i, n, r) {\n        return r = Object.assign({\n            method: \"POST\",\n            body: {\n                clientId: e,\n                teamId: t,\n                keyId: s,\n                privateKey: i,\n                duration: n\n            }\n        }, r), this.client.send(\"/api/settings/apple/generate-client-secret\", r);\n    }\n}\nclass $5582cf41b70f685b$export$d8ebe4a1f8b281ca extends $5582cf41b70f685b$var$BaseService {\n    decode(e) {\n        return e;\n    }\n    async getFullList(e, t) {\n        if (\"number\" == typeof e) return this._getFullList(e, t);\n        let s = 500;\n        return (t = Object.assign({}, e, t)).batch && (s = t.batch, delete t.batch), this._getFullList(s, t);\n    }\n    async getList(e = 1, t = 30, s) {\n        return (s = Object.assign({\n            method: \"GET\"\n        }, s)).query = Object.assign({\n            page: e,\n            perPage: t\n        }, s.query), this.client.send(this.baseCrudPath, s).then((e)=>(e.items = e.items?.map((e)=>this.decode(e)) || [], e));\n    }\n    async getFirstListItem(e, t) {\n        return (t = Object.assign({\n            requestKey: \"one_by_filter_\" + this.baseCrudPath + \"_\" + e\n        }, t)).query = Object.assign({\n            filter: e,\n            skipTotal: 1\n        }, t.query), this.getList(1, 1, t).then((e)=>{\n            if (!e?.items?.length) throw new $5582cf41b70f685b$export$dcaf143e197b2cd2({\n                status: 404,\n                response: {\n                    code: 404,\n                    message: \"The requested resource wasn't found.\",\n                    data: {}\n                }\n            });\n            return e.items[0];\n        });\n    }\n    async getOne(e, t) {\n        if (!e) throw new $5582cf41b70f685b$export$dcaf143e197b2cd2({\n            url: this.client.buildUrl(this.baseCrudPath + \"/\"),\n            status: 404,\n            response: {\n                code: 404,\n                message: \"Missing required record id.\",\n                data: {}\n            }\n        });\n        return t = Object.assign({\n            method: \"GET\"\n        }, t), this.client.send(this.baseCrudPath + \"/\" + encodeURIComponent(e), t).then((e)=>this.decode(e));\n    }\n    async create(e, t) {\n        return t = Object.assign({\n            method: \"POST\",\n            body: e\n        }, t), this.client.send(this.baseCrudPath, t).then((e)=>this.decode(e));\n    }\n    async update(e, t, s) {\n        return s = Object.assign({\n            method: \"PATCH\",\n            body: t\n        }, s), this.client.send(this.baseCrudPath + \"/\" + encodeURIComponent(e), s).then((e)=>this.decode(e));\n    }\n    async delete(e, t) {\n        return t = Object.assign({\n            method: \"DELETE\"\n        }, t), this.client.send(this.baseCrudPath + \"/\" + encodeURIComponent(e), t).then(()=>!0);\n    }\n    _getFullList(e = 500, t) {\n        (t = t || {}).query = Object.assign({\n            skipTotal: 1\n        }, t.query);\n        let s = [], request = async (i)=>this.getList(i, e || 500, t).then((e)=>{\n                const t = e.items;\n                return s = s.concat(t), t.length == e.perPage ? request(i + 1) : s;\n            });\n        return request(1);\n    }\n}\nfunction $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(e, t, s, i) {\n    const n = void 0 !== i;\n    return n || void 0 !== s ? n ? (console.warn(e), t.body = Object.assign({}, t.body, s), t.query = Object.assign({}, t.query, i), t) : Object.assign(t, s) : t;\n}\nfunction $5582cf41b70f685b$var$resetAutoRefresh(e) {\n    e._resetAutoRefresh?.();\n}\nclass $5582cf41b70f685b$export$33af9b5749be502a extends $5582cf41b70f685b$export$d8ebe4a1f8b281ca {\n    get baseCrudPath() {\n        return \"/api/admins\";\n    }\n    async update(e, t, s) {\n        return super.update(e, t, s).then((e)=>(this.client.authStore.model?.id === e.id && void 0 === this.client.authStore.model?.collectionId && this.client.authStore.save(this.client.authStore.token, e), e));\n    }\n    async delete(e, t) {\n        return super.delete(e, t).then((t)=>(t && this.client.authStore.model?.id === e && void 0 === this.client.authStore.model?.collectionId && this.client.authStore.clear(), t));\n    }\n    authResponse(e) {\n        const t = this.decode(e?.admin || {});\n        return e?.token && e?.admin && this.client.authStore.save(e.token, t), Object.assign({}, e, {\n            token: e?.token || \"\",\n            admin: t\n        });\n    }\n    async authWithPassword(e, t, s, i) {\n        let n = {\n            method: \"POST\",\n            body: {\n                identity: e,\n                password: t\n            }\n        };\n        n = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of authWithPassword(email, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(email, pass, options?).\", n, s, i);\n        const r = n.autoRefreshThreshold;\n        delete n.autoRefreshThreshold, n.autoRefresh || $5582cf41b70f685b$var$resetAutoRefresh(this.client);\n        let o = await this.client.send(this.baseCrudPath + \"/auth-with-password\", n);\n        return o = this.authResponse(o), r && function registerAutoRefresh(e, t, s, i) {\n            $5582cf41b70f685b$var$resetAutoRefresh(e);\n            const n = e.beforeSend, r = e.authStore.model, o = e.authStore.onChange((t, s)=>{\n                (!t || s?.id != r?.id || (s?.collectionId || r?.collectionId) && s?.collectionId != r?.collectionId) && $5582cf41b70f685b$var$resetAutoRefresh(e);\n            });\n            e._resetAutoRefresh = function() {\n                o(), e.beforeSend = n, delete e._resetAutoRefresh;\n            }, e.beforeSend = async (r, o)=>{\n                const a = e.authStore.token;\n                if (o.query?.autoRefresh) return n ? n(r, o) : {\n                    url: r,\n                    sendOptions: o\n                };\n                let c = e.authStore.isValid;\n                if (c && $5582cf41b70f685b$export$b007d77a962aa175(e.authStore.token, t)) try {\n                    await s();\n                } catch (e) {\n                    c = !1;\n                }\n                c || await i();\n                const l = o.headers || {};\n                for(let t in l)if (\"authorization\" == t.toLowerCase() && a == l[t] && e.authStore.token) {\n                    l[t] = e.authStore.token;\n                    break;\n                }\n                return o.headers = l, n ? n(r, o) : {\n                    url: r,\n                    sendOptions: o\n                };\n            };\n        }(this.client, r, ()=>this.authRefresh({\n                autoRefresh: !0\n            }), ()=>this.authWithPassword(e, t, Object.assign({\n                autoRefresh: !0\n            }, n))), o;\n    }\n    async authRefresh(e, t) {\n        let s = {\n            method: \"POST\"\n        };\n        return s = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\", s, e, t), this.client.send(this.baseCrudPath + \"/auth-refresh\", s).then(this.authResponse.bind(this));\n    }\n    async requestPasswordReset(e, t, s) {\n        let i = {\n            method: \"POST\",\n            body: {\n                email: e\n            }\n        };\n        return i = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\", i, t, s), this.client.send(this.baseCrudPath + \"/request-password-reset\", i).then(()=>!0);\n    }\n    async confirmPasswordReset(e, t, s, i, n) {\n        let r = {\n            method: \"POST\",\n            body: {\n                token: e,\n                password: t,\n                passwordConfirm: s\n            }\n        };\n        return r = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of confirmPasswordReset(resetToken, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(resetToken, password, passwordConfirm, options?).\", r, i, n), this.client.send(this.baseCrudPath + \"/confirm-password-reset\", r).then(()=>!0);\n    }\n}\nconst $5582cf41b70f685b$var$i = [\n    \"requestKey\",\n    \"$cancelKey\",\n    \"$autoCancel\",\n    \"fetch\",\n    \"headers\",\n    \"body\",\n    \"query\",\n    \"params\",\n    \"cache\",\n    \"credentials\",\n    \"headers\",\n    \"integrity\",\n    \"keepalive\",\n    \"method\",\n    \"mode\",\n    \"redirect\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"signal\",\n    \"window\"\n];\nfunction $5582cf41b70f685b$export$d4eab50bd87f5014(e) {\n    if (e) {\n        e.query = e.query || {};\n        for(let t in e)$5582cf41b70f685b$var$i.includes(t) || (e.query[t] = e[t], delete e[t]);\n    }\n}\nclass $5582cf41b70f685b$export$94618cb2db738d0c extends $5582cf41b70f685b$var$BaseService {\n    constructor(){\n        super(...arguments), this.clientId = \"\", this.eventSource = null, this.subscriptions = {}, this.lastSentSubscriptions = [], this.maxConnectTimeout = 15e3, this.reconnectAttempts = 0, this.maxReconnectAttempts = 1 / 0, this.predefinedReconnectIntervals = [\n            200,\n            300,\n            500,\n            1e3,\n            1200,\n            1500,\n            2e3\n        ], this.pendingConnects = [];\n    }\n    get isConnected() {\n        return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\n    }\n    async subscribe(e, t, s) {\n        if (!e) throw new Error(\"topic must be set.\");\n        let i = e;\n        if (s) {\n            $5582cf41b70f685b$export$d4eab50bd87f5014(s);\n            const e = \"options=\" + encodeURIComponent(JSON.stringify({\n                query: s.query,\n                headers: s.headers\n            }));\n            i += (i.includes(\"?\") ? \"&\" : \"?\") + e;\n        }\n        const listener = function(e) {\n            const s = e;\n            let i;\n            try {\n                i = JSON.parse(s?.data);\n            } catch  {}\n            t(i || {});\n        };\n        return this.subscriptions[i] || (this.subscriptions[i] = []), this.subscriptions[i].push(listener), this.isConnected ? 1 === this.subscriptions[i].length ? await this.submitSubscriptions() : this.eventSource?.addEventListener(i, listener) : await this.connect(), async ()=>this.unsubscribeByTopicAndListener(e, listener);\n    }\n    async unsubscribe(e) {\n        let t = !1;\n        if (e) {\n            const s = this.getSubscriptionsByTopic(e);\n            for(let e in s)if (this.hasSubscriptionListeners(e)) {\n                for (let t of this.subscriptions[e])this.eventSource?.removeEventListener(e, t);\n                delete this.subscriptions[e], t || (t = !0);\n            }\n        } else this.subscriptions = {};\n        this.hasSubscriptionListeners() ? t && await this.submitSubscriptions() : this.disconnect();\n    }\n    async unsubscribeByPrefix(e) {\n        let t = !1;\n        for(let s in this.subscriptions)if ((s + \"?\").startsWith(e)) {\n            t = !0;\n            for (let e of this.subscriptions[s])this.eventSource?.removeEventListener(s, e);\n            delete this.subscriptions[s];\n        }\n        t && (this.hasSubscriptionListeners() ? await this.submitSubscriptions() : this.disconnect());\n    }\n    async unsubscribeByTopicAndListener(e, t) {\n        let s = !1;\n        const i = this.getSubscriptionsByTopic(e);\n        for(let e in i){\n            if (!Array.isArray(this.subscriptions[e]) || !this.subscriptions[e].length) continue;\n            let i = !1;\n            for(let s = this.subscriptions[e].length - 1; s >= 0; s--)this.subscriptions[e][s] === t && (i = !0, delete this.subscriptions[e][s], this.subscriptions[e].splice(s, 1), this.eventSource?.removeEventListener(e, t));\n            i && (this.subscriptions[e].length || delete this.subscriptions[e], s || this.hasSubscriptionListeners(e) || (s = !0));\n        }\n        this.hasSubscriptionListeners() ? s && await this.submitSubscriptions() : this.disconnect();\n    }\n    hasSubscriptionListeners(e) {\n        if (this.subscriptions = this.subscriptions || {}, e) return !!this.subscriptions[e]?.length;\n        for(let e in this.subscriptions)if (this.subscriptions[e]?.length) return !0;\n        return !1;\n    }\n    async submitSubscriptions() {\n        if (this.clientId) return this.addAllSubscriptionListeners(), this.lastSentSubscriptions = this.getNonEmptySubscriptionKeys(), this.client.send(\"/api/realtime\", {\n            method: \"POST\",\n            body: {\n                clientId: this.clientId,\n                subscriptions: this.lastSentSubscriptions\n            },\n            requestKey: this.getSubscriptionsCancelKey()\n        }).catch((e)=>{\n            if (!e?.isAbort) throw e;\n        });\n    }\n    getSubscriptionsCancelKey() {\n        return \"realtime_\" + this.clientId;\n    }\n    getSubscriptionsByTopic(e) {\n        const t = {};\n        e = e.includes(\"?\") ? e : e + \"?\";\n        for(let s in this.subscriptions)(s + \"?\").startsWith(e) && (t[s] = this.subscriptions[s]);\n        return t;\n    }\n    getNonEmptySubscriptionKeys() {\n        const e = [];\n        for(let t in this.subscriptions)this.subscriptions[t].length && e.push(t);\n        return e;\n    }\n    addAllSubscriptionListeners() {\n        if (this.eventSource) {\n            this.removeAllSubscriptionListeners();\n            for(let e in this.subscriptions)for (let t of this.subscriptions[e])this.eventSource.addEventListener(e, t);\n        }\n    }\n    removeAllSubscriptionListeners() {\n        if (this.eventSource) for(let e in this.subscriptions)for (let t of this.subscriptions[e])this.eventSource.removeEventListener(e, t);\n    }\n    async connect() {\n        if (!(this.reconnectAttempts > 0)) return new Promise((e, t)=>{\n            this.pendingConnects.push({\n                resolve: e,\n                reject: t\n            }), this.pendingConnects.length > 1 || this.initConnect();\n        });\n    }\n    initConnect() {\n        this.disconnect(!0), clearTimeout(this.connectTimeoutId), this.connectTimeoutId = setTimeout(()=>{\n            this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\n        }, this.maxConnectTimeout), this.eventSource = new EventSource(this.client.buildUrl(\"/api/realtime\")), this.eventSource.onerror = (e)=>{\n            this.connectErrorHandler(new Error(\"Failed to establish realtime connection.\"));\n        }, this.eventSource.addEventListener(\"PB_CONNECT\", (e)=>{\n            const t = e;\n            this.clientId = t?.lastEventId, this.submitSubscriptions().then(async ()=>{\n                let e = 3;\n                for(; this.hasUnsentSubscriptions() && e > 0;)e--, await this.submitSubscriptions();\n            }).then(()=>{\n                for (let e of this.pendingConnects)e.resolve();\n                this.pendingConnects = [], this.reconnectAttempts = 0, clearTimeout(this.reconnectTimeoutId), clearTimeout(this.connectTimeoutId);\n                const t = this.getSubscriptionsByTopic(\"PB_CONNECT\");\n                for(let s in t)for (let i of t[s])i(e);\n            }).catch((e)=>{\n                this.clientId = \"\", this.connectErrorHandler(e);\n            });\n        });\n    }\n    hasUnsentSubscriptions() {\n        const e = this.getNonEmptySubscriptionKeys();\n        if (e.length != this.lastSentSubscriptions.length) return !0;\n        for (const t of e)if (!this.lastSentSubscriptions.includes(t)) return !0;\n        return !1;\n    }\n    connectErrorHandler(e) {\n        if (clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), !this.clientId && !this.reconnectAttempts || this.reconnectAttempts > this.maxReconnectAttempts) {\n            for (let t of this.pendingConnects)t.reject(new $5582cf41b70f685b$export$dcaf143e197b2cd2(e));\n            return this.pendingConnects = [], void this.disconnect();\n        }\n        this.disconnect(!0);\n        const t = this.predefinedReconnectIntervals[this.reconnectAttempts] || this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];\n        this.reconnectAttempts++, this.reconnectTimeoutId = setTimeout(()=>{\n            this.initConnect();\n        }, t);\n    }\n    disconnect(e = !1) {\n        if (clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), this.removeAllSubscriptionListeners(), this.client.cancelRequest(this.getSubscriptionsCancelKey()), this.eventSource?.close(), this.eventSource = null, this.clientId = \"\", !e) {\n            this.reconnectAttempts = 0;\n            for (let e of this.pendingConnects)e.resolve();\n            this.pendingConnects = [];\n        }\n    }\n}\nclass $5582cf41b70f685b$export$1b7d28e1ebf40328 extends $5582cf41b70f685b$export$d8ebe4a1f8b281ca {\n    constructor(e, t){\n        super(e), this.collectionIdOrName = t;\n    }\n    get baseCrudPath() {\n        return this.baseCollectionPath + \"/records\";\n    }\n    get baseCollectionPath() {\n        return \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName);\n    }\n    async subscribe(e, t, s) {\n        if (!e) throw new Error(\"Missing topic.\");\n        if (!t) throw new Error(\"Missing subscription callback.\");\n        return this.client.realtime.subscribe(this.collectionIdOrName + \"/\" + e, t, s);\n    }\n    async unsubscribe(e) {\n        return e ? this.client.realtime.unsubscribe(this.collectionIdOrName + \"/\" + e) : this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n    }\n    async getFullList(e, t) {\n        if (\"number\" == typeof e) return super.getFullList(e, t);\n        const s = Object.assign({}, e, t);\n        return super.getFullList(s);\n    }\n    async getList(e = 1, t = 30, s) {\n        return super.getList(e, t, s);\n    }\n    async getFirstListItem(e, t) {\n        return super.getFirstListItem(e, t);\n    }\n    async getOne(e, t) {\n        return super.getOne(e, t);\n    }\n    async create(e, t) {\n        return super.create(e, t);\n    }\n    async update(e, t, s) {\n        return super.update(e, t, s).then((e)=>(this.client.authStore.model?.id !== e?.id || this.client.authStore.model?.collectionId !== this.collectionIdOrName && this.client.authStore.model?.collectionName !== this.collectionIdOrName || this.client.authStore.save(this.client.authStore.token, e), e));\n    }\n    async delete(e, t) {\n        return super.delete(e, t).then((t)=>(!t || this.client.authStore.model?.id !== e || this.client.authStore.model?.collectionId !== this.collectionIdOrName && this.client.authStore.model?.collectionName !== this.collectionIdOrName || this.client.authStore.clear(), t));\n    }\n    authResponse(e) {\n        const t = this.decode(e?.record || {});\n        return this.client.authStore.save(e?.token, t), Object.assign({}, e, {\n            token: e?.token || \"\",\n            record: t\n        });\n    }\n    async listAuthMethods(e) {\n        return e = Object.assign({\n            method: \"GET\"\n        }, e), this.client.send(this.baseCollectionPath + \"/auth-methods\", e).then((e)=>Object.assign({}, e, {\n                usernamePassword: !!e?.usernamePassword,\n                emailPassword: !!e?.emailPassword,\n                authProviders: Array.isArray(e?.authProviders) ? e?.authProviders : []\n            }));\n    }\n    async authWithPassword(e, t, s, i) {\n        let n = {\n            method: \"POST\",\n            body: {\n                identity: e,\n                password: t\n            }\n        };\n        return n = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of authWithPassword(usernameOrEmail, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(usernameOrEmail, pass, options?).\", n, s, i), this.client.send(this.baseCollectionPath + \"/auth-with-password\", n).then((e)=>this.authResponse(e));\n    }\n    async authWithOAuth2Code(e, t, s, i, n, r, o) {\n        let a = {\n            method: \"POST\",\n            body: {\n                provider: e,\n                code: t,\n                codeVerifier: s,\n                redirectUrl: i,\n                createData: n\n            }\n        };\n        return a = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, options?).\", a, r, o), this.client.send(this.baseCollectionPath + \"/auth-with-oauth2\", a).then((e)=>this.authResponse(e));\n    }\n    async authWithOAuth2(...e) {\n        if (e.length > 1 || \"string\" == typeof e?.[0]) return console.warn(\"PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\"), this.authWithOAuth2Code(e?.[0] || \"\", e?.[1] || \"\", e?.[2] || \"\", e?.[3] || \"\", e?.[4] || {}, e?.[5] || {}, e?.[6] || {});\n        const t = e?.[0] || {}, s = (await this.listAuthMethods()).authProviders.find((e)=>e.name === t.provider);\n        if (!s) throw new $5582cf41b70f685b$export$dcaf143e197b2cd2(new Error(`Missing or invalid provider \"${t.provider}\".`));\n        const i = this.client.buildUrl(\"/api/oauth2-redirect\"), n = new $5582cf41b70f685b$export$94618cb2db738d0c(this.client);\n        let r = null;\n        function cleanup() {\n            r?.close(), n.unsubscribe();\n        }\n        return t.urlCallback || (r = $5582cf41b70f685b$var$openBrowserPopup(void 0)), new Promise(async (e, o)=>{\n            try {\n                await n.subscribe(\"@oauth2\", async (r)=>{\n                    const a = n.clientId;\n                    try {\n                        if (!r.state || a !== r.state) throw new Error(\"State parameters don't match.\");\n                        if (r.error || !r.code) throw new Error(\"OAuth2 redirect error or missing code: \" + r.error);\n                        const n = Object.assign({}, t);\n                        delete n.provider, delete n.scopes, delete n.createData, delete n.urlCallback;\n                        const o = await this.authWithOAuth2Code(s.name, r.code, s.codeVerifier, i, t.createData, n);\n                        e(o);\n                    } catch (e) {\n                        o(new $5582cf41b70f685b$export$dcaf143e197b2cd2(e));\n                    }\n                    cleanup();\n                });\n                const a = {\n                    state: n.clientId\n                };\n                t.scopes?.length && (a.scope = t.scopes.join(\" \"));\n                const c = this._replaceQueryParams(s.authUrl + i, a);\n                let l = t.urlCallback || function(e) {\n                    r ? r.location.href = e : r = $5582cf41b70f685b$var$openBrowserPopup(e);\n                };\n                await l(c);\n            } catch (e) {\n                cleanup(), o(new $5582cf41b70f685b$export$dcaf143e197b2cd2(e));\n            }\n        });\n    }\n    async authRefresh(e, t) {\n        let s = {\n            method: \"POST\"\n        };\n        return s = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\", s, e, t), this.client.send(this.baseCollectionPath + \"/auth-refresh\", s).then((e)=>this.authResponse(e));\n    }\n    async requestPasswordReset(e, t, s) {\n        let i = {\n            method: \"POST\",\n            body: {\n                email: e\n            }\n        };\n        return i = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\", i, t, s), this.client.send(this.baseCollectionPath + \"/request-password-reset\", i).then(()=>!0);\n    }\n    async confirmPasswordReset(e, t, s, i, n) {\n        let r = {\n            method: \"POST\",\n            body: {\n                token: e,\n                password: t,\n                passwordConfirm: s\n            }\n        };\n        return r = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).\", r, i, n), this.client.send(this.baseCollectionPath + \"/confirm-password-reset\", r).then(()=>!0);\n    }\n    async requestVerification(e, t, s) {\n        let i = {\n            method: \"POST\",\n            body: {\n                email: e\n            }\n        };\n        return i = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).\", i, t, s), this.client.send(this.baseCollectionPath + \"/request-verification\", i).then(()=>!0);\n    }\n    async confirmVerification(e, t, s) {\n        let i = {\n            method: \"POST\",\n            body: {\n                token: e\n            }\n        };\n        return i = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).\", i, t, s), this.client.send(this.baseCollectionPath + \"/confirm-verification\", i).then(()=>{\n            const t = $5582cf41b70f685b$export$26ddc56bc995240a(e), s = this.client.authStore.model;\n            return s && !s.verified && s.id === t.id && s.collectionId === t.collectionId && (s.verified = !0, this.client.authStore.save(this.client.authStore.token, s)), !0;\n        });\n    }\n    async requestEmailChange(e, t, s) {\n        let i = {\n            method: \"POST\",\n            body: {\n                newEmail: e\n            }\n        };\n        return i = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).\", i, t, s), this.client.send(this.baseCollectionPath + \"/request-email-change\", i).then(()=>!0);\n    }\n    async confirmEmailChange(e, t, s, i) {\n        let n = {\n            method: \"POST\",\n            body: {\n                token: e,\n                password: t\n            }\n        };\n        return n = $5582cf41b70f685b$var$normalizeLegacyOptionsArgs(\"This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).\", n, s, i), this.client.send(this.baseCollectionPath + \"/confirm-email-change\", n).then(()=>{\n            const t = $5582cf41b70f685b$export$26ddc56bc995240a(e), s = this.client.authStore.model;\n            return s && s.id === t.id && s.collectionId === t.collectionId && this.client.authStore.clear(), !0;\n        });\n    }\n    async listExternalAuths(e, t) {\n        return t = Object.assign({\n            method: \"GET\"\n        }, t), this.client.send(this.baseCrudPath + \"/\" + encodeURIComponent(e) + \"/external-auths\", t);\n    }\n    async unlinkExternalAuth(e, t, s) {\n        return s = Object.assign({\n            method: \"DELETE\"\n        }, s), this.client.send(this.baseCrudPath + \"/\" + encodeURIComponent(e) + \"/external-auths/\" + encodeURIComponent(t), s).then(()=>!0);\n    }\n    _replaceQueryParams(e, t = {}) {\n        let s = e, i = \"\";\n        e.indexOf(\"?\") >= 0 && (s = e.substring(0, e.indexOf(\"?\")), i = e.substring(e.indexOf(\"?\") + 1));\n        const n = {}, r = i.split(\"&\");\n        for (const e of r){\n            if (\"\" == e) continue;\n            const t = e.split(\"=\");\n            n[decodeURIComponent(t[0].replace(/\\+/g, \" \"))] = decodeURIComponent((t[1] || \"\").replace(/\\+/g, \" \"));\n        }\n        for(let e in t)t.hasOwnProperty(e) && (null == t[e] ? delete n[e] : n[e] = t[e]);\n        i = \"\";\n        for(let e in n)n.hasOwnProperty(e) && (\"\" != i && (i += \"&\"), i += encodeURIComponent(e.replace(/%20/g, \"+\")) + \"=\" + encodeURIComponent(n[e].replace(/%20/g, \"+\")));\n        return \"\" != i ? s + \"?\" + i : s;\n    }\n}\nfunction $5582cf41b70f685b$var$openBrowserPopup(e) {\n    if (\"undefined\" == typeof window || !window?.open) throw new $5582cf41b70f685b$export$dcaf143e197b2cd2(new Error(\"Not in a browser context - please pass a custom urlCallback function.\"));\n    let t = 1024, s = 768, i = window.innerWidth, n = window.innerHeight;\n    t = t > i ? i : t, s = s > n ? n : s;\n    let r = i / 2 - t / 2, o = n / 2 - s / 2;\n    return window.open(e, \"popup_window\", \"width=\" + t + \",height=\" + s + \",top=\" + o + \",left=\" + r + \",resizable,menubar=no\");\n}\nclass $5582cf41b70f685b$export$133889e600929275 extends $5582cf41b70f685b$export$d8ebe4a1f8b281ca {\n    get baseCrudPath() {\n        return \"/api/collections\";\n    }\n    async import(e, t = !1, s) {\n        return s = Object.assign({\n            method: \"PUT\",\n            body: {\n                collections: e,\n                deleteMissing: t\n            }\n        }, s), this.client.send(this.baseCrudPath + \"/import\", s).then(()=>!0);\n    }\n}\nclass $5582cf41b70f685b$export$e2c5c1c0df6e287f extends $5582cf41b70f685b$var$BaseService {\n    async getList(e = 1, t = 30, s) {\n        return (s = Object.assign({\n            method: \"GET\"\n        }, s)).query = Object.assign({\n            page: e,\n            perPage: t\n        }, s.query), this.client.send(\"/api/logs\", s);\n    }\n    async getOne(e, t) {\n        if (!e) throw new $5582cf41b70f685b$export$dcaf143e197b2cd2({\n            url: this.client.buildUrl(\"/api/logs/\"),\n            status: 404,\n            response: {\n                code: 404,\n                message: \"Missing required log id.\",\n                data: {}\n            }\n        });\n        return t = Object.assign({\n            method: \"GET\"\n        }, t), this.client.send(\"/api/logs/\" + encodeURIComponent(e), t);\n    }\n    async getStats(e) {\n        return e = Object.assign({\n            method: \"GET\"\n        }, e), this.client.send(\"/api/logs/stats\", e);\n    }\n}\nclass $5582cf41b70f685b$var$HealthService extends $5582cf41b70f685b$var$BaseService {\n    async check(e) {\n        return e = Object.assign({\n            method: \"GET\"\n        }, e), this.client.send(\"/api/health\", e);\n    }\n}\nclass $5582cf41b70f685b$var$FileService extends $5582cf41b70f685b$var$BaseService {\n    getUrl(e, t, s = {}) {\n        if (!t || !e?.id || !e?.collectionId && !e?.collectionName) return \"\";\n        const i = [];\n        i.push(\"api\"), i.push(\"files\"), i.push(encodeURIComponent(e.collectionId || e.collectionName)), i.push(encodeURIComponent(e.id)), i.push(encodeURIComponent(t));\n        let n = this.client.buildUrl(i.join(\"/\"));\n        if (Object.keys(s).length) {\n            !1 === s.download && delete s.download;\n            const e = new URLSearchParams(s);\n            n += (n.includes(\"?\") ? \"&\" : \"?\") + e;\n        }\n        return n;\n    }\n    async getToken(e) {\n        return e = Object.assign({\n            method: \"POST\"\n        }, e), this.client.send(\"/api/files/token\", e).then((e)=>e?.token || \"\");\n    }\n}\nclass $5582cf41b70f685b$var$BackupService extends $5582cf41b70f685b$var$BaseService {\n    async getFullList(e) {\n        return e = Object.assign({\n            method: \"GET\"\n        }, e), this.client.send(\"/api/backups\", e);\n    }\n    async create(e, t) {\n        return t = Object.assign({\n            method: \"POST\",\n            body: {\n                name: e\n            }\n        }, t), this.client.send(\"/api/backups\", t).then(()=>!0);\n    }\n    async upload(e, t) {\n        return t = Object.assign({\n            method: \"POST\",\n            body: e\n        }, t), this.client.send(\"/api/backups/upload\", t).then(()=>!0);\n    }\n    async delete(e, t) {\n        return t = Object.assign({\n            method: \"DELETE\"\n        }, t), this.client.send(`/api/backups/${encodeURIComponent(e)}`, t).then(()=>!0);\n    }\n    async restore(e, t) {\n        return t = Object.assign({\n            method: \"POST\"\n        }, t), this.client.send(`/api/backups/${encodeURIComponent(e)}/restore`, t).then(()=>!0);\n    }\n    getDownloadUrl(e, t) {\n        return this.client.buildUrl(`/api/backups/${encodeURIComponent(t)}?token=${encodeURIComponent(e)}`);\n    }\n}\nclass $5582cf41b70f685b$export$2e2bcd8739ae039 {\n    constructor(e = \"/\", t, s = \"en-US\"){\n        this.cancelControllers = {}, this.recordServices = {}, this.enableAutoCancellation = !0, this.baseUrl = e, this.lang = s, this.authStore = t || new $5582cf41b70f685b$export$6439a4b85bcd7f5d, this.admins = new $5582cf41b70f685b$export$33af9b5749be502a(this), this.collections = new $5582cf41b70f685b$export$133889e600929275(this), this.files = new $5582cf41b70f685b$var$FileService(this), this.logs = new $5582cf41b70f685b$export$e2c5c1c0df6e287f(this), this.settings = new $5582cf41b70f685b$var$SettingsService(this), this.realtime = new $5582cf41b70f685b$export$94618cb2db738d0c(this), this.health = new $5582cf41b70f685b$var$HealthService(this), this.backups = new $5582cf41b70f685b$var$BackupService(this);\n    }\n    collection(e) {\n        return this.recordServices[e] || (this.recordServices[e] = new $5582cf41b70f685b$export$1b7d28e1ebf40328(this, e)), this.recordServices[e];\n    }\n    autoCancellation(e) {\n        return this.enableAutoCancellation = !!e, this;\n    }\n    cancelRequest(e) {\n        return this.cancelControllers[e] && (this.cancelControllers[e].abort(), delete this.cancelControllers[e]), this;\n    }\n    cancelAllRequests() {\n        for(let e in this.cancelControllers)this.cancelControllers[e].abort();\n        return this.cancelControllers = {}, this;\n    }\n    filter(e, t) {\n        if (!t) return e;\n        for(let s in t){\n            let i = t[s];\n            switch(typeof i){\n                case \"boolean\":\n                case \"number\":\n                    i = \"\" + i;\n                    break;\n                case \"string\":\n                    i = \"'\" + i.replace(/'/g, \"\\\\'\") + \"'\";\n                    break;\n                default:\n                    i = null === i ? \"null\" : i instanceof Date ? \"'\" + i.toISOString().replace(\"T\", \" \") + \"'\" : \"'\" + JSON.stringify(i).replace(/'/g, \"\\\\'\") + \"'\";\n            }\n            e = e.replaceAll(\"{:\" + s + \"}\", i);\n        }\n        return e;\n    }\n    getFileUrl(e, t, s = {}) {\n        return this.files.getUrl(e, t, s);\n    }\n    buildUrl(e) {\n        let t = this.baseUrl;\n        return \"undefined\" == typeof window || !window.location || t.startsWith(\"https://\") || t.startsWith(\"http://\") || (t = window.location.origin?.endsWith(\"/\") ? window.location.origin.substring(0, window.location.origin.length - 1) : window.location.origin || \"\", this.baseUrl.startsWith(\"/\") || (t += window.location.pathname || \"/\", t += t.endsWith(\"/\") ? \"\" : \"/\"), t += this.baseUrl), e && (t += t.endsWith(\"/\") ? \"\" : \"/\", t += e.startsWith(\"/\") ? e.substring(1) : e), t;\n    }\n    async send(e, t) {\n        t = this.initSendOptions(e, t);\n        let s = this.buildUrl(e);\n        if (this.beforeSend) {\n            const e = Object.assign({}, await this.beforeSend(s, t));\n            void 0 !== e.url || void 0 !== e.options ? (s = e.url || s, t = e.options || t) : Object.keys(e).length && (t = e, console?.warn && console.warn(\"Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.\"));\n        }\n        if (void 0 !== t.query) {\n            const e = this.serializeQueryParams(t.query);\n            e && (s += (s.includes(\"?\") ? \"&\" : \"?\") + e), delete t.query;\n        }\n        \"application/json\" == this.getHeader(t.headers, \"Content-Type\") && t.body && \"string\" != typeof t.body && (t.body = JSON.stringify(t.body));\n        return (t.fetch || fetch)(s, t).then(async (e)=>{\n            let t = {};\n            try {\n                t = await e.json();\n            } catch (e) {}\n            if (this.afterSend && (t = await this.afterSend(e, t)), e.status >= 400) throw new $5582cf41b70f685b$export$dcaf143e197b2cd2({\n                url: e.url,\n                status: e.status,\n                data: t\n            });\n            return t;\n        }).catch((e)=>{\n            throw new $5582cf41b70f685b$export$dcaf143e197b2cd2(e);\n        });\n    }\n    initSendOptions(e, t) {\n        if ((t = Object.assign({\n            method: \"GET\"\n        }, t)).body = this.convertToFormDataIfNeeded(t.body), $5582cf41b70f685b$export$d4eab50bd87f5014(t), t.query = Object.assign({}, t.params, t.query), void 0 === t.requestKey && (!1 === t.$autoCancel || !1 === t.query.$autoCancel ? t.requestKey = null : (t.$cancelKey || t.query.$cancelKey) && (t.requestKey = t.$cancelKey || t.query.$cancelKey)), delete t.$autoCancel, delete t.query.$autoCancel, delete t.$cancelKey, delete t.query.$cancelKey, null !== this.getHeader(t.headers, \"Content-Type\") || this.isFormData(t.body) || (t.headers = Object.assign({}, t.headers, {\n            \"Content-Type\": \"application/json\"\n        })), null === this.getHeader(t.headers, \"Accept-Language\") && (t.headers = Object.assign({}, t.headers, {\n            \"Accept-Language\": this.lang\n        })), this.authStore.token && null === this.getHeader(t.headers, \"Authorization\") && (t.headers = Object.assign({}, t.headers, {\n            Authorization: this.authStore.token\n        })), this.enableAutoCancellation && null !== t.requestKey) {\n            const s = t.requestKey || (t.method || \"GET\") + e;\n            delete t.requestKey, this.cancelRequest(s);\n            const i = new AbortController;\n            this.cancelControllers[s] = i, t.signal = i.signal;\n        }\n        return t;\n    }\n    convertToFormDataIfNeeded(e) {\n        if (\"undefined\" == typeof FormData || void 0 === e || \"object\" != typeof e || null === e || this.isFormData(e) || !this.hasBlobField(e)) return e;\n        const t = new FormData;\n        for(const s in e){\n            const i = e[s];\n            if (\"object\" != typeof i || this.hasBlobField({\n                data: i\n            })) {\n                const e = Array.isArray(i) ? i : [\n                    i\n                ];\n                for (let i of e)t.append(s, i);\n            } else {\n                let e = {};\n                e[s] = i, t.append(\"@jsonPayload\", JSON.stringify(e));\n            }\n        }\n        return t;\n    }\n    hasBlobField(e) {\n        for(const t in e){\n            const s = Array.isArray(e[t]) ? e[t] : [\n                e[t]\n            ];\n            for (const e of s)if (\"undefined\" != typeof Blob && e instanceof Blob || \"undefined\" != typeof File && e instanceof File) return !0;\n        }\n        return !1;\n    }\n    getHeader(e, t) {\n        e = e || {}, t = t.toLowerCase();\n        for(let s in e)if (s.toLowerCase() == t) return e[s];\n        return null;\n    }\n    isFormData(e) {\n        return e && (\"FormData\" === e.constructor.name || \"undefined\" != typeof FormData && e instanceof FormData);\n    }\n    serializeQueryParams(e) {\n        const t = [];\n        for(const s in e){\n            if (null === e[s]) continue;\n            const i = e[s], n = encodeURIComponent(s);\n            if (Array.isArray(i)) for (const e of i)t.push(n + \"=\" + encodeURIComponent(e));\n            else i instanceof Date ? t.push(n + \"=\" + encodeURIComponent(i.toISOString())) : \"object\" == typeof i ? t.push(n + \"=\" + encodeURIComponent(JSON.stringify(i))) : t.push(n + \"=\" + encodeURIComponent(i));\n        }\n        return t.join(\"&\");\n    }\n}\nclass $5582cf41b70f685b$export$c94662ed41386ffd extends $5582cf41b70f685b$export$68a044b9d3f6e888 {\n    constructor(e){\n        super(), this.queue = [], this.saveFunc = e.save, this.clearFunc = e.clear, this._enqueue(()=>this._loadInitial(e.initial));\n    }\n    save(e, t) {\n        super.save(e, t);\n        let s = \"\";\n        try {\n            s = JSON.stringify({\n                token: e,\n                model: t\n            });\n        } catch (e) {\n            console.warn(\"AsyncAuthStore: failed to stringify the new state\");\n        }\n        this._enqueue(()=>this.saveFunc(s));\n    }\n    clear() {\n        super.clear(), this.clearFunc ? this._enqueue(()=>this.clearFunc()) : this._enqueue(()=>this.saveFunc(\"\"));\n    }\n    async _loadInitial(e) {\n        try {\n            if (e = await e) {\n                let t;\n                \"string\" == typeof e ? t = JSON.parse(e) || {} : \"object\" == typeof e && (t = e), this.save(t.token || \"\", t.model || null);\n            }\n        } catch (e) {}\n    }\n    _enqueue(e) {\n        this.queue.push(e), 1 == this.queue.length && this._dequeue();\n    }\n    _dequeue() {\n        this.queue.length && this.queue[0]().finally(()=>{\n            this.queue.shift(), this.queue.length && this._dequeue();\n        });\n    }\n}\n\n});\n\n\n\n//# sourceMappingURL=index.53236992.js.map\n","import view from './view';\n\nconst helper = (() => {\n  function buildPost(title, body, author, author_id) {\n    return {\n      title,\n      body,\n      author,\n      author_id,\n    };\n  }\n\n  function buildUser(name, username, password, passwordConfirm) {\n    return {\n      username,\n      emailVisibility: false,\n      password,\n      passwordConfirm,\n      name,\n      isAdmin: false,\n    };\n  }\n\n  function validateInput(input) {\n    const validity = input.validity;\n\n    // Validity Cases\n    if (validity.valid) return null;\n    if (validity.valueMissing) return 'Required';\n    if (validity.patternMismatch) {\n      if (input.name === 'name') return 'Please match format: John S';\n      if (input.name === 'username') return 'Should be lowercase, no spaces';\n    }\n    if (validity.tooShort) return 'Please use at least 5 characters';\n  }\n\n  function validateForm(form) {\n    const elements = form.elements;\n    const error = elements.passwordConfirm.previousElementSibling.children[0];\n\n    if (elements.password.value !== elements.passwordConfirm.value) {\n      console.log(error);\n      view.showError(error, 'Passwords do not match');\n      return false;\n    } else {\n      view.showError(error, '');\n    }\n\n    // Check form validity\n    return form.checkValidity();\n  }\n\n  return { buildPost, buildUser, validateInput, validateForm };\n})();\n\nexport default helper;\n","const view = (() => {\n  const buildPosts = (posts, currentUser) => {\n    // FUNCTION THE BUILDS POST IN UI\n    const postsContainer = document.getElementById('posts-container');\n\n    // Clear post in UI\n    clearPosts(postsContainer);\n\n    // Update UI to stay in sync with data\n    updateHeading(currentUser);\n    updateUI(currentUser);\n\n    for (let post of posts) {\n      const title = document.createElement('h2');\n      title.classList.add('post-title');\n      title.textContent = post.title;\n\n      const author = document.createElement('div');\n      author.classList.add('post-author');\n      author.textContent = post.author;\n\n      const date = document.createElement('div');\n      date.classList.add('post-date');\n      date.textContent = new Date(post.created).toDateString();\n\n      const byline = document.createElement('div');\n      byline.classList.add('post-byline');\n      byline.appendChild(author);\n      byline.appendChild(date);\n\n      // Render delete button is user is logged in, only renders on user's posts unless user is admin\n      if (\n        currentUser &&\n        (currentUser.id === post.author_id || currentUser.isAdmin)\n      ) {\n        const del = document.createElement('button');\n        del.classList.add('post-delete');\n        del.innerHTML = '<span>×</span>';\n        del.onclick = () => {\n          const deletionModal = document.getElementById('deletion-modal');\n          // set post_id data attribute to post id onclick. Used for post deletion\n          deletionModal.dataset.post_id = post.id;\n          openModal(deletionModal);\n        };\n        byline.appendChild(del);\n      }\n\n      const divider = document.createElement('div');\n      divider.classList.add('divider');\n\n      const body = document.createElement('div');\n      body.classList.add('post-body');\n      body.innerHTML = post.body;\n\n      const announcement = document.createElement('div');\n      announcement.classList.add('post');\n      announcement.dataset.author_id = post.author_id;\n      announcement.dataset.post_id = post.id;\n      announcement.appendChild(title);\n      announcement.appendChild(byline);\n      announcement.appendChild(divider);\n      announcement.appendChild(body);\n\n      postsContainer.appendChild(announcement);\n    }\n  };\n\n  const updateHeading = (currentUser) => {\n    const authHeading = document.getElementById('auth-heading');\n    const username = document.getElementById('current-username');\n    if (!currentUser) {\n      authHeading.style.display = 'none';\n      username.textContent = 'NO USER';\n      return;\n    }\n\n    authHeading.style.display = 'flex';\n    username.textContent = currentUser.name;\n    return;\n  };\n\n  const updateUI = (currentUser) => {\n    const button = document.getElementById('new-post-button');\n    if (!currentUser) {\n      button.textContent = 'Log In';\n    } else {\n      button.textContent = 'New Announcement';\n    }\n  };\n\n  const clearPosts = (parent) => {\n    while (parent.hasChildNodes()) {\n      parent.removeChild(parent.firstChild);\n    }\n  };\n\n  const openModal = (modal) => {\n    modal.showModal();\n  };\n\n  const closeModal = (modal) => {\n    modal.close();\n  };\n\n  const showError = (element, error) => {\n    element.textContent = error;\n  };\n\n  return { buildPosts, openModal, closeModal, showError };\n})();\n\nexport default view;\n","import PocketBase from 'pocketbase';\n\nconst url = 'https://mpls.pockethost.io/';\nconst pb = new PocketBase(url);\n\n// A MODULE TO HANDLE CALLS TO POCKETBASE BACKEND\nconst backend = (() => {\n  async function getPosts() {\n    try {\n      const records = await pb\n        .collection('posts')\n        .getFullList({ sort: '-created' });\n\n      return records;\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  async function pushPost(post) {\n    if (!backend.getCurrentUser()) return false;\n\n    try {\n      await pb.collection('posts').create(post);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  async function deletePost(id) {\n    if (!backend.getCurrentUser()) return false;\n\n    try {\n      await pb.collection('posts').delete(id);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  async function createUser(user) {\n    try {\n      // create user in backend\n      const record = await pb.collection('users').create(user);\n      return record;\n    } catch (error) {\n      // throw error\n      return error.data;\n    }\n  }\n\n  async function authUser(username, password) {\n    // Attempt to log in user.\n    // Return true if successful else return false\n    try {\n      const authData = await pb\n        .collection('users')\n        .authWithPassword(username, password);\n\n      return true;\n    } catch (error) {\n      console.log(error);\n      return false;\n    }\n  }\n\n  function getCurrentUser() {\n    // Check current user. Returns null if no user\n    return pb.authStore.model;\n  }\n\n  function logoutUser() {\n    return pb.authStore.clear();\n  }\n\n  return {\n    getPosts,\n    pushPost,\n    deletePost,\n    createUser,\n    authUser,\n    getCurrentUser,\n    logoutUser,\n  };\n})();\n\nexport default backend;\n","class ClientResponseError extends Error{constructor(e){super(\"ClientResponseError\"),this.url=\"\",this.status=0,this.response={},this.isAbort=!1,this.originalError=null,Object.setPrototypeOf(this,ClientResponseError.prototype),null!==e&&\"object\"==typeof e&&(this.url=\"string\"==typeof e.url?e.url:\"\",this.status=\"number\"==typeof e.status?e.status:0,this.isAbort=!!e.isAbort,this.originalError=e.originalError,null!==e.response&&\"object\"==typeof e.response?this.response=e.response:null!==e.data&&\"object\"==typeof e.data?this.response=e.data:this.response={}),this.originalError||e instanceof ClientResponseError||(this.originalError=e),\"undefined\"!=typeof DOMException&&e instanceof DOMException&&(this.isAbort=!0),this.name=\"ClientResponseError \"+this.status,this.message=this.response?.message,this.message||(this.isAbort?this.message=\"The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation.\":this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\")?this.message=\"Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).\":this.message=\"Something went wrong while processing your request.\")}get data(){return this.response}toJSON(){return{...this}}}const e=/^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;function cookieParse(e,t){const s={};if(\"string\"!=typeof e)return s;const i=Object.assign({},t||{}).decode||defaultDecode;let n=0;for(;n<e.length;){const t=e.indexOf(\"=\",n);if(-1===t)break;let r=e.indexOf(\";\",n);if(-1===r)r=e.length;else if(r<t){n=e.lastIndexOf(\";\",t-1)+1;continue}const o=e.slice(n,t).trim();if(void 0===s[o]){let n=e.slice(t+1,r).trim();34===n.charCodeAt(0)&&(n=n.slice(1,-1));try{s[o]=i(n)}catch(e){s[o]=n}}n=r+1}return s}function cookieSerialize(t,s,i){const n=Object.assign({},i||{}),r=n.encode||defaultEncode;if(!e.test(t))throw new TypeError(\"argument name is invalid\");const o=r(s);if(o&&!e.test(o))throw new TypeError(\"argument val is invalid\");let a=t+\"=\"+o;if(null!=n.maxAge){const e=n.maxAge-0;if(isNaN(e)||!isFinite(e))throw new TypeError(\"option maxAge is invalid\");a+=\"; Max-Age=\"+Math.floor(e)}if(n.domain){if(!e.test(n.domain))throw new TypeError(\"option domain is invalid\");a+=\"; Domain=\"+n.domain}if(n.path){if(!e.test(n.path))throw new TypeError(\"option path is invalid\");a+=\"; Path=\"+n.path}if(n.expires){if(!function isDate(e){return\"[object Date]\"===Object.prototype.toString.call(e)||e instanceof Date}(n.expires)||isNaN(n.expires.valueOf()))throw new TypeError(\"option expires is invalid\");a+=\"; Expires=\"+n.expires.toUTCString()}if(n.httpOnly&&(a+=\"; HttpOnly\"),n.secure&&(a+=\"; Secure\"),n.priority){switch(\"string\"==typeof n.priority?n.priority.toLowerCase():n.priority){case\"low\":a+=\"; Priority=Low\";break;case\"medium\":a+=\"; Priority=Medium\";break;case\"high\":a+=\"; Priority=High\";break;default:throw new TypeError(\"option priority is invalid\")}}if(n.sameSite){switch(\"string\"==typeof n.sameSite?n.sameSite.toLowerCase():n.sameSite){case!0:a+=\"; SameSite=Strict\";break;case\"lax\":a+=\"; SameSite=Lax\";break;case\"strict\":a+=\"; SameSite=Strict\";break;case\"none\":a+=\"; SameSite=None\";break;default:throw new TypeError(\"option sameSite is invalid\")}}return a}function defaultDecode(e){return-1!==e.indexOf(\"%\")?decodeURIComponent(e):e}function defaultEncode(e){return encodeURIComponent(e)}let t;function getTokenPayload(e){if(e)try{const s=decodeURIComponent(t(e.split(\".\")[1]).split(\"\").map((function(e){return\"%\"+(\"00\"+e.charCodeAt(0).toString(16)).slice(-2)})).join(\"\"));return JSON.parse(s)||{}}catch(e){}return{}}function isTokenExpired(e,t=0){let s=getTokenPayload(e);return!(Object.keys(s).length>0&&(!s.exp||s.exp-t>Date.now()/1e3))}t=\"function\"==typeof atob?atob:e=>{let t=String(e).replace(/=+$/,\"\");if(t.length%4==1)throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");for(var s,i,n=0,r=0,o=\"\";i=t.charAt(r++);~i&&(s=n%4?64*s+i:i,n++%4)?o+=String.fromCharCode(255&s>>(-2*n&6)):0)i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(i);return o};const s=\"pb_auth\";class BaseAuthStore{constructor(){this.baseToken=\"\",this.baseModel=null,this._onChangeCallbacks=[]}get token(){return this.baseToken}get model(){return this.baseModel}get isValid(){return!isTokenExpired(this.token)}get isAdmin(){return\"admin\"===getTokenPayload(this.token).type}get isAuthRecord(){return\"authRecord\"===getTokenPayload(this.token).type}save(e,t){this.baseToken=e||\"\",this.baseModel=t||null,this.triggerChange()}clear(){this.baseToken=\"\",this.baseModel=null,this.triggerChange()}loadFromCookie(e,t=s){const i=cookieParse(e||\"\")[t]||\"\";let n={};try{n=JSON.parse(i),(null===typeof n||\"object\"!=typeof n||Array.isArray(n))&&(n={})}catch(e){}this.save(n.token||\"\",n.model||null)}exportToCookie(e,t=s){const i={secure:!0,sameSite:!0,httpOnly:!0,path:\"/\"},n=getTokenPayload(this.token);i.expires=n?.exp?new Date(1e3*n.exp):new Date(\"1970-01-01\"),e=Object.assign({},i,e);const r={token:this.token,model:this.model?JSON.parse(JSON.stringify(this.model)):null};let o=cookieSerialize(t,JSON.stringify(r),e);const a=\"undefined\"!=typeof Blob?new Blob([o]).size:o.length;if(r.model&&a>4096){r.model={id:r?.model?.id,email:r?.model?.email};const s=[\"collectionId\",\"username\",\"verified\"];for(const e in this.model)s.includes(e)&&(r.model[e]=this.model[e]);o=cookieSerialize(t,JSON.stringify(r),e)}return o}onChange(e,t=!1){return this._onChangeCallbacks.push(e),t&&e(this.token,this.model),()=>{for(let t=this._onChangeCallbacks.length-1;t>=0;t--)if(this._onChangeCallbacks[t]==e)return delete this._onChangeCallbacks[t],void this._onChangeCallbacks.splice(t,1)}}triggerChange(){for(const e of this._onChangeCallbacks)e&&e(this.token,this.model)}}class LocalAuthStore extends BaseAuthStore{constructor(e=\"pocketbase_auth\"){super(),this.storageFallback={},this.storageKey=e,this._bindStorageEvent()}get token(){return(this._storageGet(this.storageKey)||{}).token||\"\"}get model(){return(this._storageGet(this.storageKey)||{}).model||null}save(e,t){this._storageSet(this.storageKey,{token:e,model:t}),super.save(e,t)}clear(){this._storageRemove(this.storageKey),super.clear()}_storageGet(e){if(\"undefined\"!=typeof window&&window?.localStorage){const t=window.localStorage.getItem(e)||\"\";try{return JSON.parse(t)}catch(e){return t}}return this.storageFallback[e]}_storageSet(e,t){if(\"undefined\"!=typeof window&&window?.localStorage){let s=t;\"string\"!=typeof t&&(s=JSON.stringify(t)),window.localStorage.setItem(e,s)}else this.storageFallback[e]=t}_storageRemove(e){\"undefined\"!=typeof window&&window?.localStorage&&window.localStorage?.removeItem(e),delete this.storageFallback[e]}_bindStorageEvent(){\"undefined\"!=typeof window&&window?.localStorage&&window.addEventListener&&window.addEventListener(\"storage\",(e=>{if(e.key!=this.storageKey)return;const t=this._storageGet(this.storageKey)||{};super.save(t.token||\"\",t.model||null)}))}}class BaseService{constructor(e){this.client=e}}class SettingsService extends BaseService{async getAll(e){return e=Object.assign({method:\"GET\"},e),this.client.send(\"/api/settings\",e)}async update(e,t){return t=Object.assign({method:\"PATCH\",body:e},t),this.client.send(\"/api/settings\",t)}async testS3(e=\"storage\",t){return t=Object.assign({method:\"POST\",body:{filesystem:e}},t),this.client.send(\"/api/settings/test/s3\",t).then((()=>!0))}async testEmail(e,t,s){return s=Object.assign({method:\"POST\",body:{email:e,template:t}},s),this.client.send(\"/api/settings/test/email\",s).then((()=>!0))}async generateAppleClientSecret(e,t,s,i,n,r){return r=Object.assign({method:\"POST\",body:{clientId:e,teamId:t,keyId:s,privateKey:i,duration:n}},r),this.client.send(\"/api/settings/apple/generate-client-secret\",r)}}class CrudService extends BaseService{decode(e){return e}async getFullList(e,t){if(\"number\"==typeof e)return this._getFullList(e,t);let s=500;return(t=Object.assign({},e,t)).batch&&(s=t.batch,delete t.batch),this._getFullList(s,t)}async getList(e=1,t=30,s){return(s=Object.assign({method:\"GET\"},s)).query=Object.assign({page:e,perPage:t},s.query),this.client.send(this.baseCrudPath,s).then((e=>(e.items=e.items?.map((e=>this.decode(e)))||[],e)))}async getFirstListItem(e,t){return(t=Object.assign({requestKey:\"one_by_filter_\"+this.baseCrudPath+\"_\"+e},t)).query=Object.assign({filter:e,skipTotal:1},t.query),this.getList(1,1,t).then((e=>{if(!e?.items?.length)throw new ClientResponseError({status:404,response:{code:404,message:\"The requested resource wasn't found.\",data:{}}});return e.items[0]}))}async getOne(e,t){if(!e)throw new ClientResponseError({url:this.client.buildUrl(this.baseCrudPath+\"/\"),status:404,response:{code:404,message:\"Missing required record id.\",data:{}}});return t=Object.assign({method:\"GET\"},t),this.client.send(this.baseCrudPath+\"/\"+encodeURIComponent(e),t).then((e=>this.decode(e)))}async create(e,t){return t=Object.assign({method:\"POST\",body:e},t),this.client.send(this.baseCrudPath,t).then((e=>this.decode(e)))}async update(e,t,s){return s=Object.assign({method:\"PATCH\",body:t},s),this.client.send(this.baseCrudPath+\"/\"+encodeURIComponent(e),s).then((e=>this.decode(e)))}async delete(e,t){return t=Object.assign({method:\"DELETE\"},t),this.client.send(this.baseCrudPath+\"/\"+encodeURIComponent(e),t).then((()=>!0))}_getFullList(e=500,t){(t=t||{}).query=Object.assign({skipTotal:1},t.query);let s=[],request=async i=>this.getList(i,e||500,t).then((e=>{const t=e.items;return s=s.concat(t),t.length==e.perPage?request(i+1):s}));return request(1)}}function normalizeLegacyOptionsArgs(e,t,s,i){const n=void 0!==i;return n||void 0!==s?n?(console.warn(e),t.body=Object.assign({},t.body,s),t.query=Object.assign({},t.query,i),t):Object.assign(t,s):t}function resetAutoRefresh(e){e._resetAutoRefresh?.()}class AdminService extends CrudService{get baseCrudPath(){return\"/api/admins\"}async update(e,t,s){return super.update(e,t,s).then((e=>(this.client.authStore.model?.id===e.id&&void 0===this.client.authStore.model?.collectionId&&this.client.authStore.save(this.client.authStore.token,e),e)))}async delete(e,t){return super.delete(e,t).then((t=>(t&&this.client.authStore.model?.id===e&&void 0===this.client.authStore.model?.collectionId&&this.client.authStore.clear(),t)))}authResponse(e){const t=this.decode(e?.admin||{});return e?.token&&e?.admin&&this.client.authStore.save(e.token,t),Object.assign({},e,{token:e?.token||\"\",admin:t})}async authWithPassword(e,t,s,i){let n={method:\"POST\",body:{identity:e,password:t}};n=normalizeLegacyOptionsArgs(\"This form of authWithPassword(email, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(email, pass, options?).\",n,s,i);const r=n.autoRefreshThreshold;delete n.autoRefreshThreshold,n.autoRefresh||resetAutoRefresh(this.client);let o=await this.client.send(this.baseCrudPath+\"/auth-with-password\",n);return o=this.authResponse(o),r&&function registerAutoRefresh(e,t,s,i){resetAutoRefresh(e);const n=e.beforeSend,r=e.authStore.model,o=e.authStore.onChange(((t,s)=>{(!t||s?.id!=r?.id||(s?.collectionId||r?.collectionId)&&s?.collectionId!=r?.collectionId)&&resetAutoRefresh(e)}));e._resetAutoRefresh=function(){o(),e.beforeSend=n,delete e._resetAutoRefresh},e.beforeSend=async(r,o)=>{const a=e.authStore.token;if(o.query?.autoRefresh)return n?n(r,o):{url:r,sendOptions:o};let c=e.authStore.isValid;if(c&&isTokenExpired(e.authStore.token,t))try{await s()}catch(e){c=!1}c||await i();const l=o.headers||{};for(let t in l)if(\"authorization\"==t.toLowerCase()&&a==l[t]&&e.authStore.token){l[t]=e.authStore.token;break}return o.headers=l,n?n(r,o):{url:r,sendOptions:o}}}(this.client,r,(()=>this.authRefresh({autoRefresh:!0})),(()=>this.authWithPassword(e,t,Object.assign({autoRefresh:!0},n)))),o}async authRefresh(e,t){let s={method:\"POST\"};return s=normalizeLegacyOptionsArgs(\"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\",s,e,t),this.client.send(this.baseCrudPath+\"/auth-refresh\",s).then(this.authResponse.bind(this))}async requestPasswordReset(e,t,s){let i={method:\"POST\",body:{email:e}};return i=normalizeLegacyOptionsArgs(\"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\",i,t,s),this.client.send(this.baseCrudPath+\"/request-password-reset\",i).then((()=>!0))}async confirmPasswordReset(e,t,s,i,n){let r={method:\"POST\",body:{token:e,password:t,passwordConfirm:s}};return r=normalizeLegacyOptionsArgs(\"This form of confirmPasswordReset(resetToken, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(resetToken, password, passwordConfirm, options?).\",r,i,n),this.client.send(this.baseCrudPath+\"/confirm-password-reset\",r).then((()=>!0))}}const i=[\"requestKey\",\"$cancelKey\",\"$autoCancel\",\"fetch\",\"headers\",\"body\",\"query\",\"params\",\"cache\",\"credentials\",\"headers\",\"integrity\",\"keepalive\",\"method\",\"mode\",\"redirect\",\"referrer\",\"referrerPolicy\",\"signal\",\"window\"];function normalizeUnknownQueryParams(e){if(e){e.query=e.query||{};for(let t in e)i.includes(t)||(e.query[t]=e[t],delete e[t])}}class RealtimeService extends BaseService{constructor(){super(...arguments),this.clientId=\"\",this.eventSource=null,this.subscriptions={},this.lastSentSubscriptions=[],this.maxConnectTimeout=15e3,this.reconnectAttempts=0,this.maxReconnectAttempts=1/0,this.predefinedReconnectIntervals=[200,300,500,1e3,1200,1500,2e3],this.pendingConnects=[]}get isConnected(){return!!this.eventSource&&!!this.clientId&&!this.pendingConnects.length}async subscribe(e,t,s){if(!e)throw new Error(\"topic must be set.\");let i=e;if(s){normalizeUnknownQueryParams(s);const e=\"options=\"+encodeURIComponent(JSON.stringify({query:s.query,headers:s.headers}));i+=(i.includes(\"?\")?\"&\":\"?\")+e}const listener=function(e){const s=e;let i;try{i=JSON.parse(s?.data)}catch{}t(i||{})};return this.subscriptions[i]||(this.subscriptions[i]=[]),this.subscriptions[i].push(listener),this.isConnected?1===this.subscriptions[i].length?await this.submitSubscriptions():this.eventSource?.addEventListener(i,listener):await this.connect(),async()=>this.unsubscribeByTopicAndListener(e,listener)}async unsubscribe(e){let t=!1;if(e){const s=this.getSubscriptionsByTopic(e);for(let e in s)if(this.hasSubscriptionListeners(e)){for(let t of this.subscriptions[e])this.eventSource?.removeEventListener(e,t);delete this.subscriptions[e],t||(t=!0)}}else this.subscriptions={};this.hasSubscriptionListeners()?t&&await this.submitSubscriptions():this.disconnect()}async unsubscribeByPrefix(e){let t=!1;for(let s in this.subscriptions)if((s+\"?\").startsWith(e)){t=!0;for(let e of this.subscriptions[s])this.eventSource?.removeEventListener(s,e);delete this.subscriptions[s]}t&&(this.hasSubscriptionListeners()?await this.submitSubscriptions():this.disconnect())}async unsubscribeByTopicAndListener(e,t){let s=!1;const i=this.getSubscriptionsByTopic(e);for(let e in i){if(!Array.isArray(this.subscriptions[e])||!this.subscriptions[e].length)continue;let i=!1;for(let s=this.subscriptions[e].length-1;s>=0;s--)this.subscriptions[e][s]===t&&(i=!0,delete this.subscriptions[e][s],this.subscriptions[e].splice(s,1),this.eventSource?.removeEventListener(e,t));i&&(this.subscriptions[e].length||delete this.subscriptions[e],s||this.hasSubscriptionListeners(e)||(s=!0))}this.hasSubscriptionListeners()?s&&await this.submitSubscriptions():this.disconnect()}hasSubscriptionListeners(e){if(this.subscriptions=this.subscriptions||{},e)return!!this.subscriptions[e]?.length;for(let e in this.subscriptions)if(this.subscriptions[e]?.length)return!0;return!1}async submitSubscriptions(){if(this.clientId)return this.addAllSubscriptionListeners(),this.lastSentSubscriptions=this.getNonEmptySubscriptionKeys(),this.client.send(\"/api/realtime\",{method:\"POST\",body:{clientId:this.clientId,subscriptions:this.lastSentSubscriptions},requestKey:this.getSubscriptionsCancelKey()}).catch((e=>{if(!e?.isAbort)throw e}))}getSubscriptionsCancelKey(){return\"realtime_\"+this.clientId}getSubscriptionsByTopic(e){const t={};e=e.includes(\"?\")?e:e+\"?\";for(let s in this.subscriptions)(s+\"?\").startsWith(e)&&(t[s]=this.subscriptions[s]);return t}getNonEmptySubscriptionKeys(){const e=[];for(let t in this.subscriptions)this.subscriptions[t].length&&e.push(t);return e}addAllSubscriptionListeners(){if(this.eventSource){this.removeAllSubscriptionListeners();for(let e in this.subscriptions)for(let t of this.subscriptions[e])this.eventSource.addEventListener(e,t)}}removeAllSubscriptionListeners(){if(this.eventSource)for(let e in this.subscriptions)for(let t of this.subscriptions[e])this.eventSource.removeEventListener(e,t)}async connect(){if(!(this.reconnectAttempts>0))return new Promise(((e,t)=>{this.pendingConnects.push({resolve:e,reject:t}),this.pendingConnects.length>1||this.initConnect()}))}initConnect(){this.disconnect(!0),clearTimeout(this.connectTimeoutId),this.connectTimeoutId=setTimeout((()=>{this.connectErrorHandler(new Error(\"EventSource connect took too long.\"))}),this.maxConnectTimeout),this.eventSource=new EventSource(this.client.buildUrl(\"/api/realtime\")),this.eventSource.onerror=e=>{this.connectErrorHandler(new Error(\"Failed to establish realtime connection.\"))},this.eventSource.addEventListener(\"PB_CONNECT\",(e=>{const t=e;this.clientId=t?.lastEventId,this.submitSubscriptions().then((async()=>{let e=3;for(;this.hasUnsentSubscriptions()&&e>0;)e--,await this.submitSubscriptions()})).then((()=>{for(let e of this.pendingConnects)e.resolve();this.pendingConnects=[],this.reconnectAttempts=0,clearTimeout(this.reconnectTimeoutId),clearTimeout(this.connectTimeoutId);const t=this.getSubscriptionsByTopic(\"PB_CONNECT\");for(let s in t)for(let i of t[s])i(e)})).catch((e=>{this.clientId=\"\",this.connectErrorHandler(e)}))}))}hasUnsentSubscriptions(){const e=this.getNonEmptySubscriptionKeys();if(e.length!=this.lastSentSubscriptions.length)return!0;for(const t of e)if(!this.lastSentSubscriptions.includes(t))return!0;return!1}connectErrorHandler(e){if(clearTimeout(this.connectTimeoutId),clearTimeout(this.reconnectTimeoutId),!this.clientId&&!this.reconnectAttempts||this.reconnectAttempts>this.maxReconnectAttempts){for(let t of this.pendingConnects)t.reject(new ClientResponseError(e));return this.pendingConnects=[],void this.disconnect()}this.disconnect(!0);const t=this.predefinedReconnectIntervals[this.reconnectAttempts]||this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length-1];this.reconnectAttempts++,this.reconnectTimeoutId=setTimeout((()=>{this.initConnect()}),t)}disconnect(e=!1){if(clearTimeout(this.connectTimeoutId),clearTimeout(this.reconnectTimeoutId),this.removeAllSubscriptionListeners(),this.client.cancelRequest(this.getSubscriptionsCancelKey()),this.eventSource?.close(),this.eventSource=null,this.clientId=\"\",!e){this.reconnectAttempts=0;for(let e of this.pendingConnects)e.resolve();this.pendingConnects=[]}}}class RecordService extends CrudService{constructor(e,t){super(e),this.collectionIdOrName=t}get baseCrudPath(){return this.baseCollectionPath+\"/records\"}get baseCollectionPath(){return\"/api/collections/\"+encodeURIComponent(this.collectionIdOrName)}async subscribe(e,t,s){if(!e)throw new Error(\"Missing topic.\");if(!t)throw new Error(\"Missing subscription callback.\");return this.client.realtime.subscribe(this.collectionIdOrName+\"/\"+e,t,s)}async unsubscribe(e){return e?this.client.realtime.unsubscribe(this.collectionIdOrName+\"/\"+e):this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName)}async getFullList(e,t){if(\"number\"==typeof e)return super.getFullList(e,t);const s=Object.assign({},e,t);return super.getFullList(s)}async getList(e=1,t=30,s){return super.getList(e,t,s)}async getFirstListItem(e,t){return super.getFirstListItem(e,t)}async getOne(e,t){return super.getOne(e,t)}async create(e,t){return super.create(e,t)}async update(e,t,s){return super.update(e,t,s).then((e=>(this.client.authStore.model?.id!==e?.id||this.client.authStore.model?.collectionId!==this.collectionIdOrName&&this.client.authStore.model?.collectionName!==this.collectionIdOrName||this.client.authStore.save(this.client.authStore.token,e),e)))}async delete(e,t){return super.delete(e,t).then((t=>(!t||this.client.authStore.model?.id!==e||this.client.authStore.model?.collectionId!==this.collectionIdOrName&&this.client.authStore.model?.collectionName!==this.collectionIdOrName||this.client.authStore.clear(),t)))}authResponse(e){const t=this.decode(e?.record||{});return this.client.authStore.save(e?.token,t),Object.assign({},e,{token:e?.token||\"\",record:t})}async listAuthMethods(e){return e=Object.assign({method:\"GET\"},e),this.client.send(this.baseCollectionPath+\"/auth-methods\",e).then((e=>Object.assign({},e,{usernamePassword:!!e?.usernamePassword,emailPassword:!!e?.emailPassword,authProviders:Array.isArray(e?.authProviders)?e?.authProviders:[]})))}async authWithPassword(e,t,s,i){let n={method:\"POST\",body:{identity:e,password:t}};return n=normalizeLegacyOptionsArgs(\"This form of authWithPassword(usernameOrEmail, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(usernameOrEmail, pass, options?).\",n,s,i),this.client.send(this.baseCollectionPath+\"/auth-with-password\",n).then((e=>this.authResponse(e)))}async authWithOAuth2Code(e,t,s,i,n,r,o){let a={method:\"POST\",body:{provider:e,code:t,codeVerifier:s,redirectUrl:i,createData:n}};return a=normalizeLegacyOptionsArgs(\"This form of authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, options?).\",a,r,o),this.client.send(this.baseCollectionPath+\"/auth-with-oauth2\",a).then((e=>this.authResponse(e)))}async authWithOAuth2(...e){if(e.length>1||\"string\"==typeof e?.[0])return console.warn(\"PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\"),this.authWithOAuth2Code(e?.[0]||\"\",e?.[1]||\"\",e?.[2]||\"\",e?.[3]||\"\",e?.[4]||{},e?.[5]||{},e?.[6]||{});const t=e?.[0]||{},s=(await this.listAuthMethods()).authProviders.find((e=>e.name===t.provider));if(!s)throw new ClientResponseError(new Error(`Missing or invalid provider \"${t.provider}\".`));const i=this.client.buildUrl(\"/api/oauth2-redirect\"),n=new RealtimeService(this.client);let r=null;function cleanup(){r?.close(),n.unsubscribe()}return t.urlCallback||(r=openBrowserPopup(void 0)),new Promise((async(e,o)=>{try{await n.subscribe(\"@oauth2\",(async r=>{const a=n.clientId;try{if(!r.state||a!==r.state)throw new Error(\"State parameters don't match.\");if(r.error||!r.code)throw new Error(\"OAuth2 redirect error or missing code: \"+r.error);const n=Object.assign({},t);delete n.provider,delete n.scopes,delete n.createData,delete n.urlCallback;const o=await this.authWithOAuth2Code(s.name,r.code,s.codeVerifier,i,t.createData,n);e(o)}catch(e){o(new ClientResponseError(e))}cleanup()}));const a={state:n.clientId};t.scopes?.length&&(a.scope=t.scopes.join(\" \"));const c=this._replaceQueryParams(s.authUrl+i,a);let l=t.urlCallback||function(e){r?r.location.href=e:r=openBrowserPopup(e)};await l(c)}catch(e){cleanup(),o(new ClientResponseError(e))}}))}async authRefresh(e,t){let s={method:\"POST\"};return s=normalizeLegacyOptionsArgs(\"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\",s,e,t),this.client.send(this.baseCollectionPath+\"/auth-refresh\",s).then((e=>this.authResponse(e)))}async requestPasswordReset(e,t,s){let i={method:\"POST\",body:{email:e}};return i=normalizeLegacyOptionsArgs(\"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\",i,t,s),this.client.send(this.baseCollectionPath+\"/request-password-reset\",i).then((()=>!0))}async confirmPasswordReset(e,t,s,i,n){let r={method:\"POST\",body:{token:e,password:t,passwordConfirm:s}};return r=normalizeLegacyOptionsArgs(\"This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).\",r,i,n),this.client.send(this.baseCollectionPath+\"/confirm-password-reset\",r).then((()=>!0))}async requestVerification(e,t,s){let i={method:\"POST\",body:{email:e}};return i=normalizeLegacyOptionsArgs(\"This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).\",i,t,s),this.client.send(this.baseCollectionPath+\"/request-verification\",i).then((()=>!0))}async confirmVerification(e,t,s){let i={method:\"POST\",body:{token:e}};return i=normalizeLegacyOptionsArgs(\"This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).\",i,t,s),this.client.send(this.baseCollectionPath+\"/confirm-verification\",i).then((()=>{const t=getTokenPayload(e),s=this.client.authStore.model;return s&&!s.verified&&s.id===t.id&&s.collectionId===t.collectionId&&(s.verified=!0,this.client.authStore.save(this.client.authStore.token,s)),!0}))}async requestEmailChange(e,t,s){let i={method:\"POST\",body:{newEmail:e}};return i=normalizeLegacyOptionsArgs(\"This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).\",i,t,s),this.client.send(this.baseCollectionPath+\"/request-email-change\",i).then((()=>!0))}async confirmEmailChange(e,t,s,i){let n={method:\"POST\",body:{token:e,password:t}};return n=normalizeLegacyOptionsArgs(\"This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).\",n,s,i),this.client.send(this.baseCollectionPath+\"/confirm-email-change\",n).then((()=>{const t=getTokenPayload(e),s=this.client.authStore.model;return s&&s.id===t.id&&s.collectionId===t.collectionId&&this.client.authStore.clear(),!0}))}async listExternalAuths(e,t){return t=Object.assign({method:\"GET\"},t),this.client.send(this.baseCrudPath+\"/\"+encodeURIComponent(e)+\"/external-auths\",t)}async unlinkExternalAuth(e,t,s){return s=Object.assign({method:\"DELETE\"},s),this.client.send(this.baseCrudPath+\"/\"+encodeURIComponent(e)+\"/external-auths/\"+encodeURIComponent(t),s).then((()=>!0))}_replaceQueryParams(e,t={}){let s=e,i=\"\";e.indexOf(\"?\")>=0&&(s=e.substring(0,e.indexOf(\"?\")),i=e.substring(e.indexOf(\"?\")+1));const n={},r=i.split(\"&\");for(const e of r){if(\"\"==e)continue;const t=e.split(\"=\");n[decodeURIComponent(t[0].replace(/\\+/g,\" \"))]=decodeURIComponent((t[1]||\"\").replace(/\\+/g,\" \"))}for(let e in t)t.hasOwnProperty(e)&&(null==t[e]?delete n[e]:n[e]=t[e]);i=\"\";for(let e in n)n.hasOwnProperty(e)&&(\"\"!=i&&(i+=\"&\"),i+=encodeURIComponent(e.replace(/%20/g,\"+\"))+\"=\"+encodeURIComponent(n[e].replace(/%20/g,\"+\")));return\"\"!=i?s+\"?\"+i:s}}function openBrowserPopup(e){if(\"undefined\"==typeof window||!window?.open)throw new ClientResponseError(new Error(\"Not in a browser context - please pass a custom urlCallback function.\"));let t=1024,s=768,i=window.innerWidth,n=window.innerHeight;t=t>i?i:t,s=s>n?n:s;let r=i/2-t/2,o=n/2-s/2;return window.open(e,\"popup_window\",\"width=\"+t+\",height=\"+s+\",top=\"+o+\",left=\"+r+\",resizable,menubar=no\")}class CollectionService extends CrudService{get baseCrudPath(){return\"/api/collections\"}async import(e,t=!1,s){return s=Object.assign({method:\"PUT\",body:{collections:e,deleteMissing:t}},s),this.client.send(this.baseCrudPath+\"/import\",s).then((()=>!0))}}class LogService extends BaseService{async getList(e=1,t=30,s){return(s=Object.assign({method:\"GET\"},s)).query=Object.assign({page:e,perPage:t},s.query),this.client.send(\"/api/logs\",s)}async getOne(e,t){if(!e)throw new ClientResponseError({url:this.client.buildUrl(\"/api/logs/\"),status:404,response:{code:404,message:\"Missing required log id.\",data:{}}});return t=Object.assign({method:\"GET\"},t),this.client.send(\"/api/logs/\"+encodeURIComponent(e),t)}async getStats(e){return e=Object.assign({method:\"GET\"},e),this.client.send(\"/api/logs/stats\",e)}}class HealthService extends BaseService{async check(e){return e=Object.assign({method:\"GET\"},e),this.client.send(\"/api/health\",e)}}class FileService extends BaseService{getUrl(e,t,s={}){if(!t||!e?.id||!e?.collectionId&&!e?.collectionName)return\"\";const i=[];i.push(\"api\"),i.push(\"files\"),i.push(encodeURIComponent(e.collectionId||e.collectionName)),i.push(encodeURIComponent(e.id)),i.push(encodeURIComponent(t));let n=this.client.buildUrl(i.join(\"/\"));if(Object.keys(s).length){!1===s.download&&delete s.download;const e=new URLSearchParams(s);n+=(n.includes(\"?\")?\"&\":\"?\")+e}return n}async getToken(e){return e=Object.assign({method:\"POST\"},e),this.client.send(\"/api/files/token\",e).then((e=>e?.token||\"\"))}}class BackupService extends BaseService{async getFullList(e){return e=Object.assign({method:\"GET\"},e),this.client.send(\"/api/backups\",e)}async create(e,t){return t=Object.assign({method:\"POST\",body:{name:e}},t),this.client.send(\"/api/backups\",t).then((()=>!0))}async upload(e,t){return t=Object.assign({method:\"POST\",body:e},t),this.client.send(\"/api/backups/upload\",t).then((()=>!0))}async delete(e,t){return t=Object.assign({method:\"DELETE\"},t),this.client.send(`/api/backups/${encodeURIComponent(e)}`,t).then((()=>!0))}async restore(e,t){return t=Object.assign({method:\"POST\"},t),this.client.send(`/api/backups/${encodeURIComponent(e)}/restore`,t).then((()=>!0))}getDownloadUrl(e,t){return this.client.buildUrl(`/api/backups/${encodeURIComponent(t)}?token=${encodeURIComponent(e)}`)}}class Client{constructor(e=\"/\",t,s=\"en-US\"){this.cancelControllers={},this.recordServices={},this.enableAutoCancellation=!0,this.baseUrl=e,this.lang=s,this.authStore=t||new LocalAuthStore,this.admins=new AdminService(this),this.collections=new CollectionService(this),this.files=new FileService(this),this.logs=new LogService(this),this.settings=new SettingsService(this),this.realtime=new RealtimeService(this),this.health=new HealthService(this),this.backups=new BackupService(this)}collection(e){return this.recordServices[e]||(this.recordServices[e]=new RecordService(this,e)),this.recordServices[e]}autoCancellation(e){return this.enableAutoCancellation=!!e,this}cancelRequest(e){return this.cancelControllers[e]&&(this.cancelControllers[e].abort(),delete this.cancelControllers[e]),this}cancelAllRequests(){for(let e in this.cancelControllers)this.cancelControllers[e].abort();return this.cancelControllers={},this}filter(e,t){if(!t)return e;for(let s in t){let i=t[s];switch(typeof i){case\"boolean\":case\"number\":i=\"\"+i;break;case\"string\":i=\"'\"+i.replace(/'/g,\"\\\\'\")+\"'\";break;default:i=null===i?\"null\":i instanceof Date?\"'\"+i.toISOString().replace(\"T\",\" \")+\"'\":\"'\"+JSON.stringify(i).replace(/'/g,\"\\\\'\")+\"'\"}e=e.replaceAll(\"{:\"+s+\"}\",i)}return e}getFileUrl(e,t,s={}){return this.files.getUrl(e,t,s)}buildUrl(e){let t=this.baseUrl;return\"undefined\"==typeof window||!window.location||t.startsWith(\"https://\")||t.startsWith(\"http://\")||(t=window.location.origin?.endsWith(\"/\")?window.location.origin.substring(0,window.location.origin.length-1):window.location.origin||\"\",this.baseUrl.startsWith(\"/\")||(t+=window.location.pathname||\"/\",t+=t.endsWith(\"/\")?\"\":\"/\"),t+=this.baseUrl),e&&(t+=t.endsWith(\"/\")?\"\":\"/\",t+=e.startsWith(\"/\")?e.substring(1):e),t}async send(e,t){t=this.initSendOptions(e,t);let s=this.buildUrl(e);if(this.beforeSend){const e=Object.assign({},await this.beforeSend(s,t));void 0!==e.url||void 0!==e.options?(s=e.url||s,t=e.options||t):Object.keys(e).length&&(t=e,console?.warn&&console.warn(\"Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.\"))}if(void 0!==t.query){const e=this.serializeQueryParams(t.query);e&&(s+=(s.includes(\"?\")?\"&\":\"?\")+e),delete t.query}\"application/json\"==this.getHeader(t.headers,\"Content-Type\")&&t.body&&\"string\"!=typeof t.body&&(t.body=JSON.stringify(t.body));return(t.fetch||fetch)(s,t).then((async e=>{let t={};try{t=await e.json()}catch(e){}if(this.afterSend&&(t=await this.afterSend(e,t)),e.status>=400)throw new ClientResponseError({url:e.url,status:e.status,data:t});return t})).catch((e=>{throw new ClientResponseError(e)}))}initSendOptions(e,t){if((t=Object.assign({method:\"GET\"},t)).body=this.convertToFormDataIfNeeded(t.body),normalizeUnknownQueryParams(t),t.query=Object.assign({},t.params,t.query),void 0===t.requestKey&&(!1===t.$autoCancel||!1===t.query.$autoCancel?t.requestKey=null:(t.$cancelKey||t.query.$cancelKey)&&(t.requestKey=t.$cancelKey||t.query.$cancelKey)),delete t.$autoCancel,delete t.query.$autoCancel,delete t.$cancelKey,delete t.query.$cancelKey,null!==this.getHeader(t.headers,\"Content-Type\")||this.isFormData(t.body)||(t.headers=Object.assign({},t.headers,{\"Content-Type\":\"application/json\"})),null===this.getHeader(t.headers,\"Accept-Language\")&&(t.headers=Object.assign({},t.headers,{\"Accept-Language\":this.lang})),this.authStore.token&&null===this.getHeader(t.headers,\"Authorization\")&&(t.headers=Object.assign({},t.headers,{Authorization:this.authStore.token})),this.enableAutoCancellation&&null!==t.requestKey){const s=t.requestKey||(t.method||\"GET\")+e;delete t.requestKey,this.cancelRequest(s);const i=new AbortController;this.cancelControllers[s]=i,t.signal=i.signal}return t}convertToFormDataIfNeeded(e){if(\"undefined\"==typeof FormData||void 0===e||\"object\"!=typeof e||null===e||this.isFormData(e)||!this.hasBlobField(e))return e;const t=new FormData;for(const s in e){const i=e[s];if(\"object\"!=typeof i||this.hasBlobField({data:i})){const e=Array.isArray(i)?i:[i];for(let i of e)t.append(s,i)}else{let e={};e[s]=i,t.append(\"@jsonPayload\",JSON.stringify(e))}}return t}hasBlobField(e){for(const t in e){const s=Array.isArray(e[t])?e[t]:[e[t]];for(const e of s)if(\"undefined\"!=typeof Blob&&e instanceof Blob||\"undefined\"!=typeof File&&e instanceof File)return!0}return!1}getHeader(e,t){e=e||{},t=t.toLowerCase();for(let s in e)if(s.toLowerCase()==t)return e[s];return null}isFormData(e){return e&&(\"FormData\"===e.constructor.name||\"undefined\"!=typeof FormData&&e instanceof FormData)}serializeQueryParams(e){const t=[];for(const s in e){if(null===e[s])continue;const i=e[s],n=encodeURIComponent(s);if(Array.isArray(i))for(const e of i)t.push(n+\"=\"+encodeURIComponent(e));else i instanceof Date?t.push(n+\"=\"+encodeURIComponent(i.toISOString())):null!==typeof i&&\"object\"==typeof i?t.push(n+\"=\"+encodeURIComponent(JSON.stringify(i))):t.push(n+\"=\"+encodeURIComponent(i))}return t.join(\"&\")}}class AsyncAuthStore extends BaseAuthStore{constructor(e){super(),this.queue=[],this.saveFunc=e.save,this.clearFunc=e.clear,this._enqueue((()=>this._loadInitial(e.initial)))}save(e,t){super.save(e,t);let s=\"\";try{s=JSON.stringify({token:e,model:t})}catch(e){console.warn(\"AsyncAuthStore: failed to stringify the new state\")}this._enqueue((()=>this.saveFunc(s)))}clear(){super.clear(),this.clearFunc?this._enqueue((()=>this.clearFunc())):this._enqueue((()=>this.saveFunc(\"\")))}async _loadInitial(e){try{if(e=await e){let t;\"string\"==typeof e?t=JSON.parse(e)||{}:\"object\"==typeof e&&(t=e),this.save(t.token||\"\",t.model||null)}}catch(e){}}_enqueue(e){this.queue.push(e),1==this.queue.length&&this._dequeue()}_dequeue(){this.queue.length&&this.queue[0]().finally((()=>{this.queue.shift(),this.queue.length&&this._dequeue()}))}}export{AdminService,AsyncAuthStore,BaseAuthStore,ClientResponseError,CollectionService,CrudService,LocalAuthStore,LogService,RealtimeService,RecordService,cookieParse,cookieSerialize,Client as default,getTokenPayload,isTokenExpired,normalizeUnknownQueryParams};\n//# sourceMappingURL=pocketbase.es.mjs.map\n","/**\n * ClientResponseError is a custom Error class that is intended to wrap\n * and normalize any error thrown by `Client.send()`.\n */\nexport class ClientResponseError extends Error {\n    url: string = \"\";\n    status: number = 0;\n    response: { [key: string]: any } = {};\n    isAbort: boolean = false;\n    originalError: any = null;\n\n    constructor(errData?: any) {\n        super(\"ClientResponseError\");\n\n        // Set the prototype explicitly.\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, ClientResponseError.prototype);\n\n        if (errData !== null && typeof errData === \"object\") {\n            this.url = typeof errData.url === \"string\" ? errData.url : \"\";\n            this.status = typeof errData.status === \"number\" ? errData.status : 0;\n            this.isAbort = !!errData.isAbort;\n            this.originalError = errData.originalError;\n\n            if (errData.response !== null && typeof errData.response === \"object\") {\n                this.response = errData.response;\n            } else if (errData.data !== null && typeof errData.data === \"object\") {\n                this.response = errData.data;\n            } else {\n                this.response = {};\n            }\n        }\n\n        if (!this.originalError && !(errData instanceof ClientResponseError)) {\n            this.originalError = errData;\n        }\n\n        if (typeof DOMException !== \"undefined\" && errData instanceof DOMException) {\n            this.isAbort = true;\n        }\n\n        this.name = \"ClientResponseError \" + this.status;\n        this.message = this.response?.message;\n        if (!this.message) {\n            if (this.isAbort) {\n                this.message =\n                    \"The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation.\";\n            } else if (this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\")) {\n                this.message =\n                    \"Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).\";\n            } else {\n                this.message = \"Something went wrong while processing your request.\";\n            }\n        }\n    }\n\n    /**\n     * Alias for `this.response` to preserve the backward compatibility.\n     */\n    get data() {\n        return this.response;\n    }\n\n    /**\n     * Make a POJO's copy of the current error class instance.\n     * @see https://github.com/vuex-orm/vuex-orm/issues/255\n     */\n    toJSON() {\n        return { ...this };\n    }\n}\n","/**\n * -------------------------------------------------------------------\n * Simple cookie parse and serialize utilities mostly based on the\n * node module https://github.com/jshttp/cookie.\n * -------------------------------------------------------------------\n */\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nexport interface ParseOptions {\n    decode?: (val: string) => string;\n}\n\n/**\n * Parses the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nexport function cookieParse(str: string, options?: ParseOptions): { [key: string]: any } {\n    const result: { [key: string]: any } = {};\n\n    if (typeof str !== \"string\") {\n        return result;\n    }\n\n    const opt = Object.assign({}, options || {});\n    const decode = opt.decode || defaultDecode;\n\n    let index = 0;\n    while (index < str.length) {\n        const eqIdx = str.indexOf(\"=\", index);\n\n        // no more cookie pairs\n        if (eqIdx === -1) {\n            break;\n        }\n\n        let endIdx = str.indexOf(\";\", index);\n\n        if (endIdx === -1) {\n            endIdx = str.length;\n        } else if (endIdx < eqIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n\n        const key = str.slice(index, eqIdx).trim();\n\n        // only assign once\n        if (undefined === result[key]) {\n            let val = str.slice(eqIdx + 1, endIdx).trim();\n\n            // quoted values\n            if (val.charCodeAt(0) === 0x22) {\n                val = val.slice(1, -1);\n            }\n\n            try {\n                result[key] = decode(val);\n            } catch (_) {\n                result[key] = val; // no decoding\n            }\n        }\n\n        index = endIdx + 1;\n    }\n\n    return result;\n}\n\nexport interface SerializeOptions {\n    encode?: (val: string | number | boolean) => string;\n    maxAge?: number;\n    domain?: string;\n    path?: string;\n    expires?: Date;\n    httpOnly?: boolean;\n    secure?: boolean;\n    priority?: string;\n    sameSite?: boolean | string;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * ```js\n * cookieSerialize('foo', 'bar', { httpOnly: true }) // \"foo=bar; httpOnly\"\n * ```\n */\nexport function cookieSerialize(\n    name: string,\n    val: string,\n    options?: SerializeOptions,\n): string {\n    const opt = Object.assign({}, options || {});\n    const encode = opt.encode || defaultEncode;\n\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError(\"argument name is invalid\");\n    }\n\n    const value = encode(val);\n\n    if (value && !fieldContentRegExp.test(value)) {\n        throw new TypeError(\"argument val is invalid\");\n    }\n\n    let result = name + \"=\" + value;\n\n    if (opt.maxAge != null) {\n        const maxAge = opt.maxAge - 0;\n\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError(\"option maxAge is invalid\");\n        }\n\n        result += \"; Max-Age=\" + Math.floor(maxAge);\n    }\n\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError(\"option domain is invalid\");\n        }\n\n        result += \"; Domain=\" + opt.domain;\n    }\n\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError(\"option path is invalid\");\n        }\n\n        result += \"; Path=\" + opt.path;\n    }\n\n    if (opt.expires) {\n        if (!isDate(opt.expires) || isNaN(opt.expires.valueOf())) {\n            throw new TypeError(\"option expires is invalid\");\n        }\n\n        result += \"; Expires=\" + opt.expires.toUTCString();\n    }\n\n    if (opt.httpOnly) {\n        result += \"; HttpOnly\";\n    }\n\n    if (opt.secure) {\n        result += \"; Secure\";\n    }\n\n    if (opt.priority) {\n        const priority =\n            typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n\n        switch (priority) {\n            case \"low\":\n                result += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                result += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                result += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(\"option priority is invalid\");\n        }\n    }\n\n    if (opt.sameSite) {\n        const sameSite =\n            typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n        switch (sameSite) {\n            case true:\n                result += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                result += \"; SameSite=Lax\";\n                break;\n            case \"strict\":\n                result += \"; SameSite=Strict\";\n                break;\n            case \"none\":\n                result += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(\"option sameSite is invalid\");\n        }\n    }\n\n    return result;\n}\n\n/**\n * Default URL-decode string value function.\n * Optimized to skip native call when no `%`.\n */\nfunction defaultDecode(val: string): string {\n    return val.indexOf(\"%\") !== -1 ? decodeURIComponent(val) : val;\n}\n\n/**\n * Default URL-encode value function.\n */\nfunction defaultEncode(val: string | number | boolean): string {\n    return encodeURIComponent(val);\n}\n\n/**\n * Determines if value is a Date.\n */\nfunction isDate(val: any): boolean {\n    return Object.prototype.toString.call(val) === \"[object Date]\" || val instanceof Date;\n}\n","let atobPolyfill: Function;\nif (typeof atob === \"function\") {\n    atobPolyfill = atob;\n} else {\n    /**\n     * The code was extracted from:\n     * https://github.com/davidchambers/Base64.js\n     */\n    atobPolyfill = (input: any) => {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        let str = String(input).replace(/=+$/, \"\");\n        if (str.length % 4 == 1) {\n            throw new Error(\n                \"'atob' failed: The string to be decoded is not correctly encoded.\",\n            );\n        }\n\n        for (\n            // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = \"\";\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            ((bs = bc % 4 ? (bs as any) * 64 + buffer : buffer),\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4)\n                ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n                : 0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n\n        return output;\n    };\n}\n\n/**\n * Returns JWT token's payload data.\n */\nexport function getTokenPayload(token: string): { [key: string]: any } {\n    if (token) {\n        try {\n            const encodedPayload = decodeURIComponent(\n                atobPolyfill(token.split(\".\")[1])\n                    .split(\"\")\n                    .map(function (c: string) {\n                        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n                    })\n                    .join(\"\"),\n            );\n\n            return JSON.parse(encodedPayload) || {};\n        } catch (e) {}\n    }\n\n    return {};\n}\n\n/**\n * Checks whether a JWT token is expired or not.\n * Tokens without `exp` payload key are considered valid.\n * Tokens with empty payload (eg. invalid token strings) are considered expired.\n *\n * @param token The token to check.\n * @param [expirationThreshold] Time in seconds that will be subtracted from the token `exp` property.\n */\nexport function isTokenExpired(token: string, expirationThreshold = 0): boolean {\n    let payload = getTokenPayload(token);\n\n    if (\n        Object.keys(payload).length > 0 &&\n        (!payload.exp || payload.exp - expirationThreshold > Date.now() / 1000)\n    ) {\n        return false;\n    }\n\n    return true;\n}\n","import { cookieParse, cookieSerialize, SerializeOptions } from \"@/stores/utils/cookie\";\nimport { isTokenExpired, getTokenPayload } from \"@/stores/utils/jwt\";\n\nexport type AuthModel = { [key: string]: any } | null;\n\nexport type OnStoreChangeFunc = (token: string, model: AuthModel) => void;\n\nconst defaultCookieKey = \"pb_auth\";\n\n/**\n * Base AuthStore class that is intended to be extended by all other\n * PocketBase AuthStore implementations.\n */\nexport abstract class BaseAuthStore {\n    protected baseToken: string = \"\";\n    protected baseModel: AuthModel = null;\n\n    private _onChangeCallbacks: Array<OnStoreChangeFunc> = [];\n\n    /**\n     * Retrieves the stored token (if any).\n     */\n    get token(): string {\n        return this.baseToken;\n    }\n\n    /**\n     * Retrieves the stored model data (if any).\n     */\n    get model(): AuthModel {\n        return this.baseModel;\n    }\n\n    /**\n     * Loosely checks if the store has valid token (aka. existing and unexpired exp claim).\n     */\n    get isValid(): boolean {\n        return !isTokenExpired(this.token);\n    }\n\n    /**\n     * Checks whether the current store state is for admin authentication.\n     */\n    get isAdmin(): boolean {\n        return getTokenPayload(this.token).type === \"admin\";\n    }\n\n    /**\n     * Checks whether the current store state is for auth record authentication.\n     */\n    get isAuthRecord(): boolean {\n        return getTokenPayload(this.token).type === \"authRecord\";\n    }\n\n    /**\n     * Saves the provided new token and model data in the auth store.\n     */\n    save(token: string, model?: AuthModel): void {\n        this.baseToken = token || \"\";\n        this.baseModel = model || null;\n\n        this.triggerChange();\n    }\n\n    /**\n     * Removes the stored token and model data form the auth store.\n     */\n    clear(): void {\n        this.baseToken = \"\";\n        this.baseModel = null;\n        this.triggerChange();\n    }\n\n    /**\n     * Parses the provided cookie string and updates the store state\n     * with the cookie's token and model data.\n     *\n     * NB! This function doesn't validate the token or its data.\n     * Usually this isn't a concern if you are interacting only with the\n     * PocketBase API because it has the proper server-side security checks in place,\n     * but if you are using the store `isValid` state for permission controls\n     * in a node server (eg. SSR), then it is recommended to call `authRefresh()`\n     * after loading the cookie to ensure an up-to-date token and model state.\n     * For example:\n     *\n     * ```js\n     * pb.authStore.loadFromCookie(\"cookie string...\");\n     *\n     * try {\n     *     // get an up-to-date auth store state by veryfing and refreshing the loaded auth model (if any)\n     *     pb.authStore.isValid && await pb.collection('users').authRefresh();\n     * } catch (_) {\n     *     // clear the auth store on failed refresh\n     *     pb.authStore.clear();\n     * }\n     * ```\n     */\n    loadFromCookie(cookie: string, key = defaultCookieKey): void {\n        const rawData = cookieParse(cookie || \"\")[key] || \"\";\n\n        let data: { [key: string]: any } = {};\n        try {\n            data = JSON.parse(rawData);\n            // normalize\n            if (typeof data === null || typeof data !== \"object\" || Array.isArray(data)) {\n                data = {};\n            }\n        } catch (_) {}\n\n        this.save(data.token || \"\", data.model || null);\n    }\n\n    /**\n     * Exports the current store state as cookie string.\n     *\n     * By default the following optional attributes are added:\n     * - Secure\n     * - HttpOnly\n     * - SameSite=Strict\n     * - Path=/\n     * - Expires={the token expiration date}\n     *\n     * NB! If the generated cookie exceeds 4096 bytes, this method will\n     * strip the model data to the bare minimum to try to fit within the\n     * recommended size in https://www.rfc-editor.org/rfc/rfc6265#section-6.1.\n     */\n    exportToCookie(options?: SerializeOptions, key = defaultCookieKey): string {\n        const defaultOptions: SerializeOptions = {\n            secure: true,\n            sameSite: true,\n            httpOnly: true,\n            path: \"/\",\n        };\n\n        // extract the token expiration date\n        const payload = getTokenPayload(this.token);\n        if (payload?.exp) {\n            defaultOptions.expires = new Date(payload.exp * 1000);\n        } else {\n            defaultOptions.expires = new Date(\"1970-01-01\");\n        }\n\n        // merge with the user defined options\n        options = Object.assign({}, defaultOptions, options);\n\n        const rawData = {\n            token: this.token,\n            model: this.model ? JSON.parse(JSON.stringify(this.model)) : null,\n        };\n\n        let result = cookieSerialize(key, JSON.stringify(rawData), options);\n\n        const resultLength =\n            typeof Blob !== \"undefined\" ? new Blob([result]).size : result.length;\n\n        // strip down the model data to the bare minimum\n        if (rawData.model && resultLength > 4096) {\n            rawData.model = { id: rawData?.model?.id, email: rawData?.model?.email };\n            const extraProps = [\"collectionId\", \"username\", \"verified\"];\n            for (const prop in this.model) {\n                if (extraProps.includes(prop)) {\n                    rawData.model[prop] = this.model[prop];\n                }\n            }\n            result = cookieSerialize(key, JSON.stringify(rawData), options);\n        }\n\n        return result;\n    }\n\n    /**\n     * Register a callback function that will be called on store change.\n     *\n     * You can set the `fireImmediately` argument to true in order to invoke\n     * the provided callback right after registration.\n     *\n     * Returns a removal function that you could call to \"unsubscribe\" from the changes.\n     */\n    onChange(callback: OnStoreChangeFunc, fireImmediately = false): () => void {\n        this._onChangeCallbacks.push(callback);\n\n        if (fireImmediately) {\n            callback(this.token, this.model);\n        }\n\n        return () => {\n            for (let i = this._onChangeCallbacks.length - 1; i >= 0; i--) {\n                if (this._onChangeCallbacks[i] == callback) {\n                    delete this._onChangeCallbacks[i]; // removes the function reference\n                    this._onChangeCallbacks.splice(i, 1); // reindex the array\n                    return;\n                }\n            }\n        };\n    }\n\n    protected triggerChange(): void {\n        for (const callback of this._onChangeCallbacks) {\n            callback && callback(this.token, this.model);\n        }\n    }\n}\n","import { BaseAuthStore, AuthModel } from \"@/stores/BaseAuthStore\";\n\n/**\n * The default token store for browsers with auto fallback\n * to runtime/memory if local storage is undefined (eg. in node env).\n */\nexport class LocalAuthStore extends BaseAuthStore {\n    private storageFallback: { [key: string]: any } = {};\n    private storageKey: string;\n\n    constructor(storageKey = \"pocketbase_auth\") {\n        super();\n\n        this.storageKey = storageKey;\n\n        this._bindStorageEvent();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get token(): string {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.token || \"\";\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get model(): AuthModel {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.model || null;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, model?: AuthModel) {\n        this._storageSet(this.storageKey, {\n            token: token,\n            model: model,\n        });\n\n        super.save(token, model);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear() {\n        this._storageRemove(this.storageKey);\n\n        super.clear();\n    }\n\n    // ---------------------------------------------------------------\n    // Internal helpers:\n    // ---------------------------------------------------------------\n\n    /**\n     * Retrieves `key` from the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageGet(key: string): any {\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            const rawValue = window.localStorage.getItem(key) || \"\";\n            try {\n                return JSON.parse(rawValue);\n            } catch (e) {\n                // not a json\n                return rawValue;\n            }\n        }\n\n        // fallback\n        return this.storageFallback[key];\n    }\n\n    /**\n     * Stores a new data in the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageSet(key: string, value: any) {\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            // store in local storage\n            let normalizedVal = value;\n            if (typeof value !== \"string\") {\n                normalizedVal = JSON.stringify(value);\n            }\n            window.localStorage.setItem(key, normalizedVal);\n        } else {\n            // store in fallback\n            this.storageFallback[key] = value;\n        }\n    }\n\n    /**\n     * Removes `key` from the browser's local storage and the runtime/memory.\n     */\n    private _storageRemove(key: string) {\n        // delete from local storage\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            window.localStorage?.removeItem(key);\n        }\n\n        // delete from fallback\n        delete this.storageFallback[key];\n    }\n\n    /**\n     * Updates the current store state on localStorage change.\n     */\n    private _bindStorageEvent() {\n        if (\n            typeof window === \"undefined\" ||\n            !window?.localStorage ||\n            !window.addEventListener\n        ) {\n            return;\n        }\n\n        window.addEventListener(\"storage\", (e) => {\n            if (e.key != this.storageKey) {\n                return;\n            }\n\n            const data = this._storageGet(this.storageKey) || {};\n\n            super.save(data.token || \"\", data.model || null);\n        });\n    }\n}\n","import Client from \"@/Client\";\n\n/**\n * BaseService class that should be inherited from all API services.\n */\nexport abstract class BaseService {\n    readonly client: Client;\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n}\n","import { BaseService } from \"@/services/utils/BaseService\";\nimport { CommonOptions } from \"@/services/utils/options\";\n\ninterface appleClientSecret {\n    secret: string;\n}\n\nexport class SettingsService extends BaseService {\n    /**\n     * Fetch all available app settings.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getAll(options?: CommonOptions): Promise<{ [key: string]: any }> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings\", options);\n    }\n\n    /**\n     * Bulk updates app settings.\n     *\n     * @throws {ClientResponseError}\n     */\n    async update(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings\", options);\n    }\n\n    /**\n     * Performs a S3 filesystem connection test.\n     *\n     * The currently supported `filesystem` are \"storage\" and \"backups\".\n     *\n     * @throws {ClientResponseError}\n     */\n    async testS3(\n        filesystem: string = \"storage\",\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    filesystem: filesystem,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/test/s3\", options).then(() => true);\n    }\n\n    /**\n     * Sends a test email.\n     *\n     * The possible `emailTemplate` values are:\n     * - verification\n     * - password-reset\n     * - email-change\n     *\n     * @throws {ClientResponseError}\n     */\n    async testEmail(\n        toEmail: string,\n        emailTemplate: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    email: toEmail,\n                    template: emailTemplate,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/test/email\", options).then(() => true);\n    }\n\n    /**\n     * Generates a new Apple OAuth2 client secret.\n     *\n     * @throws {ClientResponseError}\n     */\n    async generateAppleClientSecret(\n        clientId: string,\n        teamId: string,\n        keyId: string,\n        privateKey: string,\n        duration: number,\n        options?: CommonOptions,\n    ): Promise<appleClientSecret> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    clientId,\n                    teamId,\n                    keyId,\n                    privateKey,\n                    duration,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/apple/generate-client-secret\", options);\n    }\n}\n","import { BaseService } from \"@/services/utils/BaseService\";\nimport { ClientResponseError } from \"@/ClientResponseError\";\nimport { ListResult } from \"@/services/utils/dtos\";\nimport { CommonOptions, ListOptions, FullListOptions } from \"@/services/utils/options\";\n\nexport abstract class CrudService<M> extends BaseService {\n    /**\n     * Base path for the crud actions (without trailing slash, eg. '/admins').\n     */\n    abstract get baseCrudPath(): string;\n\n    /**\n     * Response data decoder.\n     */\n    decode<T = M>(data: { [key: string]: any }): T {\n        return data as T;\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once\n     * (by default 500 items per request; to change it set the `batch` query param).\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList<T = M>(options?: FullListOptions): Promise<Array<T>>;\n\n    /**\n     * Legacy version of getFullList with explicitly specified batch size.\n     */\n    async getFullList<T = M>(batch?: number, options?: ListOptions): Promise<Array<T>>;\n\n    async getFullList<T = M>(\n        batchOrqueryParams?: number | FullListOptions,\n        options?: ListOptions,\n    ): Promise<Array<T>> {\n        if (typeof batchOrqueryParams == \"number\") {\n            return this._getFullList<T>(batchOrqueryParams, options);\n        }\n\n        options = Object.assign({}, batchOrqueryParams, options);\n\n        let batch = 500;\n        if (options.batch) {\n            batch = options.batch;\n            delete options.batch;\n        }\n\n        return this._getFullList<T>(batch, options);\n    }\n\n    /**\n     * Returns paginated items list.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getList<T = M>(\n        page = 1,\n        perPage = 30,\n        options?: ListOptions,\n    ): Promise<ListResult<T>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        options.query = Object.assign(\n            {\n                page: page,\n                perPage: perPage,\n            },\n            options.query,\n        );\n\n        return this.client.send(this.baseCrudPath, options).then((responseData: any) => {\n            responseData.items =\n                responseData.items?.map((item: any) => {\n                    return this.decode<T>(item);\n                }) || [];\n\n            return responseData;\n        });\n    }\n\n    /**\n     * Returns the first found item by the specified filter.\n     *\n     * Internally it calls `getList(1, 1, { filter, skipTotal })` and\n     * returns the first found item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * For consistency with `getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFirstListItem<T = M>(filter: string, options?: CommonOptions): Promise<T> {\n        options = Object.assign(\n            {\n                requestKey: \"one_by_filter_\" + this.baseCrudPath + \"_\" + filter,\n            },\n            options,\n        );\n\n        options.query = Object.assign(\n            {\n                filter: filter,\n                skipTotal: 1,\n            },\n            options.query,\n        );\n\n        return this.getList<T>(1, 1, options).then((result) => {\n            if (!result?.items?.length) {\n                throw new ClientResponseError({\n                    status: 404,\n                    response: {\n                        code: 404,\n                        message: \"The requested resource wasn't found.\",\n                        data: {},\n                    },\n                });\n            }\n\n            return result.items[0];\n        });\n    }\n\n    /**\n     * Returns single item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * If `id` is empty it will throw a 404 error.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getOne<T = M>(id: string, options?: CommonOptions): Promise<T> {\n        if (!id) {\n            throw new ClientResponseError({\n                url: this.client.buildUrl(this.baseCrudPath + \"/\"),\n                status: 404,\n                response: {\n                    code: 404,\n                    message: \"Missing required record id.\",\n                    data: {},\n                },\n            });\n        }\n\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Creates a new item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async create<T = M>(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath, options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Updates an existing item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async update<T = M>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     *\n     * @throws {ClientResponseError}\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then(() => true);\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     */\n    protected _getFullList<T = M>(\n        batchSize = 500,\n        options?: ListOptions,\n    ): Promise<Array<T>> {\n        options = options || {};\n        options.query = Object.assign(\n            {\n                skipTotal: 1,\n            },\n            options.query,\n        );\n\n        let result: Array<T> = [];\n\n        let request = async (page: number): Promise<Array<any>> => {\n            return this.getList(page, batchSize || 500, options).then((list) => {\n                const castedList = list as any as ListResult<T>;\n                const items = castedList.items;\n\n                result = result.concat(items);\n\n                if (items.length == list.perPage) {\n                    return request(page + 1);\n                }\n\n                return result;\n            });\n        };\n\n        return request(1);\n    }\n}\n","import { SendOptions } from \"@/services/utils/options\";\n\nexport function normalizeLegacyOptionsArgs(\n    legacyWarn: string,\n    baseOptions: SendOptions,\n    bodyOrOptions?: any,\n    query?: any,\n): SendOptions {\n    const hasBodyOrOptions = typeof bodyOrOptions !== \"undefined\";\n    const hasQuery = typeof query !== \"undefined\";\n\n    if (!hasQuery && !hasBodyOrOptions) {\n        return baseOptions;\n    }\n\n    if (hasQuery) {\n        console.warn(legacyWarn);\n        baseOptions.body = Object.assign({}, baseOptions.body, bodyOrOptions);\n        baseOptions.query = Object.assign({}, baseOptions.query, query);\n\n        return baseOptions;\n    }\n\n    return Object.assign(baseOptions, bodyOrOptions);\n}\n","import Client from \"@/Client\";\nimport { isTokenExpired } from \"@/stores/utils/jwt\";\n\n// reset previous auto refresh registrations\nexport function resetAutoRefresh(client: Client) {\n    (client as any)._resetAutoRefresh?.();\n}\n\nexport function registerAutoRefresh(\n    client: Client,\n    threshold: number,\n    refreshFunc: () => Promise<any>,\n    reauthenticateFunc: () => Promise<any>,\n) {\n    resetAutoRefresh(client);\n\n    const oldBeforeSend = client.beforeSend;\n    const oldModel = client.authStore.model;\n\n    // unset the auto refresh in case the auth store was cleared\n    // OR a new model was authenticated\n    const unsubStoreChange = client.authStore.onChange((newToken, model) => {\n        if (\n            !newToken ||\n            model?.id != oldModel?.id ||\n            // check the collection id in case an admin and auth record share the same id\n            ((model?.collectionId || oldModel?.collectionId) &&\n                model?.collectionId != oldModel?.collectionId)\n        ) {\n            resetAutoRefresh(client);\n        }\n    });\n\n    // initialize a reset function and attach it dynamically to the client\n    (client as any)._resetAutoRefresh = function () {\n        unsubStoreChange();\n        client.beforeSend = oldBeforeSend;\n        delete (client as any)._resetAutoRefresh;\n    };\n\n    client.beforeSend = async (url, sendOptions) => {\n        const oldToken = client.authStore.token;\n\n        if (sendOptions.query?.autoRefresh) {\n            return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n        }\n\n        let isValid = client.authStore.isValid;\n        if (\n            // is loosely valid\n            isValid &&\n            // but it is going to expire in the next \"threshold\" seconds\n            isTokenExpired(client.authStore.token, threshold)\n        ) {\n            try {\n                await refreshFunc();\n            } catch (_) {\n                isValid = false;\n            }\n        }\n\n        // still invalid -> reauthenticate\n        if (!isValid) {\n            await reauthenticateFunc();\n        }\n\n        // the request wasn't sent with a custom token\n        const headers = sendOptions.headers || {};\n        for (let key in headers) {\n            if (\n                key.toLowerCase() == \"authorization\" &&\n                // the request wasn't sent with a custom token\n                oldToken == headers[key] &&\n                client.authStore.token\n            ) {\n                // set the latest store token\n                headers[key] = client.authStore.token;\n                break;\n            }\n        }\n        sendOptions.headers = headers;\n\n        return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n    };\n}\n","import { CrudService } from \"@/services/utils/CrudService\";\nimport { AdminModel } from \"@/services/utils/dtos\";\nimport { AuthOptions, CommonOptions } from \"@/services/utils/options\";\nimport { normalizeLegacyOptionsArgs } from \"@/services/utils/legacy\";\nimport { registerAutoRefresh, resetAutoRefresh } from \"@/services/utils/refresh\";\n\nexport interface AdminAuthResponse {\n    [key: string]: any;\n\n    token: string;\n    admin: AdminModel;\n}\n\nexport class AdminService extends CrudService<AdminModel> {\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return \"/api/admins\";\n    }\n\n    // ---------------------------------------------------------------\n    // Post update/delete AuthStore sync\n    // ---------------------------------------------------------------\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    async update<T = AdminModel>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        return super.update(id, bodyParams, options).then((item) => {\n            // update the store state if the updated item id matches with the stored model\n            if (\n                this.client.authStore.model?.id === item.id &&\n                typeof this.client.authStore.model?.collectionId === \"undefined\" // is not record auth\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        return super.delete(id, options).then((success) => {\n            // clear the store state if the deleted item id matches with the stored model\n            if (\n                success &&\n                this.client.authStore.model?.id === id &&\n                typeof this.client.authStore.model?.collectionId === \"undefined\" // is not record auth\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful authorize response.\n     */\n    protected authResponse(responseData: any): AdminAuthResponse {\n        const admin = this.decode(responseData?.admin || {});\n\n        if (responseData?.token && responseData?.admin) {\n            this.client.authStore.save(responseData.token, admin);\n        }\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            token: responseData?.token || \"\",\n            admin: admin,\n        });\n    }\n\n    /**\n     * Authenticate an admin account with its email and password\n     * and returns a new admin token and data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithPassword(\n        email: string,\n        password: string,\n        options?: AuthOptions,\n    ): Promise<AdminAuthResponse>;\n\n    /**\n     * @deprecated\n     * Consider using authWithPassword(email, password, options?).\n     */\n    async authWithPassword(\n        email: string,\n        password: string,\n        body?: any,\n        query?: any,\n    ): Promise<AdminAuthResponse>;\n\n    async authWithPassword(\n        email: string,\n        password: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<AdminAuthResponse> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                identity: email,\n                password: password,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authWithPassword(email, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(email, pass, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        const autoRefreshThreshold = options.autoRefreshThreshold;\n        delete options.autoRefreshThreshold;\n\n        // not from auto refresh reauthentication\n        if (!options.autoRefresh) {\n            resetAutoRefresh(this.client);\n        }\n\n        let authData = await this.client.send(\n            this.baseCrudPath + \"/auth-with-password\",\n            options,\n        );\n\n        authData = this.authResponse(authData);\n\n        if (autoRefreshThreshold) {\n            registerAutoRefresh(\n                this.client,\n                autoRefreshThreshold,\n                () => this.authRefresh({ autoRefresh: true }),\n                () =>\n                    this.authWithPassword(\n                        email,\n                        password,\n                        Object.assign({ autoRefresh: true }, options),\n                    ),\n            );\n        }\n\n        return authData;\n    }\n\n    /**\n     * Refreshes the current admin authenticated instance and\n     * returns a new token and admin data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     *\n     * @throws {ClientResponseError}\n     */\n    async authRefresh(options?: CommonOptions): Promise<AdminAuthResponse>;\n\n    /**\n     * @deprecated\n     * Consider using authRefresh(options?).\n     */\n    async authRefresh(body?: any, query?: any): Promise<AdminAuthResponse>;\n\n    async authRefresh(bodyOrOptions?: any, query?: any): Promise<AdminAuthResponse> {\n        let options: any = {\n            method: \"POST\",\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/auth-refresh\", options)\n            .then(this.authResponse.bind(this));\n    }\n\n    /**\n     * Sends admin password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestPasswordReset(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestPasswordReset(email, options?).\n     */\n    async requestPasswordReset(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestPasswordReset(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/request-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms admin password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmPasswordReset(\n        resetToken: string,\n        password: string,\n        passwordConfirm: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmPasswordReset(resetToken, password, passwordConfirm, options?).\n     */\n    async confirmPasswordReset(\n        resetToken: string,\n        password: string,\n        passwordConfirm: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmPasswordReset(\n        resetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: resetToken,\n                password: password,\n                passwordConfirm: passwordConfirm,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmPasswordReset(resetToken, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(resetToken, password, passwordConfirm, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/confirm-password-reset\", options)\n            .then(() => true);\n    }\n}\n","export interface SendOptions extends RequestInit {\n    // for backward compatibility and to minimize the verbosity,\n    // any top-level field that doesn't exist in RequestInit or the\n    // fields below will be treated as query parameter.\n    [key: string]: any;\n\n    /**\n     * Optional custom fetch function to use for sending the request.\n     */\n    fetch?: (url: RequestInfo | URL, config?: RequestInit) => Promise<Response>;\n\n    /**\n     * Custom headers to send with the requests.\n     */\n    headers?: { [key: string]: string };\n\n    /**\n     * The body of the request (serialized automatically for json requests).\n     */\n    body?: any;\n\n    /**\n     * Query parameters that will be appended to the request url.\n     */\n    query?: { [key: string]: any };\n\n    /**\n     * @deprecated use `query` instead\n     *\n     * for backward-compatibility `params` values are merged with `query`,\n     * but this option may get removed in the final v1 release\n     */\n    params?: { [key: string]: any };\n\n    /**\n     * The request identifier that can be used to cancel pending requests.\n     */\n    requestKey?: string | null;\n\n    /**\n     * @deprecated use `requestKey:string` instead\n     */\n    $cancelKey?: string;\n\n    /**\n     * @deprecated use `requestKey:null` instead\n     */\n    $autoCancel?: boolean;\n}\n\nexport interface CommonOptions extends SendOptions {\n    fields?: string;\n}\n\nexport interface ListOptions extends CommonOptions {\n    page?: number;\n    perPage?: number;\n    sort?: string;\n    filter?: string;\n    skipTotal?: boolean;\n}\n\nexport interface FullListOptions extends ListOptions {\n    batch?: number;\n}\n\nexport interface RecordOptions extends CommonOptions {\n    expand?: string;\n}\n\nexport interface RecordListOptions extends ListOptions, RecordOptions {}\n\nexport interface RecordFullListOptions extends FullListOptions, RecordOptions {}\n\nexport interface LogStatsOptions extends CommonOptions {\n    filter?: string;\n}\n\nexport interface FileOptions extends CommonOptions {\n    thumb?: string;\n    download?: boolean;\n}\n\nexport interface AuthOptions extends CommonOptions {\n    /**\n     * If autoRefreshThreshold is set it will take care to auto refresh\n     * when necessary the auth data before each request to ensure that\n     * the auth state is always valid.\n     *\n     * The value must be in seconds, aka. the amount of seconds\n     * that will be subtracted from the current token `exp` claim in order\n     * to determine whether it is going to expire within the specified time threshold.\n     *\n     * For example, if you want to auto refresh the token if it is\n     * going to expire in the next 30mins (or already has expired),\n     * it can be set to `1800`\n     */\n    autoRefreshThreshold?: number;\n}\n\n// -------------------------------------------------------------------\n\n// list of known SendOptions keys (everything else is treated as query param)\nconst knownSendOptionsKeys = [\n    \"requestKey\",\n    \"$cancelKey\",\n    \"$autoCancel\",\n    \"fetch\",\n    \"headers\",\n    \"body\",\n    \"query\",\n    \"params\",\n    // ---,\n    \"cache\",\n    \"credentials\",\n    \"headers\",\n    \"integrity\",\n    \"keepalive\",\n    \"method\",\n    \"mode\",\n    \"redirect\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"signal\",\n    \"window\",\n];\n\n// modifies in place the provided options by moving unknown send options as query parameters.\nexport function normalizeUnknownQueryParams(options?: SendOptions): void {\n    if (!options) {\n        return;\n    }\n\n    options.query = options.query || {};\n    for (let key in options) {\n        if (knownSendOptionsKeys.includes(key)) {\n            continue;\n        }\n\n        options.query[key] = options[key];\n        delete options[key];\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseService } from \"@/services/utils/BaseService\";\nimport { SendOptions, normalizeUnknownQueryParams } from \"@/services/utils/options\";\n\ninterface promiseCallbacks {\n    resolve: Function;\n    reject: Function;\n}\n\ntype Subscriptions = { [key: string]: Array<EventListener> };\n\nexport type UnsubscribeFunc = () => Promise<void>;\n\nexport class RealtimeService extends BaseService {\n    clientId: string = \"\";\n\n    private eventSource: EventSource | null = null;\n    private subscriptions: Subscriptions = {};\n    private lastSentSubscriptions: Array<string> = [];\n    private connectTimeoutId: any;\n    private maxConnectTimeout: number = 15000;\n    private reconnectTimeoutId: any;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = Infinity;\n    private predefinedReconnectIntervals: Array<number> = [\n        200, 300, 500, 1000, 1200, 1500, 2000,\n    ];\n    private pendingConnects: Array<promiseCallbacks> = [];\n\n    /**\n     * Returns whether the realtime connection has been established.\n     */\n    get isConnected(): boolean {\n        return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\n    }\n\n    /**\n     * Register the subscription listener.\n     *\n     * You can subscribe multiple times to the same topic.\n     *\n     * If the SSE connection is not started yet,\n     * this method will also initialize it.\n     */\n    async subscribe(\n        topic: string,\n        callback: (data: any) => void,\n        options?: SendOptions,\n    ): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error(\"topic must be set.\");\n        }\n\n        let key = topic;\n\n        // serialize and append the topic options (if any)\n        if (options) {\n            normalizeUnknownQueryParams(options);\n            const serialized =\n                \"options=\" +\n                encodeURIComponent(\n                    JSON.stringify({ query: options.query, headers: options.headers }),\n                );\n            key += (key.includes(\"?\") ? \"&\" : \"?\") + serialized;\n        }\n\n        const listener = function (e: Event) {\n            const msgEvent = e as MessageEvent;\n\n            let data;\n            try {\n                data = JSON.parse(msgEvent?.data);\n            } catch {}\n\n            callback(data || {});\n        };\n\n        // store the listener\n        if (!this.subscriptions[key]) {\n            this.subscriptions[key] = [];\n        }\n        this.subscriptions[key].push(listener);\n\n        if (!this.isConnected) {\n            // initialize sse connection\n            await this.connect();\n        } else if (this.subscriptions[key].length === 1) {\n            // send the updated subscriptions (if it is the first for the key)\n            await this.submitSubscriptions();\n        } else {\n            // only register the listener\n            this.eventSource?.addEventListener(key, listener);\n        }\n\n        return async (): Promise<void> => {\n            return this.unsubscribeByTopicAndListener(topic, listener);\n        };\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners with the specified topic.\n     *\n     * If `topic` is not provided, then this method will unsubscribe\n     * from all active subscriptions.\n     *\n     * This method is no-op if there are no active subscriptions.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        let needToSubmit = false;\n\n        if (!topic) {\n            // remove all subscriptions\n            this.subscriptions = {};\n        } else {\n            // remove all listeners related to the topic\n            const subs = this.getSubscriptionsByTopic(topic);\n            for (let key in subs) {\n                if (!this.hasSubscriptionListeners(key)) {\n                    continue; // already unsubscribed\n                }\n\n                for (let listener of this.subscriptions[key]) {\n                    this.eventSource?.removeEventListener(key, listener);\n                }\n                delete this.subscriptions[key];\n\n                // mark for subscriptions change submit if there are no other listeners\n                if (!needToSubmit) {\n                    needToSubmit = true;\n                }\n            }\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (needToSubmit) {\n            await this.submitSubscriptions();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners starting with the specified topic prefix.\n     *\n     * This method is no-op if there are no active subscriptions with the specified topic prefix.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByPrefix(keyPrefix: string): Promise<void> {\n        let hasAtleastOneTopic = false;\n        for (let key in this.subscriptions) {\n            // \"?\" so that it can be used as end delimiter for the prefix\n            if (!(key + \"?\").startsWith(keyPrefix)) {\n                continue;\n            }\n\n            hasAtleastOneTopic = true;\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource?.removeEventListener(key, listener);\n            }\n            delete this.subscriptions[key];\n        }\n\n        if (!hasAtleastOneTopic) {\n            return; // nothing to unsubscribe from\n        }\n\n        if (this.hasSubscriptionListeners()) {\n            // submit the deleted subscriptions\n            await this.submitSubscriptions();\n        } else {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscriptions matching the specified topic and listener function.\n     *\n     * This method is no-op if there are no active subscription with\n     * the specified topic and listener.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByTopicAndListener(\n        topic: string,\n        listener: EventListener,\n    ): Promise<void> {\n        let needToSubmit = false;\n\n        const subs = this.getSubscriptionsByTopic(topic);\n        for (let key in subs) {\n            if (\n                !Array.isArray(this.subscriptions[key]) ||\n                !this.subscriptions[key].length\n            ) {\n                continue; // already unsubscribed\n            }\n\n            let exist = false;\n            for (let i = this.subscriptions[key].length - 1; i >= 0; i--) {\n                if (this.subscriptions[key][i] !== listener) {\n                    continue;\n                }\n\n                exist = true; // has at least one matching listener\n                delete this.subscriptions[key][i]; // removes the function reference\n                this.subscriptions[key].splice(i, 1); // reindex the array\n                this.eventSource?.removeEventListener(key, listener);\n            }\n            if (!exist) {\n                continue;\n            }\n\n            // remove the key from the subscriptions list if there are no other listeners\n            if (!this.subscriptions[key].length) {\n                delete this.subscriptions[key];\n            }\n\n            // mark for subscriptions change submit if there are no other listeners\n            if (!needToSubmit && !this.hasSubscriptionListeners(key)) {\n                needToSubmit = true;\n            }\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (needToSubmit) {\n            await this.submitSubscriptions();\n        }\n    }\n\n    private hasSubscriptionListeners(keyToCheck?: string): boolean {\n        this.subscriptions = this.subscriptions || {};\n\n        // check the specified key\n        if (keyToCheck) {\n            return !!this.subscriptions[keyToCheck]?.length;\n        }\n\n        // check for at least one non-empty subscription\n        for (let key in this.subscriptions) {\n            if (!!this.subscriptions[key]?.length) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private async submitSubscriptions(): Promise<void> {\n        if (!this.clientId) {\n            return; // no client/subscriber\n        }\n\n        // optimistic update\n        this.addAllSubscriptionListeners();\n\n        this.lastSentSubscriptions = this.getNonEmptySubscriptionKeys();\n\n        return this.client\n            .send(\"/api/realtime\", {\n                method: \"POST\",\n                body: {\n                    clientId: this.clientId,\n                    subscriptions: this.lastSentSubscriptions,\n                },\n                requestKey: this.getSubscriptionsCancelKey(),\n            })\n            .catch((err) => {\n                if (err?.isAbort) {\n                    return; // silently ignore aborted pending requests\n                }\n                throw err;\n            });\n    }\n\n    private getSubscriptionsCancelKey(): string {\n        return \"realtime_\" + this.clientId;\n    }\n\n    private getSubscriptionsByTopic(topic: string): Subscriptions {\n        const result: Subscriptions = {};\n\n        // \"?\" so that it can be used as end delimiter for the topic\n        topic = topic.includes(\"?\") ? topic : topic + \"?\";\n\n        for (let key in this.subscriptions) {\n            if ((key + \"?\").startsWith(topic)) {\n                result[key] = this.subscriptions[key];\n            }\n        }\n\n        return result;\n    }\n\n    private getNonEmptySubscriptionKeys(): Array<string> {\n        const result: Array<string> = [];\n\n        for (let key in this.subscriptions) {\n            if (this.subscriptions[key].length) {\n                result.push(key);\n            }\n        }\n\n        return result;\n    }\n\n    private addAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        this.removeAllSubscriptionListeners();\n\n        for (let key in this.subscriptions) {\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource.addEventListener(key, listener);\n            }\n        }\n    }\n\n    private removeAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        for (let key in this.subscriptions) {\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource.removeEventListener(key, listener);\n            }\n        }\n    }\n\n    private async connect(): Promise<void> {\n        if (this.reconnectAttempts > 0) {\n            // immediately resolve the promise to avoid indefinitely\n            // blocking the client during reconnection\n            return;\n        }\n\n        return new Promise((resolve, reject) => {\n            this.pendingConnects.push({ resolve, reject });\n\n            if (this.pendingConnects.length > 1) {\n                // all promises will be resolved once the connection is established\n                return;\n            }\n\n            this.initConnect();\n        });\n    }\n\n    private initConnect() {\n        this.disconnect(true);\n\n        // wait up to 15s for connect\n        clearTimeout(this.connectTimeoutId);\n        this.connectTimeoutId = setTimeout(() => {\n            this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\n        }, this.maxConnectTimeout);\n\n        this.eventSource = new EventSource(this.client.buildUrl(\"/api/realtime\"));\n\n        this.eventSource.onerror = (_) => {\n            this.connectErrorHandler(\n                new Error(\"Failed to establish realtime connection.\"),\n            );\n        };\n\n        this.eventSource.addEventListener(\"PB_CONNECT\", (e) => {\n            const msgEvent = e as MessageEvent;\n            this.clientId = msgEvent?.lastEventId;\n\n            this.submitSubscriptions()\n                .then(async () => {\n                    let retries = 3;\n                    while (this.hasUnsentSubscriptions() && retries > 0) {\n                        retries--;\n                        // resubscribe to ensure that the latest topics are submitted\n                        //\n                        // This is needed because missed topics could happen on reconnect\n                        // if after the pending sent `submitSubscriptions()` call another `subscribe()`\n                        // was made before the submit was able to complete.\n                        await this.submitSubscriptions();\n                    }\n                })\n                .then(() => {\n                    for (let p of this.pendingConnects) {\n                        p.resolve();\n                    }\n\n                    // reset connect meta\n                    this.pendingConnects = [];\n                    this.reconnectAttempts = 0;\n                    clearTimeout(this.reconnectTimeoutId);\n                    clearTimeout(this.connectTimeoutId);\n\n                    // propagate the PB_CONNECT event\n                    const connectSubs = this.getSubscriptionsByTopic(\"PB_CONNECT\");\n                    for (let key in connectSubs) {\n                        for (let listener of connectSubs[key]) {\n                            listener(e);\n                        }\n                    }\n                })\n                .catch((err) => {\n                    this.clientId = \"\";\n                    this.connectErrorHandler(err);\n                });\n        });\n    }\n\n    private hasUnsentSubscriptions(): boolean {\n        const latestTopics = this.getNonEmptySubscriptionKeys();\n        if (latestTopics.length != this.lastSentSubscriptions.length) {\n            return true;\n        }\n\n        for (const t of latestTopics) {\n            if (!this.lastSentSubscriptions.includes(t)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private connectErrorHandler(err: any) {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n\n        if (\n            // wasn't previously connected -> direct reject\n            (!this.clientId && !this.reconnectAttempts) ||\n            // was previously connected but the max reconnection limit has been reached\n            this.reconnectAttempts > this.maxReconnectAttempts\n        ) {\n            for (let p of this.pendingConnects) {\n                p.reject(new ClientResponseError(err));\n            }\n            this.pendingConnects = [];\n            this.disconnect();\n            return;\n        }\n\n        // otherwise -> reconnect in the background\n        this.disconnect(true);\n        const timeout =\n            this.predefinedReconnectIntervals[this.reconnectAttempts] ||\n            this.predefinedReconnectIntervals[\n                this.predefinedReconnectIntervals.length - 1\n            ];\n        this.reconnectAttempts++;\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.initConnect();\n        }, timeout);\n    }\n\n    private disconnect(fromReconnect = false): void {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n        this.removeAllSubscriptionListeners();\n        this.client.cancelRequest(this.getSubscriptionsCancelKey());\n        this.eventSource?.close();\n        this.eventSource = null;\n        this.clientId = \"\";\n\n        if (!fromReconnect) {\n            this.reconnectAttempts = 0;\n\n            // resolve any remaining connect promises\n            //\n            // this is done to avoid unnecessary throwing errors in case\n            // unsubscribe is called before the pending connect promises complete\n            // (see https://github.com/pocketbase/pocketbase/discussions/2897#discussioncomment-6423818)\n            for (let p of this.pendingConnects) {\n                p.resolve();\n            }\n            this.pendingConnects = [];\n        }\n    }\n}\n","import Client from \"@/Client\";\nimport { getTokenPayload } from \"@/stores/utils/jwt\";\nimport { CrudService } from \"@/services/utils/CrudService\";\nimport { RealtimeService, UnsubscribeFunc } from \"@/services/RealtimeService\";\nimport { ClientResponseError } from \"@/ClientResponseError\";\nimport { ListResult, RecordModel, ExternalAuthModel } from \"@/services/utils/dtos\";\nimport {\n    SendOptions,\n    CommonOptions,\n    RecordOptions,\n    RecordListOptions,\n    RecordFullListOptions,\n} from \"@/services/utils/options\";\nimport { normalizeLegacyOptionsArgs } from \"@/services/utils/legacy\";\n\nexport interface RecordAuthResponse<T = RecordModel> {\n    /**\n     * The signed PocketBase auth record.\n     */\n    record: T;\n\n    /**\n     * The PocketBase record auth token.\n     *\n     * If you are looking for the OAuth2 access and refresh tokens\n     * they are available under the `meta.accessToken` and `meta.refreshToken` props.\n     */\n    token: string;\n\n    /**\n     * Auth meta data usually filled when OAuth2 is used.\n     */\n    meta?: { [key: string]: any };\n}\n\nexport interface AuthProviderInfo {\n    name: string;\n    displayName: string;\n    state: string;\n    authUrl: string;\n    codeVerifier: string;\n    codeChallenge: string;\n    codeChallengeMethod: string;\n}\n\nexport interface AuthMethodsList {\n    usernamePassword: boolean;\n    emailPassword: boolean;\n    onlyVerified: boolean;\n    authProviders: Array<AuthProviderInfo>;\n}\n\nexport interface RecordSubscription<T = RecordModel> {\n    action: string; // eg. create, update, delete\n    record: T;\n}\n\nexport type OAuth2UrlCallback = (url: string) => void | Promise<void>;\n\nexport interface OAuth2AuthConfig extends SendOptions {\n    // the name of the OAuth2 provider (eg. \"google\")\n    provider: string;\n\n    // custom scopes to overwrite the default ones\n    scopes?: Array<string>;\n\n    // optional record create data\n    createData?: { [key: string]: any };\n\n    // optional callback that is triggered after the OAuth2 sign-in/sign-up url generation\n    urlCallback?: OAuth2UrlCallback;\n\n    // optional query params to send with the PocketBase auth request (eg. fields, expand, etc.)\n    query?: RecordOptions;\n}\n\nexport class RecordService<M = RecordModel> extends CrudService<M> {\n    readonly collectionIdOrName: string;\n\n    constructor(client: Client, collectionIdOrName: string) {\n        super(client);\n\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return this.baseCollectionPath + \"/records\";\n    }\n\n    /**\n     * Returns the current collection service base path.\n     */\n    get baseCollectionPath(): string {\n        return \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Realtime handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Subscribe to realtime changes to the specified topic (\"*\" or record id).\n     *\n     * If `topic` is the wildcard \"*\", then this method will subscribe to\n     * any record changes in the collection.\n     *\n     * If `topic` is a record id, then this method will subscribe only\n     * to changes of the specified record id.\n     *\n     * It's OK to subscribe multiple times to the same topic.\n     * You can use the returned `UnsubscribeFunc` to remove only a single subscription.\n     * Or use `unsubscribe(topic)` if you want to remove all subscriptions attached to the topic.\n     */\n    async subscribe<T = M>(\n        topic: string,\n        callback: (data: RecordSubscription<T>) => void,\n        options?: SendOptions,\n    ): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error(\"Missing topic.\");\n        }\n\n        if (!callback) {\n            throw new Error(\"Missing subscription callback.\");\n        }\n\n        return this.client.realtime.subscribe(\n            this.collectionIdOrName + \"/\" + topic,\n            callback,\n            options,\n        );\n    }\n\n    /**\n     * Unsubscribe from all subscriptions of the specified topic\n     * (\"*\" or record id).\n     *\n     * If `topic` is not set, then this method will unsubscribe from\n     * all subscriptions associated to the current collection.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        // unsubscribe from the specified topic\n        if (topic) {\n            return this.client.realtime.unsubscribe(\n                this.collectionIdOrName + \"/\" + topic,\n            );\n        }\n\n        // unsubscribe from everything related to the collection\n        return this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Crud handers\n    // ---------------------------------------------------------------\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(options?: RecordFullListOptions): Promise<Array<T>>;\n\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(\n        batch?: number,\n        options?: RecordListOptions,\n    ): Promise<Array<T>>;\n\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(\n        batchOrOptions?: number | RecordFullListOptions,\n        options?: RecordListOptions,\n    ): Promise<Array<T>> {\n        if (typeof batchOrOptions == \"number\") {\n            return super.getFullList<T>(batchOrOptions, options);\n        }\n\n        const params = Object.assign({}, batchOrOptions, options);\n\n        return super.getFullList<T>(params);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getList<T = M>(\n        page = 1,\n        perPage = 30,\n        options?: RecordListOptions,\n    ): Promise<ListResult<T>> {\n        return super.getList<T>(page, perPage, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getFirstListItem<T = M>(\n        filter: string,\n        options?: RecordListOptions,\n    ): Promise<T> {\n        return super.getFirstListItem<T>(filter, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getOne<T = M>(id: string, options?: RecordOptions): Promise<T> {\n        return super.getOne<T>(id, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async create<T = M>(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): Promise<T> {\n        return super.create<T>(bodyParams, options);\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    async update<T = M>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): Promise<T> {\n        return super.update<RecordModel>(id, bodyParams, options).then((item) => {\n            if (\n                // is record auth\n                this.client.authStore.model?.id === item?.id &&\n                (this.client.authStore.model?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.model?.collectionName ===\n                        this.collectionIdOrName)\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        return super.delete(id, options).then((success) => {\n            if (\n                success &&\n                // is record auth\n                this.client.authStore.model?.id === id &&\n                (this.client.authStore.model?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.model?.collectionName ===\n                        this.collectionIdOrName)\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful collection authorization response.\n     */\n    protected authResponse<T = M>(responseData: any): RecordAuthResponse<T> {\n        const record = this.decode(responseData?.record || {});\n\n        this.client.authStore.save(responseData?.token, record as any);\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            token: responseData?.token || \"\",\n            record: record as any as T,\n        });\n    }\n\n    /**\n     * Returns all available collection auth methods.\n     *\n     * @throws {ClientResponseError}\n     */\n    async listAuthMethods(options?: CommonOptions): Promise<AuthMethodsList> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-methods\", options)\n            .then((responseData: any) => {\n                return Object.assign({}, responseData, {\n                    // normalize common fields\n                    usernamePassword: !!responseData?.usernamePassword,\n                    emailPassword: !!responseData?.emailPassword,\n                    authProviders: Array.isArray(responseData?.authProviders)\n                        ? responseData?.authProviders\n                        : [],\n                });\n            });\n    }\n\n    /**\n     * Authenticate a single auth collection record via its username/email and password.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithPassword<T = M>(\n        usernameOrEmail: string,\n        password: string,\n        options?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authWithPassword(usernameOrEmail, password, options?).\n     */\n    async authWithPassword<T = M>(\n        usernameOrEmail: string,\n        password: string,\n        body?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>>;\n\n    async authWithPassword<T = M>(\n        usernameOrEmail: string,\n        password: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                identity: usernameOrEmail,\n                password: password,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authWithPassword(usernameOrEmail, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(usernameOrEmail, pass, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-with-password\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Authenticate a single auth collection record with OAuth2 code.\n     *\n     * If you don't have an OAuth2 code you may also want to check `authWithOAuth2` method.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: { [key: string]: any },\n        options?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createdData, options?).\n     */\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: { [key: string]: any },\n        body?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>>;\n\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: { [key: string]: any },\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                provider: provider,\n                code: code,\n                codeVerifier: codeVerifier,\n                redirectUrl: redirectUrl,\n                createData: createData,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-with-oauth2\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * @deprecated This form of authWithOAuth2 is deprecated.\n     *\n     * Please use `authWithOAuth2Code()` OR its simplified realtime version\n     * as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\n     */\n    async authWithOAuth2<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: { [key: string]: any },\n        bodyParams?: { [key: string]: any },\n        queryParams?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * Authenticate a single auth collection record with OAuth2\n     * **without custom redirects, deeplinks or even page reload**.\n     *\n     * This method initializes a one-off realtime subscription and will\n     * open a popup window with the OAuth2 vendor page to authenticate.\n     * Once the external OAuth2 sign-in/sign-up flow is completed, the popup\n     * window will be automatically closed and the OAuth2 data sent back\n     * to the user through the previously established realtime connection.\n     *\n     * You can specify an optional `urlCallback` prop to customize\n     * the default url `window.open` behavior.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * Example:\n     *\n     * ```js\n     * const authData = await pb.collection(\"users\").authWithOAuth2({\n     *     provider: \"google\",\n     * })\n     * ```\n     *\n     * _Site-note_: when creating the OAuth2 app in the provider dashboard\n     * you have to configure `https://yourdomain.com/api/oauth2-redirect`\n     * as redirect URL.\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOAuth2<T = M>(\n        options: OAuth2AuthConfig,\n    ): Promise<RecordAuthResponse<T>>;\n\n    async authWithOAuth2<T = M>(...args: any): Promise<RecordAuthResponse<T>> {\n        // fallback to legacy format\n        if (args.length > 1 || typeof args?.[0] === \"string\") {\n            console.warn(\n                \"PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\",\n            );\n            return this.authWithOAuth2Code<T>(\n                args?.[0] || \"\",\n                args?.[1] || \"\",\n                args?.[2] || \"\",\n                args?.[3] || \"\",\n                args?.[4] || {},\n                args?.[5] || {},\n                args?.[6] || {},\n            );\n        }\n\n        const config = args?.[0] || {};\n\n        const authMethods = await this.listAuthMethods();\n\n        const provider = authMethods.authProviders.find(\n            (p) => p.name === config.provider,\n        );\n        if (!provider) {\n            throw new ClientResponseError(\n                new Error(`Missing or invalid provider \"${config.provider}\".`),\n            );\n        }\n\n        const redirectUrl = this.client.buildUrl(\"/api/oauth2-redirect\");\n\n        // initialize a one-off realtime service\n        const realtime = new RealtimeService(this.client);\n\n        // open a new popup window in case config.urlCallback is not set\n        //\n        // note: it is opened before the async call due to Safari restrictions\n        // (see https://github.com/pocketbase/pocketbase/discussions/2429#discussioncomment-5943061)\n        let eagerDefaultPopup: Window | null = null;\n        if (!config.urlCallback) {\n            eagerDefaultPopup = openBrowserPopup(undefined);\n        }\n\n        function cleanup() {\n            eagerDefaultPopup?.close();\n            realtime.unsubscribe();\n        }\n\n        return new Promise(async (resolve, reject) => {\n            try {\n                await realtime.subscribe(\"@oauth2\", async (e) => {\n                    const oldState = realtime.clientId;\n\n                    try {\n                        if (!e.state || oldState !== e.state) {\n                            throw new Error(\"State parameters don't match.\");\n                        }\n\n                        if (e.error || !e.code) {\n                            throw new Error(\n                                \"OAuth2 redirect error or missing code: \" + e.error,\n                            );\n                        }\n\n                        // clear the non SendOptions props\n                        const options = Object.assign({}, config);\n                        delete options.provider;\n                        delete options.scopes;\n                        delete options.createData;\n                        delete options.urlCallback;\n\n                        const authData = await this.authWithOAuth2Code<T>(\n                            provider.name,\n                            e.code,\n                            provider.codeVerifier,\n                            redirectUrl,\n                            config.createData,\n                            options,\n                        );\n\n                        resolve(authData);\n                    } catch (err) {\n                        reject(new ClientResponseError(err));\n                    }\n\n                    cleanup();\n                });\n\n                const replacements: { [key: string]: any } = {\n                    state: realtime.clientId,\n                };\n                if (config.scopes?.length) {\n                    replacements[\"scope\"] = config.scopes.join(\" \");\n                }\n\n                const url = this._replaceQueryParams(\n                    provider.authUrl + redirectUrl,\n                    replacements,\n                );\n\n                let urlCallback =\n                    config.urlCallback ||\n                    function (url: string) {\n                        if (eagerDefaultPopup) {\n                            eagerDefaultPopup.location.href = url;\n                        } else {\n                            // it could have been blocked due to its empty initial url,\n                            // try again...\n                            eagerDefaultPopup = openBrowserPopup(url);\n                        }\n                    };\n\n                await urlCallback(url);\n            } catch (err) {\n                cleanup();\n                reject(new ClientResponseError(err));\n            }\n        });\n    }\n\n    /**\n     * Refreshes the current authenticated record instance and\n     * returns a new token and record data.\n     *\n     * On success this method also automatically updates the client's AuthStore.\n     *\n     * @throws {ClientResponseError}\n     */\n    async authRefresh<T = M>(options?: RecordOptions): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authRefresh(options?).\n     */\n    async authRefresh<T = M>(body?: any, query?: any): Promise<RecordAuthResponse<T>>;\n\n    async authRefresh<T = M>(\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-refresh\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Sends auth record password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestPasswordReset(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestPasswordReset(email, options?).\n     */\n    async requestPasswordReset(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestPasswordReset(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmPasswordReset(passwordResetToken, password, passwordConfirm, options?).\n     */\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: passwordResetToken,\n                password: password,\n                passwordConfirm: passwordConfirm,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Sends auth record verification email request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestVerification(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestVerification(email, options?).\n     */\n    async requestVerification(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestVerification(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-verification\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record email verification request.\n     *\n     * If the current `client.authStore.model` matches with the auth record from the token,\n     * then on success the `client.authStore.model.verified` will be updated to `true`.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmVerification(\n        verificationToken: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmVerification(verificationToken, options?).\n     */\n    async confirmVerification(\n        verificationToken: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmVerification(\n        verificationToken: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: verificationToken,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-verification\", options)\n            .then(() => {\n                // on success manually update the current auth record verified state\n                const payload = getTokenPayload(verificationToken);\n                const model = this.client.authStore.model;\n                if (\n                    model &&\n                    !model.verified &&\n                    model.id === payload.id &&\n                    model.collectionId === payload.collectionId\n                ) {\n                    model.verified = true;\n                    this.client.authStore.save(this.client.authStore.token, model);\n                }\n\n                return true;\n            });\n    }\n\n    /**\n     * Sends an email change request to the authenticated record model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestEmailChange(newEmail: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestEmailChange(newEmail, options?).\n     */\n    async requestEmailChange(newEmail: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestEmailChange(\n        newEmail: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                newEmail: newEmail,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-email-change\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record's new email address.\n     *\n     * If the current `client.authStore.model` matches with the auth record from the token,\n     * then on success the `client.authStore` will be cleared.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmEmailChange(emailChangeToken, password, options?).\n     */\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: emailChangeToken,\n                password: password,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-email-change\", options)\n            .then(() => {\n                const payload = getTokenPayload(emailChangeToken);\n                const model = this.client.authStore.model;\n                if (\n                    model &&\n                    model.id === payload.id &&\n                    model.collectionId === payload.collectionId\n                ) {\n                    this.client.authStore.clear();\n                }\n\n                return true;\n            });\n    }\n\n    /**\n     * Lists all linked external auth providers for the specified auth record.\n     *\n     * @throws {ClientResponseError}\n     */\n    async listExternalAuths(\n        recordId: string,\n        options?: CommonOptions,\n    ): Promise<Array<ExternalAuthModel>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\n            this.baseCrudPath + \"/\" + encodeURIComponent(recordId) + \"/external-auths\",\n            options,\n        );\n    }\n\n    /**\n     * Unlink a single external auth provider from the specified auth record.\n     *\n     * @throws {ClientResponseError}\n     */\n    async unlinkExternalAuth(\n        recordId: string,\n        provider: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(\n                this.baseCrudPath +\n                    \"/\" +\n                    encodeURIComponent(recordId) +\n                    \"/external-auths/\" +\n                    encodeURIComponent(provider),\n                options,\n            )\n            .then(() => true);\n    }\n\n    // ---------------------------------------------------------------\n\n    // very rudimentary url query params replacement because at the moment\n    // URL (and URLSearchParams) doesn't seem to be fully supported in React Native\n    //\n    // note: for details behind some of the decode/encode parsing check https://unixpapa.com/js/querystring.html\n    private _replaceQueryParams(\n        url: string,\n        replacements: { [key: string]: any } = {},\n    ): string {\n        let urlPath = url;\n        let query = \"\";\n\n        const queryIndex = url.indexOf(\"?\");\n        if (queryIndex >= 0) {\n            urlPath = url.substring(0, url.indexOf(\"?\"));\n            query = url.substring(url.indexOf(\"?\") + 1);\n        }\n\n        const parsedParams: { [key: string]: string } = {};\n\n        // parse the query parameters\n        const rawParams = query.split(\"&\");\n        for (const param of rawParams) {\n            if (param == \"\") {\n                continue;\n            }\n\n            const pair = param.split(\"=\");\n            parsedParams[decodeURIComponent(pair[0].replace(/\\+/g, \" \"))] =\n                decodeURIComponent((pair[1] || \"\").replace(/\\+/g, \" \"));\n        }\n\n        // apply the replacements\n        for (let key in replacements) {\n            if (!replacements.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (replacements[key] == null) {\n                delete parsedParams[key];\n            } else {\n                parsedParams[key] = replacements[key];\n            }\n        }\n\n        // construct back the full query string\n        query = \"\";\n        for (let key in parsedParams) {\n            if (!parsedParams.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (query != \"\") {\n                query += \"&\";\n            }\n\n            query +=\n                encodeURIComponent(key.replace(/%20/g, \"+\")) +\n                \"=\" +\n                encodeURIComponent(parsedParams[key].replace(/%20/g, \"+\"));\n        }\n\n        return query != \"\" ? urlPath + \"?\" + query : urlPath;\n    }\n}\n\nfunction openBrowserPopup(url?: string): Window | null {\n    if (typeof window === \"undefined\" || !window?.open) {\n        throw new ClientResponseError(\n            new Error(\n                `Not in a browser context - please pass a custom urlCallback function.`,\n            ),\n        );\n    }\n\n    let width = 1024;\n    let height = 768;\n\n    let windowWidth = window.innerWidth;\n    let windowHeight = window.innerHeight;\n\n    // normalize window size\n    width = width > windowWidth ? windowWidth : width;\n    height = height > windowHeight ? windowHeight : height;\n\n    let left = windowWidth / 2 - width / 2;\n    let top = windowHeight / 2 - height / 2;\n\n    // note: we don't use the noopener and noreferrer attributes since\n    // for some reason browser blocks such windows then url is undefined/blank\n    return window.open(\n        url,\n        \"popup_window\",\n        \"width=\" +\n            width +\n            \",height=\" +\n            height +\n            \",top=\" +\n            top +\n            \",left=\" +\n            left +\n            \",resizable,menubar=no\",\n    );\n}\n","import { CrudService } from \"@/services/utils/CrudService\";\nimport { CollectionModel } from \"@/services/utils/dtos\";\nimport { CommonOptions } from \"@/services/utils/options\";\n\nexport class CollectionService extends CrudService<CollectionModel> {\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return \"/api/collections\";\n    }\n\n    /**\n     * Imports the provided collections.\n     *\n     * If `deleteMissing` is `true`, all local collections and schema fields,\n     * that are not present in the imported configuration, WILL BE DELETED\n     * (including their related records data)!\n     *\n     * @throws {ClientResponseError}\n     */\n    async import(\n        collections: Array<CollectionModel>,\n        deleteMissing: boolean = false,\n        options?: CommonOptions,\n    ): Promise<true> {\n        options = Object.assign(\n            {\n                method: \"PUT\",\n                body: {\n                    collections: collections,\n                    deleteMissing: deleteMissing,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCrudPath + \"/import\", options).then(() => true);\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseService } from \"@/services/utils/BaseService\";\nimport { ListResult, LogModel } from \"@/services/utils/dtos\";\nimport { CommonOptions, ListOptions, LogStatsOptions } from \"@/services/utils/options\";\n\nexport interface HourlyStats {\n    total: number;\n    date: string;\n}\n\nexport class LogService extends BaseService {\n    /**\n     * Returns paginated logs list.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getList(\n        page = 1,\n        perPage = 30,\n        options?: ListOptions,\n    ): Promise<ListResult<LogModel>> {\n        options = Object.assign({ method: \"GET\" }, options);\n\n        options.query = Object.assign(\n            {\n                page: page,\n                perPage: perPage,\n            },\n            options.query,\n        );\n\n        return this.client.send(\"/api/logs\", options);\n    }\n\n    /**\n     * Returns a single log by its id.\n     *\n     * If `id` is empty it will throw a 404 error.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getOne(id: string, options?: CommonOptions): Promise<LogModel> {\n        if (!id) {\n            throw new ClientResponseError({\n                url: this.client.buildUrl(\"/api/logs/\"),\n                status: 404,\n                response: {\n                    code: 404,\n                    message: \"Missing required log id.\",\n                    data: {},\n                },\n            });\n        }\n\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/logs/\" + encodeURIComponent(id), options);\n    }\n\n    /**\n     * Returns logs statistics.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getStats(options?: LogStatsOptions): Promise<Array<HourlyStats>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/logs/stats\", options);\n    }\n}\n","import { BaseService } from \"@/services/utils/BaseService\";\nimport { CommonOptions } from \"@/services/utils/options\";\n\nexport interface HealthCheckResponse {\n    code: number;\n    message: string;\n    data: { [key: string]: any };\n}\n\nexport class HealthService extends BaseService {\n    /**\n     * Checks the health status of the api.\n     *\n     * @throws {ClientResponseError}\n     */\n    async check(options?: CommonOptions): Promise<HealthCheckResponse> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/health\", options);\n    }\n}\n","import { BaseService } from \"@/services/utils/BaseService\";\nimport { CommonOptions, FileOptions } from \"@/services/utils/options\";\n\nexport class FileService extends BaseService {\n    /**\n     * Builds and returns an absolute record file url for the provided filename.\n     */\n    getUrl(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        if (\n            !filename ||\n            !record?.id ||\n            !(record?.collectionId || record?.collectionName)\n        ) {\n            return \"\";\n        }\n\n        const parts = [];\n        parts.push(\"api\");\n        parts.push(\"files\");\n        parts.push(encodeURIComponent(record.collectionId || record.collectionName));\n        parts.push(encodeURIComponent(record.id));\n        parts.push(encodeURIComponent(filename));\n\n        let result = this.client.buildUrl(parts.join(\"/\"));\n\n        if (Object.keys(queryParams).length) {\n            // normalize the download query param for consistency with the Dart sdk\n            if (queryParams.download === false) {\n                delete queryParams.download;\n            }\n\n            const params = new URLSearchParams(queryParams);\n\n            result += (result.includes(\"?\") ? \"&\" : \"?\") + params;\n        }\n\n        return result;\n    }\n\n    /**\n     * Requests a new private file access token for the current auth model (admin or record).\n     *\n     * @throws {ClientResponseError}\n     */\n    async getToken(options?: CommonOptions): Promise<string> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(\"/api/files/token\", options)\n            .then((data) => data?.token || \"\");\n    }\n}\n","import { BaseService } from \"@/services/utils/BaseService\";\nimport { CommonOptions } from \"@/services/utils/options\";\n\nexport interface BackupFileInfo {\n    key: string;\n    size: number;\n    modified: string;\n}\n\nexport class BackupService extends BaseService {\n    /**\n     * Returns list with all available backup files.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList(options?: CommonOptions): Promise<Array<BackupFileInfo>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups\", options);\n    }\n\n    /**\n     * Initializes a new backup.\n     *\n     * @throws {ClientResponseError}\n     */\n    async create(basename: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    name: basename,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups\", options).then(() => true);\n    }\n\n    /**\n     * Uploads an existing backup file.\n     *\n     * Example:\n     *\n     * ```js\n     * await pb.backups.upload({\n     *     file: new Blob([...]),\n     * });\n     * ```\n     *\n     * @throws {ClientResponseError}\n     */\n    async upload(\n        bodyParams: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups/upload\", options).then(() => true);\n    }\n\n    /**\n     * Deletes a single backup file.\n     *\n     * @throws {ClientResponseError}\n     */\n    async delete(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/backups/${encodeURIComponent(key)}`, options)\n            .then(() => true);\n    }\n\n    /**\n     * Initializes an app data restore from an existing backup.\n     *\n     * @throws {ClientResponseError}\n     */\n    async restore(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/backups/${encodeURIComponent(key)}/restore`, options)\n            .then(() => true);\n    }\n\n    /**\n     * Builds a download url for a single existing backup using an\n     * admin file token and the backup file key.\n     *\n     * The file token can be generated via `pb.files.getToken()`.\n     */\n    getDownloadUrl(token: string, key: string): string {\n        return this.client.buildUrl(\n            `/api/backups/${encodeURIComponent(key)}?token=${encodeURIComponent(token)}`,\n        );\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseAuthStore } from \"@/stores/BaseAuthStore\";\nimport { LocalAuthStore } from \"@/stores/LocalAuthStore\";\nimport { SettingsService } from \"@/services/SettingsService\";\nimport { AdminService } from \"@/services/AdminService\";\nimport { RecordService } from \"@/services/RecordService\";\nimport { CollectionService } from \"@/services/CollectionService\";\nimport { LogService } from \"@/services/LogService\";\nimport { RealtimeService } from \"@/services/RealtimeService\";\nimport { HealthService } from \"@/services/HealthService\";\nimport { FileService } from \"@/services/FileService\";\nimport { BackupService } from \"@/services/BackupService\";\nimport { RecordModel } from \"@/services/utils/dtos\";\nimport {\n    SendOptions,\n    FileOptions,\n    normalizeUnknownQueryParams,\n} from \"@/services/utils/options\";\n\nexport interface BeforeSendResult {\n    [key: string]: any; // for backward compatibility\n    url?: string;\n    options?: { [key: string]: any };\n}\n\n/**\n * PocketBase JS Client.\n */\nexport default class Client {\n    /**\n     * The base PocketBase backend url address (eg. 'http://127.0.0.1.8090').\n     */\n    baseUrl: string;\n\n    /**\n     * Hook that get triggered right before sending the fetch request,\n     * allowing you to inspect and modify the url and request options.\n     *\n     * For list of the possible options check https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n     *\n     * You can return a non-empty result object `{ url, options }` to replace the url and request options entirely.\n     *\n     * Example:\n     * ```js\n     * client.beforeSend = function (url, options) {\n     *     options.headers = Object.assign({}, options.headers, {\n     *         'X-Custom-Header': 'example',\n     *     });\n     *\n     *     return { url, options }\n     * };\n     * ```\n     */\n    beforeSend?: (\n        url: string,\n        options: SendOptions,\n    ) => BeforeSendResult | Promise<BeforeSendResult>;\n\n    /**\n     * Hook that get triggered after successfully sending the fetch request,\n     * allowing you to inspect/modify the response object and its parsed data.\n     *\n     * Returns the new Promise resolved `data` that will be returned to the client.\n     *\n     * Example:\n     * ```js\n     * client.afterSend = function (response, data) {\n     *     if (response.status != 200) {\n     *         throw new ClientResponseError({\n     *             url:      response.url,\n     *             status:   response.status,\n     *             response: { ... },\n     *         });\n     *     }\n     *\n     *     return data;\n     * };\n     * ```\n     */\n    afterSend?: (response: Response, data: any) => any;\n\n    /**\n     * Optional language code (default to `en-US`) that will be sent\n     * with the requests to the server as `Accept-Language` header.\n     */\n    lang: string;\n\n    /**\n     * A replaceable instance of the local auth store service.\n     */\n    authStore: BaseAuthStore;\n\n    /**\n     * An instance of the service that handles the **Settings APIs**.\n     */\n    readonly settings: SettingsService;\n\n    /**\n     * An instance of the service that handles the **Admin APIs**.\n     */\n    readonly admins: AdminService;\n\n    /**\n     * An instance of the service that handles the **Collection APIs**.\n     */\n    readonly collections: CollectionService;\n\n    /**\n     * An instance of the service that handles the **File APIs**.\n     */\n    readonly files: FileService;\n\n    /**\n     * An instance of the service that handles the **Log APIs**.\n     */\n    readonly logs: LogService;\n\n    /**\n     * An instance of the service that handles the **Realtime APIs**.\n     */\n    readonly realtime: RealtimeService;\n\n    /**\n     * An instance of the service that handles the **Health APIs**.\n     */\n    readonly health: HealthService;\n\n    /**\n     * An instance of the service that handles the **Backup APIs**.\n     */\n    readonly backups: BackupService;\n\n    private cancelControllers: { [key: string]: AbortController } = {};\n    private recordServices: { [key: string]: RecordService } = {};\n    private enableAutoCancellation: boolean = true;\n\n    constructor(baseUrl = \"/\", authStore?: BaseAuthStore | null, lang = \"en-US\") {\n        this.baseUrl = baseUrl;\n        this.lang = lang;\n        this.authStore = authStore || new LocalAuthStore();\n\n        // services\n        this.admins = new AdminService(this);\n        this.collections = new CollectionService(this);\n        this.files = new FileService(this);\n        this.logs = new LogService(this);\n        this.settings = new SettingsService(this);\n        this.realtime = new RealtimeService(this);\n        this.health = new HealthService(this);\n        this.backups = new BackupService(this);\n    }\n\n    /**\n     * Returns the RecordService associated to the specified collection.\n     *\n     * @param  {string} idOrName\n     * @return {RecordService}\n     */\n    collection<M = RecordModel>(idOrName: string): RecordService<M> {\n        if (!this.recordServices[idOrName]) {\n            this.recordServices[idOrName] = new RecordService(this, idOrName);\n        }\n\n        return this.recordServices[idOrName];\n    }\n\n    /**\n     * Globally enable or disable auto cancellation for pending duplicated requests.\n     */\n    autoCancellation(enable: boolean): Client {\n        this.enableAutoCancellation = !!enable;\n\n        return this;\n    }\n\n    /**\n     * Cancels single request by its cancellation key.\n     */\n    cancelRequest(requestKey: string): Client {\n        if (this.cancelControllers[requestKey]) {\n            this.cancelControllers[requestKey].abort();\n            delete this.cancelControllers[requestKey];\n        }\n\n        return this;\n    }\n\n    /**\n     * Cancels all pending requests.\n     */\n    cancelAllRequests(): Client {\n        for (let k in this.cancelControllers) {\n            this.cancelControllers[k].abort();\n        }\n\n        this.cancelControllers = {};\n\n        return this;\n    }\n\n    /**\n     * Constructs a filter expression with placeholders populated from a parameters object.\n     *\n     * Placeholder parameters are defined with the `{:paramName}` notation.\n     *\n     * The following parameter values are supported:\n     *\n     * - `string` (_single quotes are autoescaped_)\n     * - `number`\n     * - `boolean`\n     * - `Date` object (_stringified into the PocketBase datetime format_)\n     * - `null`\n     * - everything else is converted to a string using `JSON.stringify()`\n     *\n     * Example:\n     *\n     * ```js\n     * pb.collection(\"example\").getFirstListItem(pb.filter(\n     *    'title ~ {:title} && created >= {:created}',\n     *    { title: \"example\", created: new Date()}\n     * ))\n     * ```\n     */\n    filter(raw: string, params?: { [key: string]: any }): string {\n        if (!params) {\n            return raw;\n        }\n\n        for (let key in params) {\n            let val = params[key];\n            switch (typeof val) {\n                case \"boolean\":\n                case \"number\":\n                    val = \"\" + val;\n                    break;\n                case \"string\":\n                    val = \"'\" + val.replace(/'/g, \"\\\\'\") + \"'\";\n                    break;\n                default:\n                    if (val === null) {\n                        val = \"null\";\n                    } else if (val instanceof Date) {\n                        val = \"'\" + val.toISOString().replace(\"T\", \" \") + \"'\";\n                    } else {\n                        val = \"'\" + JSON.stringify(val).replace(/'/g, \"\\\\'\") + \"'\";\n                    }\n            }\n            raw = raw.replaceAll(\"{:\" + key + \"}\", val);\n        }\n\n        return raw;\n    }\n\n    /**\n     * Legacy alias of `pb.files.getUrl()`.\n     */\n    getFileUrl(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        return this.files.getUrl(record, filename, queryParams);\n    }\n\n    /**\n     * Builds a full client url by safely concatenating the provided path.\n     */\n    buildUrl(path: string): string {\n        let url = this.baseUrl;\n\n        // construct an absolute base url if in a browser environment\n        if (\n            typeof window !== \"undefined\" &&\n            !!window.location &&\n            !url.startsWith(\"https://\") &&\n            !url.startsWith(\"http://\")\n        ) {\n            url = window.location.origin?.endsWith(\"/\")\n                ? window.location.origin.substring(0, window.location.origin.length - 1)\n                : window.location.origin || \"\";\n\n            if (!this.baseUrl.startsWith(\"/\")) {\n                url += window.location.pathname || \"/\";\n                url += url.endsWith(\"/\") ? \"\" : \"/\";\n            }\n\n            url += this.baseUrl;\n        }\n\n        // concatenate the path\n        if (path) {\n            url += url.endsWith(\"/\") ? \"\" : \"/\"; // append trailing slash if missing\n            url += path.startsWith(\"/\") ? path.substring(1) : path;\n        }\n\n        return url;\n    }\n\n    /**\n     * Sends an api http request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async send<T = any>(path: string, options: SendOptions): Promise<T> {\n        options = this.initSendOptions(path, options);\n\n        // build url + path\n        let url = this.buildUrl(path);\n\n        if (this.beforeSend) {\n            const result = Object.assign({}, await this.beforeSend(url, options));\n            if (\n                typeof result.url !== \"undefined\" ||\n                typeof result.options !== \"undefined\"\n            ) {\n                url = result.url || url;\n                options = result.options || options;\n            } else if (Object.keys(result).length) {\n                // legacy behavior\n                options = result as SendOptions;\n                console?.warn &&\n                    console.warn(\n                        \"Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.\",\n                    );\n            }\n        }\n\n        // serialize the query parameters\n        if (typeof options.query !== \"undefined\") {\n            const query = this.serializeQueryParams(options.query);\n            if (query) {\n                url += (url.includes(\"?\") ? \"&\" : \"?\") + query;\n            }\n            delete options.query;\n        }\n\n        // ensures that the json body is serialized\n        if (\n            this.getHeader(options.headers, \"Content-Type\") == \"application/json\" &&\n            options.body &&\n            typeof options.body !== \"string\"\n        ) {\n            options.body = JSON.stringify(options.body);\n        }\n\n        const fetchFunc = options.fetch || fetch;\n\n        // send the request\n        return fetchFunc(url, options)\n            .then(async (response) => {\n                let data: any = {};\n\n                try {\n                    data = await response.json();\n                } catch (_) {\n                    // all api responses are expected to return json\n                    // with the exception of the realtime event and 204\n                }\n\n                if (this.afterSend) {\n                    data = await this.afterSend(response, data);\n                }\n\n                if (response.status >= 400) {\n                    throw new ClientResponseError({\n                        url: response.url,\n                        status: response.status,\n                        data: data,\n                    });\n                }\n\n                return data as T;\n            })\n            .catch((err) => {\n                // wrap to normalize all errors\n                throw new ClientResponseError(err);\n            });\n    }\n\n    /**\n     * Shallow copy the provided object and takes care to initialize\n     * any options required to preserve the backward compatability.\n     *\n     * @param  {SendOptions} options\n     * @return {SendOptions}\n     */\n    private initSendOptions(path: string, options: SendOptions): SendOptions {\n        options = Object.assign({ method: \"GET\" } as SendOptions, options);\n\n        // auto convert the body to FormData, if needed\n        options.body = this.convertToFormDataIfNeeded(options.body);\n\n        // move unknown send options as query parameters\n        normalizeUnknownQueryParams(options);\n\n        // requestKey normalizations for backward-compatibility\n        // ---\n        options.query = Object.assign({}, options.params, options.query);\n        if (typeof options.requestKey === \"undefined\") {\n            if (options.$autoCancel === false || options.query.$autoCancel === false) {\n                options.requestKey = null;\n            } else if (options.$cancelKey || options.query.$cancelKey) {\n                options.requestKey = options.$cancelKey || options.query.$cancelKey;\n            }\n        }\n        // remove the deprecated special cancellation params from the other query params\n        delete options.$autoCancel;\n        delete options.query.$autoCancel;\n        delete options.$cancelKey;\n        delete options.query.$cancelKey;\n        // ---\n\n        // add the json header, if not explicitly set\n        // (for FormData body the Content-Type header should be skipped since the boundary is autogenerated)\n        if (\n            this.getHeader(options.headers, \"Content-Type\") === null &&\n            !this.isFormData(options.body)\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                \"Content-Type\": \"application/json\",\n            });\n        }\n\n        // add Accept-Language header, if not explicitly set\n        if (this.getHeader(options.headers, \"Accept-Language\") === null) {\n            options.headers = Object.assign({}, options.headers, {\n                \"Accept-Language\": this.lang,\n            });\n        }\n\n        // check if Authorization header can be added\n        if (\n            // has valid token\n            this.authStore.token &&\n            // auth header is not explicitly set\n            this.getHeader(options.headers, \"Authorization\") === null\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                Authorization: this.authStore.token,\n            });\n        }\n\n        // handle auto cancelation for duplicated pending request\n        if (this.enableAutoCancellation && options.requestKey !== null) {\n            const requestKey = options.requestKey || (options.method || \"GET\") + path;\n\n            delete options.requestKey;\n\n            // cancel previous pending requests\n            this.cancelRequest(requestKey);\n\n            const controller = new AbortController();\n            this.cancelControllers[requestKey] = controller;\n            options.signal = controller.signal;\n        }\n\n        return options;\n    }\n\n    /**\n     * Converts analyzes the provided body and converts it to FormData\n     * in case a plain object with File/Blob values is used.\n     */\n    private convertToFormDataIfNeeded(body: any): any {\n        if (\n            typeof FormData === \"undefined\" ||\n            typeof body === \"undefined\" ||\n            typeof body !== \"object\" ||\n            body === null ||\n            this.isFormData(body) ||\n            !this.hasBlobField(body)\n        ) {\n            return body;\n        }\n\n        const form = new FormData();\n\n        for (const key in body) {\n            const val = body[key];\n\n            if (typeof val === \"object\" && !this.hasBlobField({ data: val })) {\n                // send json-like values as jsonPayload to avoid the implicit string value normalization\n                let payload: { [key: string]: any } = {};\n                payload[key] = val;\n                form.append(\"@jsonPayload\", JSON.stringify(payload));\n            } else {\n                // in case of mixed string and file/blob\n                const normalizedVal = Array.isArray(val) ? val : [val];\n                for (let v of normalizedVal) {\n                    form.append(key, v);\n                }\n            }\n        }\n\n        return form;\n    }\n\n    /**\n     * Checks if the submitted body object has at least one Blob/File field.\n     */\n    private hasBlobField(body: { [key: string]: any }): boolean {\n        for (const key in body) {\n            const values = Array.isArray(body[key]) ? body[key] : [body[key]];\n            for (const v of values) {\n                if (\n                    (typeof Blob !== \"undefined\" && v instanceof Blob) ||\n                    (typeof File !== \"undefined\" && v instanceof File)\n                ) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Extracts the header with the provided name in case-insensitive manner.\n     * Returns `null` if no header matching the name is found.\n     */\n    private getHeader(\n        headers: { [key: string]: string } | undefined,\n        name: string,\n    ): string | null {\n        headers = headers || {};\n        name = name.toLowerCase();\n\n        for (let key in headers) {\n            if (key.toLowerCase() == name) {\n                return headers[key];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Loosely checks if the specified body is a FormData instance.\n     */\n    private isFormData(body: any): boolean {\n        return (\n            body &&\n            // we are checking the constructor name because FormData\n            // is not available natively in some environments and the\n            // polyfill(s) may not be globally accessible\n            (body.constructor.name === \"FormData\" ||\n                // fallback to global FormData instance check\n                // note: this is needed because the constructor.name could be different in case of\n                //       custom global FormData implementation, eg. React Native on Android/iOS\n                (typeof FormData !== \"undefined\" && body instanceof FormData))\n        );\n    }\n\n    /**\n     * Serializes the provided query parameters into a query string.\n     */\n    private serializeQueryParams(params: { [key: string]: any }): string {\n        const result: Array<string> = [];\n        for (const key in params) {\n            if (params[key] === null) {\n                // skip null query params\n                continue;\n            }\n\n            const value = params[key];\n            const encodedKey = encodeURIComponent(key);\n\n            if (Array.isArray(value)) {\n                // repeat array params\n                for (const v of value) {\n                    result.push(encodedKey + \"=\" + encodeURIComponent(v));\n                }\n            } else if (value instanceof Date) {\n                result.push(encodedKey + \"=\" + encodeURIComponent(value.toISOString()));\n            } else if (typeof value !== null && typeof value === \"object\") {\n                result.push(encodedKey + \"=\" + encodeURIComponent(JSON.stringify(value)));\n            } else {\n                result.push(encodedKey + \"=\" + encodeURIComponent(value));\n            }\n        }\n\n        return result.join(\"&\");\n    }\n}\n","import { BaseAuthStore, AuthModel } from \"@/stores/BaseAuthStore\";\n\nexport type AsyncSaveFunc = (serializedPayload: string) => Promise<void>;\n\nexport type AsyncClearFunc = () => Promise<void>;\n\ntype queueFunc = () => Promise<void>;\n\n/**\n * AsyncAuthStore is a helper auth store implementation\n * that could be used with any external async persistent layer\n * (key-value db, local file, etc.).\n *\n * Here is an example with the React Native AsyncStorage package:\n *\n * ```\n * import AsyncStorage from \"@react-native-async-storage/async-storage\";\n * import PocketBase, { AsyncAuthStore } from \"pocketbase\";\n *\n * const store = new AsyncAuthStore({\n *     save:    async (serialized) => AsyncStorage.setItem(\"pb_auth\", serialized),\n *     initial: AsyncStorage.getItem(\"pb_auth\"),\n * });\n *\n * const pb = new PocketBase(\"https://example.com\", store)\n * ```\n */\nexport class AsyncAuthStore extends BaseAuthStore {\n    private saveFunc: AsyncSaveFunc;\n    private clearFunc?: AsyncClearFunc;\n    private queue: Array<queueFunc> = [];\n\n    constructor(config: {\n        // The async function that is called every time\n        // when the auth store state needs to be persisted.\n        save: AsyncSaveFunc;\n\n        /// An *optional* async function that is called every time\n        /// when the auth store needs to be cleared.\n        ///\n        /// If not explicitly set, `saveFunc` with empty data will be used.\n        clear?: AsyncClearFunc;\n\n        // An *optional* initial data to load into the store.\n        initial?: string | Promise<any>;\n    }) {\n        super();\n\n        this.saveFunc = config.save;\n        this.clearFunc = config.clear;\n\n        this._enqueue(() => this._loadInitial(config.initial));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, model?: AuthModel): void {\n        super.save(token, model);\n\n        let value = \"\";\n        try {\n            value = JSON.stringify({ token, model });\n        } catch (err) {\n            console.warn(\"AsyncAuthStore: failed to stringify the new state\");\n        }\n\n        this._enqueue(() => this.saveFunc(value));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear(): void {\n        super.clear();\n\n        if (this.clearFunc) {\n            this._enqueue(() => this.clearFunc!());\n        } else {\n            this._enqueue(() => this.saveFunc(\"\"));\n        }\n    }\n\n    /**\n     * Initializes the auth store state.\n     */\n    private async _loadInitial(payload?: string | Promise<any>) {\n        try {\n            payload = await payload;\n\n            if (payload) {\n                let parsed;\n                if (typeof payload === \"string\") {\n                    parsed = JSON.parse(payload) || {};\n                } else if (typeof payload === \"object\") {\n                    parsed = payload;\n                }\n\n                this.save(parsed.token || \"\", parsed.model || null);\n            }\n        } catch (_) {}\n    }\n\n    /**\n     * Appends an async function to the queue.\n     */\n    private _enqueue(asyncCallback: () => Promise<void>) {\n        this.queue.push(asyncCallback);\n\n        if (this.queue.length == 1) {\n            this._dequeue();\n        }\n    }\n\n    /**\n     * Starts the queue processing.\n     */\n    private _dequeue() {\n        if (!this.queue.length) {\n            return;\n        }\n\n        this.queue[0]().finally(() => {\n            this.queue.shift();\n\n            if (!this.queue.length) {\n                return;\n            }\n\n            this._dequeue();\n        });\n    }\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$d3824bf2ef2465db$export$2e2bcd8739ae039","$17YkW","buildPost","title","body","author","author_id","buildUser","name","username","password","passwordConfirm","emailVisibility","isAdmin","validateInput","input","validity","valid","valueMissing","patternMismatch","tooShort","validateForm","form","elements","error","previousElementSibling","children","value","console","log","default","showError","checkValidity","$0d253f80dc492c18$export$2e2bcd8739ae039","updateHeading","currentUser","authHeading","document","getElementById","style","display","textContent","updateUI","button","clearPosts","parent","hasChildNodes","removeChild","firstChild","openModal","modal","showModal","buildPosts","posts","postsContainer","post","createElement","classList","add","date","Date","created","toDateString","byline","appendChild","del","innerHTML","onclick","deletionModal","dataset","post_id","divider","announcement","closeModal","close","element","$4efa53a9ba85f959$export$2e2bcd8739ae039","$4efa53a9ba85f959$var$pb","$1LIL3","$4efa53a9ba85f959$var$backend","getPosts","collection","getFullList","sort","pushPost","getCurrentUser","create","deletePost","delete","createUser","user","data","authUser","authWithPassword","authStore","model","logoutUser","clear","$5582cf41b70f685b$var$t","$5582cf41b70f685b$export$2e2bcd8739ae039","$5582cf41b70f685b$export$dcaf143e197b2cd2","constructor","url","status","response","isAbort","originalError","setPrototypeOf","prototype","DOMException","message","cause","includes","toJSON","$5582cf41b70f685b$var$e","$5582cf41b70f685b$export$879d2f108927fb90","t","i","assign","r","encode","$5582cf41b70f685b$var$defaultEncode","test","TypeError","o","a","maxAge","isNaN","isFinite","Math","floor","domain","path","expires","toString","valueOf","toUTCString","httpOnly","secure","priority","toLowerCase","sameSite","$5582cf41b70f685b$var$defaultDecode","indexOf","decodeURIComponent","encodeURIComponent","$5582cf41b70f685b$export$26ddc56bc995240a","split","map","charCodeAt","slice","join","JSON","parse","$5582cf41b70f685b$export$b007d77a962aa175","keys","length","exp","now","atob","String","replace","charAt","fromCharCode","$5582cf41b70f685b$var$s","$5582cf41b70f685b$export$68a044b9d3f6e888","baseToken","baseModel","_onChangeCallbacks","token","isValid","type","isAuthRecord","save","triggerChange","loadFromCookie","$5582cf41b70f685b$export$2314e25186e9360","decode","lastIndexOf","trim","Array","isArray","exportToCookie","stringify","Blob","size","email","onChange","push","splice","$5582cf41b70f685b$export$6439a4b85bcd7f5d","storageFallback","storageKey","_bindStorageEvent","_storageGet","_storageSet","_storageRemove","window","localStorage","getItem","setItem","removeItem","addEventListener","key","$5582cf41b70f685b$var$BaseService","client","$5582cf41b70f685b$var$SettingsService","getAll","method","send","update","testS3","filesystem","then","testEmail","template","generateAppleClientSecret","clientId","teamId","keyId","privateKey","duration","$5582cf41b70f685b$export$d8ebe4a1f8b281ca","_getFullList","batch","getList","query","page","perPage","baseCrudPath","items","getFirstListItem","requestKey","filter","skipTotal","getOne","buildUrl","request","concat","$5582cf41b70f685b$var$normalizeLegacyOptionsArgs","warn","$5582cf41b70f685b$var$resetAutoRefresh","_resetAutoRefresh","$5582cf41b70f685b$export$33af9b5749be502a","collectionId","authResponse","admin","identity","autoRefreshThreshold","autoRefresh","beforeSend","sendOptions","c","l","headers","authRefresh","bind","requestPasswordReset","confirmPasswordReset","$5582cf41b70f685b$var$i","$5582cf41b70f685b$export$d4eab50bd87f5014","$5582cf41b70f685b$export$94618cb2db738d0c","arguments","eventSource","subscriptions","lastSentSubscriptions","maxConnectTimeout","reconnectAttempts","maxReconnectAttempts","predefinedReconnectIntervals","pendingConnects","isConnected","subscribe","listener","submitSubscriptions","connect","unsubscribeByTopicAndListener","unsubscribe","getSubscriptionsByTopic","hasSubscriptionListeners","removeEventListener","disconnect","unsubscribeByPrefix","startsWith","addAllSubscriptionListeners","getNonEmptySubscriptionKeys","getSubscriptionsCancelKey","catch","removeAllSubscriptionListeners","Promise","resolve","reject","initConnect","clearTimeout","connectTimeoutId","setTimeout","connectErrorHandler","EventSource","onerror","lastEventId","hasUnsentSubscriptions","reconnectTimeoutId","cancelRequest","$5582cf41b70f685b$export$1b7d28e1ebf40328","collectionIdOrName","baseCollectionPath","realtime","collectionName","record","listAuthMethods","usernamePassword","emailPassword","authProviders","authWithOAuth2Code","provider","codeVerifier","redirectUrl","createData","authWithOAuth2","find","cleanup","urlCallback","$5582cf41b70f685b$var$openBrowserPopup","state","scopes","scope","_replaceQueryParams","authUrl","location","href","requestVerification","confirmVerification","verified","requestEmailChange","newEmail","confirmEmailChange","listExternalAuths","unlinkExternalAuth","substring","hasOwnProperty","open","innerWidth","innerHeight","$5582cf41b70f685b$export$133889e600929275","import","collections","deleteMissing","$5582cf41b70f685b$export$e2c5c1c0df6e287f","getStats","$5582cf41b70f685b$var$HealthService","check","$5582cf41b70f685b$var$FileService","getUrl","download","URLSearchParams","getToken","$5582cf41b70f685b$var$BackupService","upload","restore","getDownloadUrl","cancelControllers","recordServices","enableAutoCancellation","baseUrl","lang","admins","files","logs","settings","health","backups","autoCancellation","abort","cancelAllRequests","toISOString","replaceAll","getFileUrl","origin","endsWith","pathname","initSendOptions","options","serializeQueryParams","getHeader","fetch","json","afterSend","convertToFormDataIfNeeded","params","$autoCancel","$cancelKey","isFormData","Authorization","AbortController","signal","FormData","hasBlobField","append","File","ClientResponseError","errData","super","this","fieldContentRegExp","cookieParse","str","result","defaultDecode","index","eqIdx","endIdx","undefined","val","_","cookieSerialize","opt","defaultEncode","isDate","atobPolyfill","getTokenPayload","encodedPayload","isTokenExpired","expirationThreshold","payload","bs","buffer","bc","idx","output","defaultCookieKey","BaseAuthStore","cookie","rawData","defaultOptions","resultLength","extraProps","prop","callback","fireImmediately","LocalAuthStore","rawValue","normalizedVal","BaseService","SettingsService","bodyParams","toEmail","emailTemplate","CrudService","batchOrqueryParams","responseData","item","batchSize","async","list","normalizeLegacyOptionsArgs","legacyWarn","baseOptions","bodyOrOptions","hasQuery","resetAutoRefresh","AdminService","success","authData","registerAutoRefresh","threshold","refreshFunc","reauthenticateFunc","oldBeforeSend","oldModel","unsubStoreChange","newToken","oldToken","resetToken","knownSendOptionsKeys","normalizeUnknownQueryParams","RealtimeService","Infinity","topic","serialized","msgEvent","needToSubmit","subs","keyPrefix","hasAtleastOneTopic","exist","keyToCheck","retries","p","connectSubs","latestTopics","timeout","fromReconnect","RecordService","batchOrOptions","usernameOrEmail","args","config","eagerDefaultPopup","openBrowserPopup","oldState","replacements","passwordResetToken","verificationToken","emailChangeToken","recordId","urlPath","parsedParams","rawParams","param","pair","width","height","windowWidth","windowHeight","left","top","CollectionService","LogService","HealthService","FileService","filename","queryParams","parts","BackupService","basename","Client","idOrName","enable","k","raw","controller","values","encodedKey","AsyncAuthStore","queue","saveFunc","clearFunc","_enqueue","_loadInitial","initial","parsed","asyncCallback","_dequeue","finally","shift"],"version":3,"file":"index.53236992.js.map"}